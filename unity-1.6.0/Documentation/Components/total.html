
<ul class="toc"><li class="toclevel"><a href='comp-MeshGroup.html'> Meshes</a></li><ul class="toc"><li class="toclevel"><a href='class-MeshFilter.html'>Mesh Filter</a></li><li class="toclevel"><a href='class-MeshMorpher.html'>Mesh Morpher</a></li><li class="toclevel"><a href='class-TextMesh.html'> Text Mesh</a></li><li class="toclevel"><a href='class-MeshRenderer.html'>Mesh Renderer</a></li><li class="toclevel"><a href='class-Pipeline.html'>Pipeline</a></li><li class="toclevel"><a href='class-SkinnedMeshFilter.html'>Skinned Mesh Filter</a></li></ul><li class="toclevel"><a href='comp-ParticlesGroup.html'>Particle systems</a></li><ul class="toc"><li class="toclevel"><a href='class-EllipsoidParticleEmitter.html'>Ellipsoid Particle Emitter</a></li><li class="toclevel"><a href='class-MeshParticleEmitter.html'> Mesh Particle Emitter</a></li><li class="toclevel"><a href='class-ParticleAnimator.html'> Particle Animator</a></li><li class="toclevel"><a href='class-WorldParticleCollider.html'>Particle Collider</a></li><li class="toclevel"><a href='class-TrailRenderer.html'>Trail Renderer</a></li><li class="toclevel"><a href='class-ParticleRenderer.html'>Particle Renderer</a></li><li class="toclevel"><a href='class-LineRenderer.html'>Line Renderer</a></li></ul><li class="toclevel"><a href='comp-DynamicsGroup.html'>Physics</a></li><ul class="toc"><li class="toclevel"><a href='class-Rigidbody.html'>Rigidbody</a></li><li class="toclevel"><a href='class-CharacterController.html'>Character Controller</a></li><li class="toclevel"><a href='class-BoxCollider.html'>Box Collider</a></li><li class="toclevel"><a href='class-SphereCollider.html'>Sphere Collider</a></li><li class="toclevel"><a href='class-CapsuleCollider.html'>Capsule Collider</a></li><li class="toclevel"><a href='class-MeshCollider.html'>Mesh Collider</a></li><li class="toclevel"><a href='class-WheelCollider.html'>Wheel Collider</a></li><li class="toclevel"><a href='class-HingeJoint.html'>Hinge Joint</a></li><li class="toclevel"><a href='class-SpringJoint.html'>Spring Joint</a></li><li class="toclevel"><a href='class-FixedJoint.html'>Fixed Joint</a></li><li class="toclevel"><a href='class-ConstantForce.html'>Constant Force</a></li><li class="toclevel"><a href='class-PhysicMaterial.html'>Physic Material</a></li><li class="toclevel"><a href='class-CharacterJoint.html'>Character Joint</a></li></ul><li class="toclevel"><a href='comp-AudioGroup.html'>Audio</a></li><ul class="toc"><li class="toclevel"><a href='class-AudioListener.html'>Audio Listener</a></li><li class="toclevel"><a href='class-AudioSource.html'>Audio Source</a></li></ul><li class="toclevel"><a href='comp-GameObjectGroup.html'>GameObject</a></li><ul class="toc"><li class="toclevel"><a href='class-GameObject.html'>GameObject</a></li></ul><li class="toclevel"><a href='comp-TransformationGroup.html'>Transforms</a></li><ul class="toc"><li class="toclevel"><a href='class-Transform.html'>Transform</a></li></ul><li class="toclevel"><a href='comp-RenderingGroup.html'>Rendering</a></li><ul class="toc"><li class="toclevel"><a href='class-Camera.html'>Camera</a></li><li class="toclevel"><a href='class-Light.html'>Light</a></li><li class="toclevel"><a href='class-Projector.html'>Projector</a></li><li class="toclevel"><a href='class-Halo.html'>Halo</a></li><li class="toclevel"><a href='class-LensFlare.html'>Lens Flare</a></li><li class="toclevel"><a href='class-GuiTexture.html'>GUI Texture</a></li><li class="toclevel"><a href='class-GuiText.html'>GUI Text</a></li><li class="toclevel"><a href='class-Skybox.html'>Skybox</a></li><li class="toclevel"><a href='class-GUILayer.html'>GUI Layer</a></li><li class="toclevel"><a href='class-FlareLayer.html'>Flare Layer</a></li><li class="toclevel"><a href='class-HaloLayer.html'>Halo Layer</a></li></ul><li class="toclevel"><a href='comp-ImageEffects.html'>Image Effects</a></li><ul class="toc"><li class="toclevel"><a href='script-GlowEffect.html'>Glow image effect</a></li><li class="toclevel"><a href='script-BlurEffect.html'>Blur effect</a></li><li class="toclevel"><a href='script-NoiseEffect.html'>Noise image effect</a></li><li class="toclevel"><a href='script-ColorCorrectionEffect.html'>Color Correction image effect</a></li><li class="toclevel"><a href='script-EdgeDetectEffect.html'>Edge Detection image effect</a></li><li class="toclevel"><a href='script-GrayscaleEffect.html'>Grayscale image effect</a></li><li class="toclevel"><a href='script-TwirlEffect.html'>Twirl image effect</a></li><li class="toclevel"><a href='script-MotionBlur.html'>Motion Blur effect</a></li><li class="toclevel"><a href='script-VortexEffect.html'>Vortex image effect</a></li><li class="toclevel"><a href='script-SepiaToneEffect.html'>Sepia Tone image effect</a></li></ul><li class="toclevel">Wizards</li><ul class="toc"><li class="toclevel"><a href='wizard-RagdollWizard.html'>Ragdoll Wizard</a></li></ul><li class="toclevel"><a href='comp-AnimationGroup.html'>Animation</a></li><ul class="toc"><li class="toclevel"><a href='class-Animation.html'> Animation</a></li><li class="toclevel"><a href='class-AnimationClip.html'> Animation Clip</a></li></ul><li class="toclevel"><a href='comp-ManagerGroup.html'>Managers</a></li><ul class="toc"><li class="toclevel"><a href='class-AudioManager.html'>Audio Manager</a></li><li class="toclevel"><a href='class-TagManager.html'>Tag Manager</a></li><li class="toclevel"><a href='class-TimeManager.html'>Time Manager</a></li><li class="toclevel"><a href='class-InputManager.html'>Input Manager</a></li><li class="toclevel"><a href='class-PhysicsManager.html'>Physics Manager</a></li><li class="toclevel"><a href='class-QualitySettings.html'>Quality Settings</a></li><li class="toclevel"><a href='class-PlayerSettings.html'>Player Settings</a></li><li class="toclevel"><a href='class-RenderSettings.html'>Render Settings</a></li></ul><li class="toclevel"><a href='comp-AssetsGroup.html'>Asset components</a></li><ul class="toc"><li class="toclevel"><a href='class-Texture2D.html'>Texture 2D</a></li><li class="toclevel"><a href='class-Mesh.html'> Importing 3D models</a></li><li class="toclevel"><a href='class-AudioClip.html'>Audio Clip</a></li><li class="toclevel"><a href='class-Font.html'>Font</a></li><li class="toclevel"><a href='class-Flare.html'> Flare</a></li><li class="toclevel"><a href='class-RenderTexture.html'>Render Texture</a></li><li class="toclevel"><a href='class-Material.html'>Material</a></li><li class="toclevel"><a href='class-CubemapTexture.html'>Cubemap Texture</a></li></ul></ul>


<p>3D meshes are the main graphics primitive of Unity. Like all other graphics, they are constructed with <b>pipelines</b>. A Mesh pipeline normally contains two filters: A producer and a renderer.
</p>

<h2>Producers</h2>
<ul><li> <a href="../Components/class-MeshFilter.html">Mesh Filter</a>
</li><li> <a href="../Components/class-MeshMorpher.html">Mesh Morpher</a>
</li><li> <a href="../Components/class-TextMesh.html">TextMesh</a>
</li></ul>

<h2>Renderer</h2>
<ul><li> <a href="../Components/class-MeshRenderer.html">Mesh Renderer</a>
</li></ul>


<p>The <b>Mesh Filter</b> takes a mesh from your assets and inserts it into the rendering <a href="../Components/class-Pipeline.html">pipeline</a>. Later on, a <a href="../Components/class-MeshRenderer.html">Mesh Renderer</a> receives the mesh and draws it, so it will appear on the screen.
</p>

<p><img class='figure' src='images/class-MeshFilter-0.jpg' />
</p>

<p><i>A <b>Mesh Filter</b> combined with a <b>Mesh Renderer</b> makes the model appear on screen. Car model courtesy of ATI Technologies Inc.</i>
</p>

<p>When importing mesh assets, Unity automatically creates a <b>Mesh Filter</b> or a <a href="../Components/class-SkinnedMeshFilter.html">Skinned Mesh Filter</a>, depending on whether the mesh is skinned or not.
</p>

<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Mesh</nobr></b></td><td> Reference to a <a href="../Components/class-Mesh.html">Mesh</a> that is inserted into the pipeline. The mesh is stored in your project.
<p></td></tr></tr></table>
</p>

<p>To see the mesh in your scene, add a <a href="../Components/class-MeshRenderer.html">Mesh Renderer</a> to the game object.  It should be added automatically, but you will have to manually re-add it if you remove it from your object.  If the <b>Mesh Renderer</b> is not present, the object will still exist in your scene (and computer memory) but it will not be drawn.
</p>



<p>The Mesh morpher filter takes a number of meshes and morphs between them over time.
</p>

<p><img class='figure' src='images/class-MeshMorpher-0.jpg' />
</p>

<p><i>The Mesh Morpher Component</i>
</p>

<h2>Properties</h2>
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Enabled</nobr></b></td><td> If enabled, the Mesh Morpher cycles between the different frames automatically.
</td></tr><tr><td><b><nobr>Speed</nobr></b></td><td> How many frames the mesh morpher goes through in one second.
</td></tr><tr><td><b><nobr>Meshes</nobr></b></td><td> A list of meshes to cycle through.
<dl><dt>Size</dt><dd> Number of meshes available to morph between</dd><dt>Element 0</dt><dd> Reference to a Mesh to be used at this stage of the morph</dd></dl>
</td></tr><tr><td><b><nobr>Frame</nobr></b></td><td> The frame currently shown.
<p></td></tr></tr></table>
</p>

<h2>Details</h2>
<p>The Mesh Morpher works a lot like the Mesh Filter. You want to have a <a href="../Components/class-MeshRenderer.html">Mesh Renderer</a> as the other filter in the object.
</p>


<h2>Hints</h2>
<p><ul><li>
The number of Vertices and Polygons should be identical across all the meshes being morphed, in order to avoid fragmented transitions.
</li><li>You need to make sure that your 3D modeler saves the vertices in the same order for all meshes.
</li></ul>
</p>



<p>This components generates 3D geometry that displays text strings.
</p>

<p><img class='figure' src='images/class-TextMesh-0.jpg' />
</p>

<p><i>The Text Mesh</i>
</p>

<p>You can create a new Text Mesh from <b>Game Object -&gt; Create Other -&gt; 3D Text</b>.
</p>

<h2> Properties</h2>

<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Text</nobr></b></td><td> The text that will be rendered
</td></tr><tr><td><b><nobr>Offset Z</nobr></b></td><td> How far should the text be offset from the transform.position.z when drawing
</td></tr><tr><td><b><nobr>Character Size</nobr></b></td><td> The size of each character (This scales the whole text)
</td></tr><tr><td><b><nobr>Line Spacing</nobr></b></td><td> How much space will be in-between lines of text.
</td></tr><tr><td><b><nobr>Anchor</nobr></b></td><td> Which point of the text shares the position of the Transform.
</td></tr><tr><td><b><nobr>Alignment</nobr></b></td><td> How multiple lines are aligned within the GUIText.
</td></tr><tr><td><b><nobr>Tab Size</nobr></b></td><td> How much space will be inserted for a tab '\t' character. As a multiplum of the space character offset.
</td></tr><tr><td><b><nobr>Font</nobr></b></td><td> The <a href="../Components/class-Font.html">font</a> to use when rendering the text.
<p></td></tr></tr></table>
</p>

<h2> Details</h2>

<p>Text Meshes can be used for rendering road signs, graffiti etc.  The Text Mesh places text in the 3D scene. To make generic 2D text for GUIs, use a <a href="../Components/class-GuiText.html">GUI Text</a> component instead.
</p>

<p>Follow these steps to create a Text Mesh with a custom Font:
<table><tr><td><div class='cbox'><div class='cbox-data'>
<ol><li> Import a font by dragging a true type font - a .ttf file - from the finder into the project view.
</li><li> Select the imported font in the project view.
</li><li> Choose <b>Game Object -&gt; Create Other -&gt; 3D Text</b>.
</li></ol>

</div></div></td></tr></table>
You have now created a text mesh with your custom true type font.  You can scale the text and move it around using the scene view's Transform controls.
</p>

<h2>Hints</h2>
<p><ul><li>
When entering text into the <b>Text</b> property, you can create a line break by holding <i>Alt</i> and pressing <i>Return</i>.
</li><li>You can download free true type fonts from <a class="wiki"  href="http://www.1001freefonts.com/fonts/afonts.htm">http://www.1001freefonts.com/fonts/afonts.htm</a> (download the windows fonts since they contain true type fonts).
</li><li>If you are scripting the <b>Text</b> property, you can add line breaks by inserting the escape character &quot;\n&quot; in your strings.
</li></ul>
</p>



<p>The Mesh Renderer takes the geometry passed through the rendering <a href="../Components/class-Pipeline.html">pipeline</a> and renders it at the position defined by the object's <a href="../Components/class-Transform.html">Transform</a> component.
</p>

<p><img class='figure' src='images/class-MeshRenderer-0.jpg' />
</p>

<p><i>A Mesh Renderer together with Mesh Filter makes the model appear on screen. Car model courtesy of ATI Technologies Inc.</i>
</p>

<h2>Properties</h2>
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Materials</nobr></b></td><td> A list of materials to render model with.
<p></td></tr></tr></table>
</p>

<h2>Details</h2>

<p>Meshes imported from 3D packages can use multiple <a href="../Manual/Materials.html">materials</a>. For each material there is an entry in Mesh Renderer's Materials list.
</p>



<p>A pipeline is a container for any filters, modifiers and renderers. Together, all of them make things appear or animate on the screen. Whenever you add a filter eg. <a href="../Components/class-MeshFilter.html">MeshFilter</a> to a game object a Pipeline is automatically added.
</p>



<p>The Skinned Mesh Filter is automatically added to imported meshes when the imported mesh is skinned.
</p>

<p><img class='figure' src='images/class-SkinnedMeshFilter-0.jpg' />
</p>

<p><i>An Animated Character rendered using the Skinned Mesh Filter and Mesh Renderer</i>
</p>


<h2> Properties</h2>
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Update When Offscreen</nobr></b></td><td> Should the skinned mesh be updated when offscreen. This also disables updating animations.
</td></tr><tr><td><b><nobr>Skin Normals</nobr></b></td><td> If enabled, normal will be updated with the bone animation.
</td></tr><tr><td><b><nobr>Quality</nobr></b></td><td> The maximum amount of bones affecting every vertex.
</td></tr><tr><td><b><nobr>Animation</nobr></b></td><td> The current animation (change this via scripting).
<p></td></tr></tr></table>
</p>

<h2> Details</h2>

<p>Skinned meshes are used for rendering characters. Characters are animated using bones, and every bone affects a part of the mesh.
Multiple bones can affect the same vertex and are weighted.  The main advantage to using boned characters in Unity is you can enable the bones to be affected by physics, making your characters into ragdolls.  You can enable/disable bones via scripting, so your character instantly goes ragdoll when it is hit by an explosion.
</p>

<p><img class='figure' src='images/class-SkinnedMeshFilter-1.jpg' />
</p>

<p><i>A Skinned Mesh enabled as a Ragdoll</i>
</p>

<h3>Skin Normals</h3>
<p>When Skin Normals is enabled, normals will be correctly animated with the bones. This makes your character correctly react to lights.
If it is disabled the normals from the character in bind pose will be used.
</p>

<p>Skinning Normals comes at a slight performance cost. In some situations correct lighting is not necessary and you can get away with disabling this option.
Play with it and see if it makes difference in your particular situation. If you can't see a difference, disable Skin Normals.
</p>

<h3>Quality</h3>
<p>Unity can skin every vertex with either 1, 2, or 4 bones. 4 bone weights look nicest and are most expensive. 2 Bone weights is a good compromise and is most commonly used in games.
</p>

<p>If Quality is set to automatic, the <a href="../Components/class-QualitySettings.html">Quality Settings</a> <b>Blend Weights</b> value will be used. This allows end-users to choose a quality setting that gives them optimum performance.
</p>

<h3>Update When Offscreen</h3>

<p>When a Skinned Mesh is not visible their skin will not be updated. That means the animation will stop playing until it comes onscreen again. This is an important performance optimization. That allows you to have a lot of characters running around not taking up any processing power when they are not visible.
</p>

<p>For characters you should always check this option off in order to gain performance.
</p>

<p>Sometimes however, the bounding volume will change a lot based on a change in the animation. Thus you need to enable offscreen updating to prevent object from suddenly appearing on screen.
</p>

<h2>Hints</h2>
<p><ul><li>
Skinned meshes can be imported from Maya or Cinema4D.
</li></ul>
</p>



<p>Particle systems in Unity are used to make clouds of smoke, steam, fire and other atmospheric effects. Particle systems work by using one or two textures &amp; drawing them many times, creating a chaotic effect.
</p>

<p><img class='figure' src='images/comp-ParticlesGroup-0.jpg' />
</p>

<p>One of the default explosions included in unity and the two textures it is made of. The orange texture is used for the flames in the bottom of the explosion, and the grayscale one is used to make the smoke near the top.
</p>

<p>A typical particle system in Unity is an object that contains a Particle Emitter, a Particle Animator and a Particle Renderer component. The <a href="../Components/class-EllipsoidParticleEmitter.html">emitter</a> generates the particles, the <a href="../Components/class-ParticleAnimator.html">animator</a> moves them over time, and the <a href="../Components/class-ParticleRenderer.html">renderer</a> gets them on the screen.
</p>

<p>If you want your particles to interact with the world, add a <a href="../Components/class-WorldParticleCollider.html">particle collider</a> component to the object.
</p>

<h2>See also</h2>

<p><ul class="toc"><li class="toclevel"><a href="../Components/class-EllipsoidParticleEmitter.html">EllipsoidParticleEmitter</a></li><li class="toclevel"><a href="../Components/class-MeshParticleEmitter.html">MeshParticleEmitter</a></li><li class="toclevel"><a href="../Components/class-ParticleAnimator.html">ParticleAnimator</a></li><li class="toclevel"><a href="../Components/class-WorldParticleCollider.html">WorldParticleCollider</a></li><li class="toclevel"><a href="../Components/class-TrailRenderer.html">TrailRenderer</a></li><li class="toclevel"><a href="../Components/class-ParticleRenderer.html">ParticleRenderer</a></li><li class="toclevel"><a href="../Components/class-LineRenderer.html">LineRenderer</a></li></ul>
</p>


<p>The Ellipsoid Particle Emitter spawns particles inside a sphere. Use the <b>Ellipsoid</b> property below to scale &amp; stretch the sphere.
</p>

<p><img class='figure' src='images/class-EllipsoidParticleEmitter-0.jpg' />
</p>

<p><i>The Ellipsoid Particle Emitter</i>
</p>


<h2>Properties</h2>

<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
 Emit</nobr></b></td><td> If enabled, the emitter will emit particles.
</td></tr><tr><td><b><nobr>Min Size</nobr></b></td><td> The minimum size each particle can be at the time when it is spawned.
</td></tr><tr><td><b><nobr>Max Size</nobr></b></td><td> The maximum size each particle can be at the time when it is spawned.
</td></tr><tr><td><b><nobr>Min Energy</nobr></b></td><td> The minimum lifetime of each particle, measured in seconds.
</td></tr><tr><td><b><nobr>Max Energy</nobr></b></td><td> The maximum lifetime of each particle, measured in seconds.
</td></tr><tr><td><b><nobr>Min Emission</nobr></b></td><td> The minimum number of particles that will be spawned every second.
</td></tr><tr><td><b><nobr>Max Emission</nobr></b></td><td> The maximum number of particles that will be spawned every second.
</td></tr><tr><td><b><nobr>World Velocity</nobr></b></td><td> The starting speed of particles in world space, along X, Y, and Z.
</td></tr><tr><td><b><nobr>Local Velocity</nobr></b></td><td> The starting speed of particles along X, Y, and Z, measured in the object's orientation.
</td></tr><tr><td><b><nobr>Rnd Velocity</nobr></b></td><td> A random speed along X, Y, and Z that is added to the velocity.
</td></tr><tr><td><b><nobr>Emitter Velocity Scale</nobr></b></td><td> The amount of the emitter's speed that the particles inherit.
</td></tr><tr><td><b><nobr>Simulate In World Space</nobr></b></td><td> If enabled, the particles don't move when the emitter moves. If false, when you move the emitter, the particles follow it around.
</td></tr><tr><td><b><nobr>One Shot</nobr></b></td><td> If enabled, the particle numbers specified by min &amp; max emission is spawned all at once. If disabled, the particles are generated in a long stream.
</td></tr><tr><td><b><nobr>Ellipsoid</nobr></b></td><td> Scale of the sphere along X, Y, and Z that the particles are spawned inside.
</td></tr><tr><td><b><nobr>MinEmitterRange</nobr></b></td><td> Determines an empty area in the center of the sphere - use this to make particles appear on the edge of the sphere.
<p></td></tr></tr></table>
</p>


<h2>Details</h2>
<p>Ellipsoid Particle Emitters (EPEs) are the basic emitter, and are included when you choose to add a Particle System to your scene from Components -&gt; Particles -&gt; Particle System.  You can define the boundaries for the particles to be spawned, and give the particles an initial velocity.  From here, use the <a href="../Components/class-ParticleAnimator.html">Particle Animator</a> to manipulate how your particles will change over time to achieve interesting effects.
</p>

<p><img class='figure' src='images/class-EllipsoidParticleEmitter-1.jpg' />
</p>

<p><i>An EPE applied to a sphere</i>
</p>

<p>Particle Emitters work in conjunction with <a href="../Components/class-ParticleAnimator.html">Particle Animators</a> and <a href="../Components/class-ParticleRenderer.html">Particle Renderers</a> to create, manipulate, and display Particle Systems.  All three components must be present on an object before the particles will behave correctly.  When particles are being emitted, all different velocities are added together to create the final velocity.
</p>


<h3>Spawning Properties</h3>

<p>Spawning properties like <b>Size</b>, <b>Energy</b>, <b>Emission</b>, and <b>Velocity</b> will give your particle system distinct personality when trying to achieve different effects.  Having a small <b>Size</b> could simulate fireflies or stars in the sky.  A large <b>Size</b> could simulate dust clouds in a musky old building.
</p>

<p><b>Energy</b> and <b>Emission</b> will control how long your particles remain onscreen and how many particles can appear at any one time.  For example, a rocket might have high <b>Emission</b> to simulate density of smoke, and high <b>Energy</b> to simulate the slow dispersion of smoke into the air.
</p>

<p><b>Velocity</b> will control how your particles move.  You might want to change your <b>Velocity</b> in scripting to achieve interesting effects, or if you want to simulate a constant effect like wind, set your X and Z <b>Velocity</b> to make your particles blow away.
</p>

<h3>Simulate in World Space</h3>

<p>If this is disabled, the position of each individual particle will always translate relative to the <b>Position</b> of the emitter.  When the emitter moves, the particles will move along with it.  If you have <b>Simulate in World Space</b> enabled, particles will not be affected by the translation of the emitter.  For example, if you have a fireball that is spurting flames that rise, the flames will be spawned and float up in space as the fireball gets further away.  If <b>Simulate in World Space</b> is disabled, those same flames will move across the screen along with the fireball.
</p>

<h3>Emitter Velocity Scale</h3>

<p>This property will only apply if <b>Simulate in World Space</b> is enabled.
</p>

<p>If this property is set to 1, the particles will inherit the exact translation of the emitter at the time they are spawned.  If it is set to 2, the particles will inherit double the emitter's translation when they are spawned.  3 is triple the translation, etc.
</p>

<h3>One Shot</h3>

<p><b>One Shot</b> emitters will create all particles within the <b>Emission</b> property all at once, and cease to emit particles over time.  Here are some examples of different particle system uses with <b>One Shot</b> enabled or disabled:
</p>

<p>Enabled
</p>
<ul><li>Explosion
</li><li>Water splash
</li><li>Magic spell
</li></ul>

<p>Disabled
</p>
<ul><li>Gun barrel smoke
</li><li>Wind effect
</li><li>Waterfall
</li></ul>



<h3>Min Emitter Range</h3>

<p>The <b>Min Emitter Range</b> determines the depth within the ellipsoid that particles can be spawned.  Setting the range to 0 will allow particles to spawn anywhere from the center core of the ellipsoid to the outer-most range.  Setting the range to 1 will restrict spawn locations to the outer-most range of the ellipsoid.
</p>

<p><img class='figure' src='images/class-EllipsoidParticleEmitter-2.jpg' />
</p>

<p><i><b>Min Emitter Range</b> of 0</i>
</p>

<p><img class='figure' src='images/class-EllipsoidParticleEmitter-3.jpg' />
</p>

<p><i><b>Min Emitter Range</b> of 1</i>
</p>

<h2>Hints</h2>
<p><ul><li>
Be careful of using many large particles. This can seriously hinder performance on low-level machines. Always try to use the minimum number of particles to attain an effect.
</li><li>The <b>Emit</b> property works in conjunction with the <b>AutoDestruct</b> property of the ParticleAnimator.  Through scripting, you can cease the emitter from emitting, and then <b>AutoDestruct</b> will automatically destroy the Particle System and the GameObject it is attached to.
</li></ul>
</p>


<p>The Mesh Particle Emitter emits particles around a mesh. Particles are spawned from the surface of the mesh, which can be necessary when you want to make your particles interact in a complex way with objects.
</p>

<p><img class='figure' src='images/class-MeshParticleEmitter-0.jpg' />
</p>

<p><i>The Mesh Particle Emitter</i>
</p>

<p>Here is how to create a <a href="../Manual/HOWTO-MeshParticleEmitter.html">Mesh Particle Emitter</a>.
</p>

<h2> Properties</h2>
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
 Emit</nobr></b></td><td> If enabled, the emitter will emit particles.
</td></tr><tr><td><b><nobr>Min Size</nobr></b></td><td> The minimum size each particle can be at the time when it is spawned.
</td></tr><tr><td><b><nobr>Max Size</nobr></b></td><td> The maximum size each particle can be at the time when it is spawned.
</td></tr><tr><td><b><nobr>Min Energy</nobr></b></td><td> The minimum lifetime of each particle, measured in seconds.
</td></tr><tr><td><b><nobr>Max Energy</nobr></b></td><td> The maximum lifetime of each particle, measured in seconds.
</td></tr><tr><td><b><nobr>Min Emission</nobr></b></td><td> The minimum number of particles that will be spawned every second.
</td></tr><tr><td><b><nobr>Max Emission</nobr></b></td><td> The maximum number of particles that will be spawned every second.
</td></tr><tr><td><b><nobr>World Velocity</nobr></b></td><td> The starting speed of particles in world space, along X, Y, and Z.
</td></tr><tr><td><b><nobr>Local Velocity</nobr></b></td><td> The starting speed of particles along X, Y, and Z, measured in the object's orientation.
</td></tr><tr><td><b><nobr>Rnd Velocity</nobr></b></td><td> A random speed along X, Y, and Z that is added to the velocity.
</td></tr><tr><td><b><nobr>Emitter Velocity Scale</nobr></b></td><td> The amount of the emitter's speed that the particles inherit.
</td></tr><tr><td><b><nobr>Simulate In World Space</nobr></b></td><td> If enabled, the particles don't move when the emitter moves. If false, when you move the emitter, the particles follow it around.
</td></tr><tr><td><b><nobr>One Shot</nobr></b></td><td> If enabled, the particle numbers specified by min &amp; max emission is spawned all at once. If disabled, the particles are generated in a long stream.
</td></tr><tr><td><b><nobr>Interpolate Triangles</nobr></b></td><td> If enabled, particles are spawned all over the mesh's surface. If disabled, particles are only spawned from the mesh's vertrices.
</td></tr><tr><td><b><nobr>Systematic</nobr></b></td><td> If enabled, particles are spawned in the order of the vertices defined in the mesh. Although you seldom have direct control over vertex order in meshes, most 3D modelling applications have a very systematic setup when using primitives. It is important that the mesh contains no faces in order for this to work.
</td></tr><tr><td><b><nobr>Min Normal Velocity</nobr></b></td><td> Minimum amount that particles are thrown away from the mesh.
</td></tr><tr><td><b><nobr>Max Normal Velocity</nobr></b></td><td> Maximum amount that particles are thrown away from the mesh.
<p></td></tr></tr></table>
</p>

<h2> Details</h2>
<p>Mesh Particle Emitters (MPEs) are used when you want more precise control over the spawn position &amp; directions than the simpler Ellipsoid Particle Emitter gives you.  They can be used for making advanced effects like flaming swords.
</p>

<p><img class='figure' src='images/class-MeshParticleEmitter-1.jpg' />
</p>

<p><i>A flaming sword created with a Mesh Particle Emitter</i>
</p>

<p>MPEs work emitting particles at the vertices of the attached mesh. Therefore, the areas of your mesh that are more dense with polygons will be more dense with particle emission.
</p>

<p>Particle Emitters work in conjunction with <a href="../Components/class-ParticleAnimator.html">Particle Animators</a> and <a href="../Components/class-ParticleRenderer.html">Particle Renderers</a> to create, manipulate, and display Particle Systems.  All three components must be present on an object before the particles will behave correctly.  When particles are being emitted, all different velocities are added together to create the final velocity.
</p>


<h3>Spawning Properties</h3>

<p>Spawning properties like <b>Size</b>, <b>Energy</b>, <b>Emission</b>, and <b>Velocity</b> will give your particle system distinct personality when trying to achieve different effects.  Having a small <b>Size</b> could simulate fireflies or stars in the sky.  A large <b>Size</b> could simulate dust clouds in a musky old building.
</p>

<p><b>Energy</b> and <b>Emission</b> will control how long your particles remain onscreen and how many particles can appear at any one time.  For example, a rocket might have high <b>Emission</b> to simulate density of smoke, and high <b>Energy</b> to simulate the slow dispersion of smoke into the air.
</p>

<p><b>Velocity</b> will control how your particles move.  You might want to change your <b>Velocity</b> in scripting to achieve interesting effects, or if you want to simulate a constant effect like wind, set your X and Z <b>Velocity</b> to make your particles blow away.
</p>

<h3>Simulate in World Space</h3>

<p>If this is disabled, the position of each individual particle will always translate relative to the <b>Position</b> of the emitter.  When the emitter moves, the particles will move along with it.  If you have <b>Simulate in World Space</b> enabled, particles will not be affected by the translation of the emitter.  For example, if you have a fireball that is spurting flames that rise, the flames will be spawned and float up in space as the fireball gets further away.  If <b>Simulate in World Space</b> is disabled, those same flames will move across the screen along with the fireball.
</p>

<h3>Emitter Velocity Scale</h3>

<p>This property will only apply if <b>Simulate in World Space</b> is enabled.
</p>

<p>If this property is set to 1, the particles will inherit the exact translation of the emitter at the time they are spawned.  If it is set to 2, the particles will inherit double the emitter's translation when they are spawned.  3 is triple the translation, etc.
</p>

<h3>One Shot</h3>

<p><b>One Shot</b> emitters will create all particles within the <b>Emission</b> property all at once, and cease to emit particles over time.  Here are some examples of different particle system uses with <b>One Shot</b> enabled or disabled:
</p>

<p>Enabled
</p>
<ul><li>Explosion
</li><li>Water splash
</li><li>Magic spell
</li></ul>

<p>Disabled
</p>
<ul><li>Gun barrel smoke
</li><li>Wind effect
</li><li>Waterfall
</li></ul>


<h2>Interpolate Triangles</h2>

<p>Enabling your emitter to interpolate triangles will allow particles to be spawned outside of the mesh's vertices.  This option is off by default, so particles will only be spawned at vertex locations.
</p>

<p><img class='figure' src='images/class-MeshParticleEmitter-2.jpg' />
</p>

<p><i>A flaming sword with <b>Interpolate Triangles</b> off (by default)</i>
</p>

<p>Enabling this option will spawn particles on and in-between vertices, essentially all over the mesh's surface (seen below).
</p>

<p><img class='figure' src='images/class-MeshParticleEmitter-3.jpg' />
</p>

<p><i>A flaming sword with <b>Interpolate Triangles</b> on</i>
</p>

<p>It bears repeating that even with <b>Interpolate Triangles</b> enabled, particles will still be denser in areas of your mesh that are more dense with polygons.
</p>

<h2>Systematic</h2>

<p>Enabling <b>Systematic</b> will cause your particles to be spawned in your mesh's vertex order.  The vertex order is set by your 3D modeling application.
</p>

<p><img class='figure' src='images/class-MeshParticleEmitter-4.jpg' />
</p>

<p><i>An MPE attached to a sphere with Systematic enabled</i>
</p>

<h2>Normal Velocity</h2>

<p><b>Normal Velocity</b> controls the speed at which particles are emitted along the normal from where they are spawned.
</p>

<p>For example, create a Mesh Particle system, use a cube mesh as the emitter, enable <b>Interpolate Triangles</b>, and set <b>Normal Velocity Min</b> and <b>Max</b> to 1. You will now see the particles emit from the faces of the cube in a straight line.
</p>

<h2>See Also</h2>
<ul><li> <a href="../Manual/HOWTO-MeshParticleEmitter.html">How to make a Mesh Particle Emitter</a>
</li></ul>

<h2> Hints</h2>
<p><ul><li>
Be careful of using many large particles. This can seriously hinder performance on low-level machines. Always try to use the minimum number of particles to attain an effect.
</li><li>The <b>Emit</b> property works in conjunction with the <b>AutoDestruct</b> property of the ParticleAnimator.  Through scripting, you can cease the emitter from emitting, and then <b>AutoDestruct</b> will automatically destroy the Particle System and the GameObject it is attached to.
MPEs can also be used to make glow from a lot of lamps placed in a scene. Simply make a mesh with one vertex in the center of each lamp, and build an MPE from that with a halo material. Great for evil sci-fi worlds.
</li></ul>
</p>


<p>Particle Animators move your particles over time, you use them to apply wind, drag &amp; color cycling to your particle systems.
</p>

<p><img class='figure' src='images/class-ParticleAnimator-0.jpg' />
</p>

<p><i>The Particle Animator</i>
</p>

<h2> Properties</h2>
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Does Animate Color</nobr></b></td><td> If enabled, particles cycle their color over their lifetime.
</td></tr><tr><td><b><nobr>Color Animation</nobr></b></td><td> The 5 colors particles go through. All particles cycle over this - if some have a shorter life span than others, they will animate faster.
</td></tr><tr><td><b><nobr>World Rotation Axis</nobr></b></td><td> An optional world-space axis the particles rotate around. Use this to make advanced spell effects or give caustic bubbles some life.
</td></tr><tr><td><b><nobr>Local Rotation Axis</nobr></b></td><td> An optional local-space axis the particles rotate around. Use this to make advanced spell effects or give caustic bubbles some life.
</td></tr><tr><td><b><nobr>Size Grow</nobr></b></td><td> Use this to make particles grow in size over their lifetime. As randomized forces will spread your particles out, it is often nice to make them grow in size so they don't fall apart.
Use this to make smoke rise upwards, to simulate wind, etc.
</td></tr><tr><td><b><nobr>Rnd Force</nobr></b></td><td> A random force added to particles every frame. Use this to make smoke become more alive.
</td></tr><tr><td><b><nobr>Force</nobr></b></td><td> The force being applied every frame to the particles, measure relative to the world.
</td></tr><tr><td><b><nobr>Damping</nobr></b></td><td> How much particles are slowed every frame. A value of 1 gives no damping, while less makes them slow down.
</td></tr><tr><td><b><nobr>Autodestruct</nobr></b></td><td> If enabled, the GameObject attached to the Particle Animator will be destroyed when all particles disappear.
<p></td></tr></tr></table>
</p>

<h2> Details</h2>

<p>Particle Animators allow your particle systems to be dynamic.  They allow you to change the color of your particles, apply forces and rotation, and choose to destroy them when they are finished emitting.  For more information about Particle Systems, reference <a href="../Components/class-MeshParticleEmitter.html">Mesh Particle Emitters</a>, <a href="../Components/class-EllipsoidParticleEmitter.html">Ellipsoid Particle Emitters</a>, and <a href="../Components/class-ParticleRenderer.html">Particle Renderers</a>.
</p>

<h3>Animating Color</h3>

<p>If you would like your particles to change colors or fade in/out, enable them to <b>Animate Color</b> and specify the colors for the cycle.  Any particle system that animates color will cycle through the 5 colors you choose.  The speed at which they cycle will be determined by the Emitter's <b>Energy</b> value.
</p>

<p>If you want your particles to fade in rather than instantly appear, set your first or last color to have a low Alpha value.
</p>

<p><img class='figure' src='images/class-ParticleAnimator-1.jpg' />
</p>

<p><i>An <b>Animating Color</b> Particle System</i>
</p>

<h3>Rotation Axes</h3>

<p>Setting values in either the Local or World <b>Rotation Axes</b> will cause all spawned particles to rotate around the indicated axis (with the <b>Transform's</b> position as the center).  The greater the value is entered on one of these axes, the faster the rotation will be.
</p>

<p>Setting values in the Local Axes will cause the rotating particles to adjust their rotation as the <b>Transform's</b> rotation changes, to match its local axes.
</p>

<p>Setting values in the World Axes will cause the particles' rotation to be consistent, regardless of the <b>Transform's</b> rotation.
</p>

<h3>Forces &amp; Damping</h3>

<p>You use force to make particles accelerate in the direction specified by the force.
</p>

<p>Damping (Drag) can be used to decelerate or accelerate without changing their direction.<br />
A value of 1 means no damping is applied, the particles will not slow down or accelerate.<br />
A value of 0 means particles will stop immediately.<br />
A value of 2 means particles will double their speed every second.
</p>

<h3>Destroying Objects attached to Particles</h3>

<p>You can destroy the Particle System and any attached Game Object by enabling the <b>AutoDestruct</b> property.  For example, if you have an oil drum, you can attach a Particle System that has <b>Emit</b> disabled and <b>AutoDestruct</b> enabled.  On collision, you enable the Particle Emitter.  The explosion will occur and after it is over, the Particle System and the oil drum will be destroyed and removed from the scene.
</p>

<h2> Hints</h2>
<p><ul><li>
Use the color animation to make your particles fade in &amp; out over their lifetime - otherwise, you will get nasty-looking pops.
</li><li>Use the rotation axes to make whirlpool-like swirly motions.
</li></ul>
</p>



<p>The Particle Collider is used to collide particles against other objects in the scene.
</p>

<p><img class='figure' src='images/class-WorldParticleCollider-0.jpg' />
</p>

<p><i>A shot of a very simple particle system with particle collider colliding with a cube</i>
</p>

<h2>Properties</h2>
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Bounce Factor</nobr></b></td><td> Particles can be accelerated or slowed down when they collide against other objects. This factor is similar to the Particle Animator's damping.
</td></tr><tr><td><b><nobr>Collision Energy Loss</nobr></b></td><td>Amount of energy (in seconds) a particle should lose when colliding. If the energy goes below 0, the particle is killed
</td></tr><tr><td><b><nobr>Min Kill Velocity</nobr></b></td><td> If a particle's velocity drops below Min Kill Velocity because of a Collision, it will be eliminated.
</td></tr><tr><td><b><nobr>Collides with</nobr></b></td><td> Which layers the particles collides against.
</td></tr><tr><td><b><nobr>Send Collision Message</nobr></b></td><td> When colliding every particle sends out a message that you can catch through scripting.
<p></td></tr></tr></table>
</p>
<h2>Details</h2>

<p>To create a particle system with particle collider:
</p>
<ol><li> Create a particle system using <b>GameObject -&gt; Create Other -&gt; Particle System</b>
</li><li> Add the particle collider using <b>Component -&gt; Particles -&gt; World Particle Collider</b>
</li></ol>


<h3>Messaging</h3>
<p>If Send Collision Message is enabled, any particles that are in a collision will send the message OnParticleCollision to  both the particle's GameObject and the GameObject the particle collided with.
</p>

<h2>Hints</h2>
<p><ul><li>
Send Collision message can be used to simulate bullets and apply damage on impact.
</li><li>Particle Collision Detection is slow when used with a lot of particles. Use Particle Collision Detection wisely.
</li><li>Message sending introduces a large overhead and shouldn't be used for normal particle systems.
</li></ul>
</p>


<p>The Trail renderer is used to make trails behind objects in the scene as they move about.
</p>

<p><img class='figure' src='images/class-TrailRenderer-0.jpg' />
</p>

<p><i>The Trail Renderer</i>
</p>

<h2> Properties</h2>
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Materials</nobr></b></td><td> An array of materials used for rendering the trail. Particle shaders work the best for trails.
</td></tr><tr><td><b><nobr>    Size</nobr></b></td><td> The total number of <b>Elements</b> in the material array
</td></tr><tr><td><b><nobr>    Element 0</nobr></b></td><td> Reference to the Material used to render the trail.  The total number of Elements is determined by the <b>Size</b> property.
</td></tr><tr><td><b><nobr>Time</nobr></b></td><td> Length of the trail, measured in seconds.
</td></tr><tr><td><b><nobr>Start Width</nobr></b></td><td> Width of the trail at the object's position.
</td></tr><tr><td><b><nobr>End Width</nobr></b></td><td> Width of the trail at the end.
</td></tr><tr><td><b><nobr>Colors</nobr></b></td><td> Array of colors to use over the length of the trail.  You can also set alpha transparency with the colors.
</td></tr><tr><td><b><nobr>    Color0</nobr></b></td><td> The trail's initial color.
</td></tr><tr><td><b><nobr>    Color1</nobr></b></td><td> The 2nd color of the trail
</td></tr><tr><td><b><nobr>    Color2</nobr></b></td><td> The 3rd color of the trail
</td></tr><tr><td><b><nobr>    Color3</nobr></b></td><td> The 4th color of the trail
</td></tr><tr><td><b><nobr>    Color4</nobr></b></td><td> The final color of the trail
</td></tr><tr><td><b><nobr>Min Vertex Distance</nobr></b></td><td> The minimum distance between anchor points of the trail.
</td></tr><tr><td><b><nobr>AutoDestruct</nobr></b></td><td> Enable this to make the object be destroyed when the object has been idle for <b>Time</b> in seconds
<p></td></tr></tr></table>
</p>

<h2> Details</h2>
<p>The TrailRenderer is great for a trail behind a missile, or contrails from the tip of a plane's wings. It is good to add a general feeling of speed.
</p>

<p><img class='figure' src='images/class-TrailRenderer-1.jpg' />
</p>

<p><i>Practical uses of the Trail Renderer in Neil Carter's &quot;Phoenix Final&quot;</i>
</p>

<p>When using a TrailRenderer, no other filters in the Pipeline are used.  It is best to create an empty GameObject, and attach a Trail Renderer as the only filter.  You can then parent the Trail Renderer to whatever object you would like it to follow.
</p>

<h3>Materials</h3>

<p>Trail Renderers should use a material that has a Particle shader.  The texture used for the material should be of square dimensions (e.g. 256x256 or 512x512).
</p>

<h3>Trail Width</h3>

<p>By setting the Trail's <b>Start</b> and <b>End Width</b>, along with the <b>Time</b> property, you can tune the way it is displayed and behaves.  For example, you could create the wake behind a boat by setting the <b>Start Width</b> to 1, and the <b>End Width</b> to 2.  These values would probably need to be fine-tuned for your game.
</p>

<h3>Trail Colors</h3>

<p>You can cycle your trail through 5 different color/opacity combinations.  Using colors could make a bright green plasma trail gradually dim down to a dull grey dissipation, or cycle through the other colors of the rainbow.  If you don't want to change the color, it can be very effective to change only the opacity of each color to make your trail fade in and out at the head and/or tail.
</p>

<h3>Min Vertex Distance</h3>

<p>The <b>Min Vertex Distance</b> value determines how far the object that contains the trail must travel before a segment of the trail is solidified.  Low values like 0.1 will create trail segments more often, creating smoother trails.  Higher values like 1.5 will create segments that are more jagged in appearance.  There is a slight performance trade off when using lower values/smoother trails, so try to use the maximum value to achieve the effect you are trying to create.
</p>

<h2> Hints</h2>
<p><ul><li>
Use particle materials with the Trail Renderer.
</li><li>Trail Renderers must be laid out over a sequence of frames, they can't appear instantaneously.
</li><li>Trail Renderers rotate to display the face toward the camera, similar to other particle systems
</li></ul>
</p>


<p>The Particle Renderer renders the particle system on screen.
</p>

<p><img class='figure' src='images/class-ParticleRenderer-0.jpg' />
<i>The Particle Renderer</i>
</p>

<h2>Properties</h2>
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Materials</nobr></b></td><td> Reference to a list of Materials that will be displayed in the position of each individual particle.
</td></tr><tr><td><b><nobr>Camera Velocity Scale</nobr></b></td><td> The amount of stretching that is applied to the particles based on Camera movement.
</td></tr><tr><td><b><nobr>Stretch Particles</nobr></b></td><td> Determines how the particles are rendered.
<dl><dt>Billboard</dt><dd> The particles are rendered as if facing the camera.</dd><dt>Stretched</dt><dd> The particles are facing the direction they are moving. </dd><dt>SortedBillboard</dt><dd> The particles are sorted by depth. Use this when using a blending material.</dd></dl>
</td></tr><tr><td><b><nobr>Length Scale</nobr></b></td><td> If <b>Stretch Particles</b> is set to Stretched, this value determines how long the particles are in their direction of motion.
</td></tr><tr><td><b><nobr>Velocity Scale</nobr></b></td><td> If <b>Stretch Particles</b> is set to Stretched, this value determines the rate at which particles will be stretched, based on their movement speed.
</td></tr><tr><td><b><nobr>UV Animation</nobr></b></td><td> If either of these are set, the UV coordinates of the particles will be generated for use with a tile animated texture. See the section on Animated Textures below.
</td></tr><tr><td><b><nobr>    X Tile</nobr></b></td><td> Number of frames located across the X axis
</td></tr><tr><td><b><nobr>    Y Tile</nobr></b></td><td> Number of frames located across the Y axis
</td></tr><tr><td><b><nobr>    Cycles</nobr></b></td><td> How many times to loop the animation sequence.
<p></td></tr></tr></table>
</p>

<h2>Details</h2>
<p>Particle Renderers are required for any Particle Systems to be displayed on the screen.
</p>

<p><img class='figure' src='images/class-ParticleRenderer-1.jpg' />
</p>

<p><i>A Particle Renderer is what makes explosion appear on the screen</i>
</p>

<h3> Choosing a material</h3>
<p>When setting up a particle renderer it is very important to use an appropriate material and shader. Most of the time you want to use a material with one of the <b>builtin Particle shaders</b>. There are some premade materials in the Standard Assets/Particles/Sources folder.
</p>

<p>Creating a new material is easy:
</p>
<ol><li> <b>Assets -&gt; Create Other -&gt; Material</b>
</li><li> The {class-Material|material} has a shader popup, choose one of the shaders in the Particles group. Eg. Particles/Multiply
</li><li> Now assign a texture. The different shaders use the alpha channel of the textures slightly differently, but most of the time a value of black will make it invisible and white in the alpha channel will display it on screen.
</li></ol>

<h3>Distorting particles</h3>

<p>By default particles are rendered billboarded. That is simple square sprites. This is good for smoke and explosions and most other particle effects.
</p>

<p>Particles can be made to either stretch with the velocity. This is useful for sparks, lightning or laser beam.
Length Scale and Velocity Scale affects how long the stretched particle will be.
</p>

<p>Sorted Billboard can be used to make all particles sort by depth. Sometimes this is necessary, mostly when using Alpha Blended particle shaders. This can be expensive and should only be used if it really makes a quality difference when rendering.
</p>

<h3>Animated textures</h3>
<p>Particle systems can be rendered with an animated tile texture. To use this feature, make the texture out of a grid of images. As the particles go thorough their life cycle, they will cycle through the images. This is good for adding more life to your particles, or making small rotating debris pieces.
</p>

<h2>Hints</h2>
<p><ul><li>
Use particle materials with the Particle Renderer.
</li></ul>
</p>



<p>The line renderer will draw free-floating lines in 3D space. Each renderer can draw many lines.
</p>

<p>The line renderer does not render one pixel thin lines; it renders 3D lines that have width and can be textured. It uses the same algorithm for line rendering as <a href="../Components/class-TrailRenderer.html">Trail Renderer</a>.
</p>

<p><img class='figure' src='images/class-LineRenderer-0.jpg' />
</p>

<p><i>The Line Renderer</i>
</p>

<h2> Properties</h2>
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Materials</nobr></b></td><td> The first material from this list is used to render the lines.
</td></tr><tr><td><b><nobr>Lines</nobr></b></td><td> An array of line information. For each element in this array, Unity draws one line. Each element has a number of subsettings.
</td></tr><tr><td><b><nobr>Positions</nobr></b></td><td> Array of 3D points to connect.
</td></tr><tr><td><b><nobr>Params</nobr></b></td><td> List of parameters for each line</td></tr><tr><td><b><nobr>StartWidth</nobr></b></td><td>Width at the first line position.
</td></tr><tr><td><b><nobr>EndWidth</nobr></b></td><td>Width at the last line position.
</td></tr><tr><td><b><nobr>Start Color</nobr></b></td><td> Color at the first line position.
</td></tr><tr><td><b><nobr>End Color</nobr></b></td><td> Color at the last line position.
</td></tr><tr><td><b><nobr>World Space</nobr></b></td><td> If enabled, the object's position is ignored, and the lines are rendered around world origin.
<p></td></tr></tr></table>
</p>

<h2> Details</h2>

<p>To create a line renderer:
</p>
<ol><li> Choose <b>GameObject -&gt; Create Empty</b>
</li><li> Choose <b>Component -&gt; Miscellaneous -&gt; Line Renderer</b>
</li><li> Drag a texture or material on the Line Renderer. It looks best if you use particle shader in the material.
</li></ol>

<p>The lines may seem to rotate as you move the camera. The line renderer completely ignores any other filters in the pipeline.
</p>

<h2>Hints</h2>
<ul><li> Line Renderers are good to use for effects when you need to lay out all the vertices in one frame.
</li></ul>




<p>Unity has the next-generation Ageia PhysX physics engine built-in. This allows for unique emergent behaviour and is generally very cool.
</p>

<h2>Basics</h2>
<p>To put an object under physics control, simply add a Rigidbody to it. When you do this, the object will be affected by gravity, and can collide with other objects in the world.
</p>

<h3> Rigidbodies</h3>
<p>You use <a href="../Components/class-Rigidbody.html">rigidbodies</a> for things that the player can push around. Eg. crates or loose objects. You can also add <a href="../Components/class-HingeJoint.html">joints</a> to rigidbodies to make the behaviour more complex. For example to make a physical door or a crane with a swinging chain.
</p>

<p>You also use rigidbodies to make vehicles, for example you can make cars using a rigidbody, 4 wheel colliders and a script applying wheel forces based on the user's input.
</p>

<p>You can make airplanes by applying forces to the rigidbody from a script. Or you can create special vehicles or robots by adding various joints and applying forces from scripts.
</p>

<p>Rigidbodies are usually used in combination with <a href="../Components/class-BoxCollider.html">primitive colliders</a>.
</p>

<h3> Kinematic Rigidbodies</h3>
<p>Kinematic rigidbodies are not affected by forces, gravity or collisions. They are driven explicitly by setting the position and rotation of the transform or animating them. They are used to interact with other non-kinematic rigidbodies.
</p>

<p>They are used for three purposes:
</p>
<ol><li>Sometimes you want an object to be under physics control but in another situation to be controlled explicitly from a script or animation. For example you could make an animated character whose bones have rigidbodies attached that are connected with joints for use as a Ragdoll. Most of the time the Ragdoll is under animation control, thus you make the rigidbody kinematic. But when he gets hit you want him to turn into a ragdoll and be affected by physics. Thus you disable the isKinematic property.
</li><li> Kinematic rigidbodies play better with other rigidbodies. For example if you have an animated platform and you want to place some rigidbody boxes on top, you should make the platform a kinematic rigidbody instead of just a collider without rigidbody.
</li><li> You might want to have a rigidbody that is animated and have a real rigidbody follow it using one of the different joints.
</li></ol>

<h3> Static Colliders</h3>
<p>Static colliders are used for level geometry which does not move around much. You add a mesh collider to your already existing graphical meshes. (Even better use the <b>Import Settings</b> Meshes Have Colliders check box)
You can of course move around static colliders but if you move them around a lot you might want to add a kinematic rigidbody.
There are two reasons why you want to make a static collider into a kinematic rigidbody instead:
</p>
<ol><li> Kinematic rigidbodies <a href="../ScriptingConcepts/RigidbodySleeping.html">wake up</a> other rigidbodies when they collide with them.
</li><li> Kinematic rigidbodies apply friction to rigidbodies placed on top of them
</li></ol>

<h3> Character Controllers</h3>
<p>You use <a href="../Components/class-CharacterController.html">character controllers</a> if you want to make a humanoid character. This could be the main character in a third person platformer, FPS shooter or any enemy characters.
</p>

<p>These controllers don't follow the rules of physics since it will not feel right. (In Doom you run 90 miles per hour, come to halt in one frame and turn on a dime). Instead a character controller performs collision detection to make sure your characters can slide along wall, walk stairs.
</p>

<p>Character Controllers are not be affected by forces but they can push rigidbodies by applying forces to them from a script. Usually all humanoid characters are implemented using Character Controllers.
</p>

<p>Character controllers are inherently unphysical, thus if you want to apply real physics - Swing on ropes, get pushed by big rocks - to your character you have to use a rigidbody, this will let you use joints and forces on your character. But be aware that tuning a rigidbody to feel right for a character is hard due to the unphysical way in which game characters are expected to move.
</p>

<h2> Components</h2>
<p>Select a component below to see the details:
</p>

<h3>Physics Control</h3>
<ul><li> <a href="../Components/class-Rigidbody.html">Rigidbody</a> - Rigid bodies put objects under physics control. After adding a rigid body,
</li><li> <a href="../Components/class-ConstantForce.html">Constant Force</a> - A utility component that adds a constant force to a rigid body. Great for rockets and other quick functionality.
</li></ul>

<h3>Colliders</h3>
<ul><li> <a href="../Components/class-SphereCollider.html">Sphere Collider</a> - use for sphere-shaped objects.
</li><li> <a href="../Components/class-BoxCollider.html">Box Collider</a> - use for box-shaped objects.
</li><li> <a href="../Components/class-CapsuleCollider.html">Capsule Collider</a> - use for capsule-like (a cylinder with half-sphere ends) objects.
</li><li> <a href="../Components/class-MeshCollider.html">Mesh Collider</a> - takes the graphical <a href="../Components/class-Mesh.html">mesh</a> and uses it as a collision shape.
</li><li> <a href="../Components/class-PhysicMaterial.html">Physic Material</a> - contains settings allowing objects to interact properly with each other (friction etc.).
</li></ul>

<h3>Joints</h3>
<ul><li> <a href="../Components/class-HingeJoint.html">Hinge Joint</a> - Used to make door hinges.
</li><li> <a href="../Components/class-SpringJoint.html">Spring Joint</a> - A spring-like joint.
</li><li> <a href="../Components/class-FixedJoint.html">Fixed Joint</a> - use to &quot;lock&quot; objects together.
</li></ul>

<h3>Special functionality</h3>
<ul><li> <a href="../Components/class-CharacterController.html">Character Controller</a> and <a href="../Components/class-CharacterJoint.html">Character Joint</a> - Used to make character controllers.
</li><li> <a href="../Components/class-WheelCollider.html">Wheel Collider</a> - A special collider for grounded vehicles.
</li></ul>



<p>Rigidbodies are the gateway for applying physics to your objects. The Rigidbody can receive forces and torque to make your objects move in a realistic way.  Any GameObject must contain a Rigidbody to be influenced by gravity, act under added forces via scripting, or interact with other objects through the Ageia physX physics engine.
</p>

<p><img class='figure' src='images/class-Rigidbody-0.jpg' />
</p>

<p><i>A GameObject with a Rigidbody component attached</i>
</p>

<h2>Properties</h2>
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Mass</nobr></b></td><td> The weight of the object in kilogram. For stable simulation it is recommended to make masses not more or less than 100 times that of other rigid bodies.
</td></tr><tr><td><b><nobr>Drag</nobr></b></td><td> How much air resistance affects the object when moving from forces. 0 means no air resistance, and infinity makes the object stop moving immediately.
</td></tr><tr><td><b><nobr>Angular Drag</nobr></b></td><td> How much air resistance affects the object when rotating from torque. 0 means no air resistance, and infinity makes the object stop rotating immediately.
</td></tr><tr><td><b><nobr>Use Gravity</nobr></b></td><td> If checked, the object is affected by gravity.
</td></tr><tr><td><b><nobr>Is Kinematic</nobr></b></td><td> If checked, the object will not be driven by the physics engine, but can only be manipulated by its Transform. This is useful for moving platforms or if you want to animate a Rigidbody that has a Hinge Joint attached.
<p></td></tr></tr></table>
</p>

<h2>Details</h2>
<p>Rigidbodies allow your GameObjects to act under control of the physics engine.  This opens the gateway to realistic collisions, varied types of joints, and other very cool behaviors.  Manipulating your objects by adding forces to a Rigidbody creates a very different feel and look than adjusting the Transform property directly.  Generally, you shouldn't manipulate the Rigidbody and the Transform of the same object &mdash; just one or the other.
</p>

<p>The biggest difference between manipulating the Transform or the Rigidbody is the use of forces.  Rigidbodies can receive forces and torque, but Transforms cannot.  Transforms can be translated and rotated, but this is not the same as using physics. You'll notice the distinct difference when adding you try it for yourself.  Adding forces/torque to the Rigidbody will actually change the object's position and rotation of the Transform component.  This is why you should only be using one or the other.  Changing the Transform while using physics could cause problems with collisions and other calculations.
</p>

<p>Rigidbodies must be explicitly added to your game object before they will be affected by the physics engine.  You can add a Rigidbody to your selected object from <i>Components-&gt;Dynamics-&gt;Rigidbody</i>. Now your object is physics-ready; it will fall under gravity and can receive forces via scripting, but you may want to add a Collider or a Joint to get it to behave exactly how you want.
</p>

<h3> Parenting</h3>
<p>When an object is under physics control, it moves semi-independently of the way its transform parents move. If you move any parents, they will pull the Rigidbody child along with them. However, the Rigidbodies will still fall down due to gravity and react to collision detection.
</p>

<h3> Scripting</h3>
<p>To control your Rigidbodies, you will primarily use scripts to add forces or torque. You do this by calling <a class="wiki"  href="../ScriptReference/Rigidbody.AddForce.html">AddForce</a> and <a class="wiki"  href="../ScriptReference/Rigidbody.html#AddTorque">AddTorque</a> on the object's Rigidbody.  Remember that you shouldn't be directly altering the object's Transform when you are using physics.
</p>

<h3>Animation</h3>
<p>For some situations, mainly creating ragdoll effects, it is neccessary to switch control of the object between animations and physics. For this purpose Rigidbodies can be marked <a class="wiki"  href="../ScriptReference/Rigidbody-isKinematic.html">Kinematic</a>. While the Rigidbody is marked Kinematic, it will not be affected by collisions, forces, or any other part of the physics engine. This means that you will have to control the object by manipulating the <a href="../Components/class-Transform.html">Transform</a> component directly.  Kinematic Rigidbodies will affect other objects, but they themselves will not be affected by physics. For example, Joints which are attached to Kinematic objects will constrain any other Rigidbodies attached to them and Kinematic Rigidbodies will affect other Rigidbodies through collisions.
</p>

<h3>Colliders</h3>
<p>Colliders are another kind of component that must be added alongside the Rigidbody in order to allow collisions to occur.  If two Rigidbodies bump into each other, the physics engine will not calculate a collision unless both objects also have a Collider attached.  Collider-less Rigidbodies will simply pass through each other during physics simulation.
</p>

<p><img class='figure' src='images/class-Rigidbody-1.jpg' />
</p>

<p><i>A Rigidbody with a Collider component attached</i>
</p>

<p>Add a collider with the Component -&gt; Dynamics menu.  View the Component page of any individual Collider for more specific information:
</p>
<ul><li><a href="../Components/class-BoxCollider.html">Box Collider</a> - primitive shape of a cube
</li><li><a href="../Components/class-SphereCollider.html">Sphere Collider</a> - primitive shape of a sphere
</li><li><a href="../Components/class-CapsuleCollider.html">Capsule Collider</a> - primitive shape of a capsule
</li><li><a href="../Components/class-MeshCollider.html">Mesh Collider</a> - creates a collider from the object's mesh, cannot collide with another Mesh Collider
</li><li><a href="../Components/class-WheelCollider.html">Wheel Collider</a> - specifically for creating cars or other moving vehicles
</li></ul>



<h3>Compound colliders</h3>

<p>Compound Colliders are combinations of primitive Colliders, all together acting as a single Collider.  They come in handy when you have a complex mesh to use in collisions, but cannot use a Mesh Collider.  To create a Compound Collider, create child objects of your colliding object, then add a primitive Collider to each child object.  This allows you to position, rotate, and scale each Collider easily and independently of each other.
</p>

<p><img alt="" src=""img/wiki_up/RigidBody" border="0"  />
</p>

<p><i>A GameObject with a Rigidbody and multiple colliders attached</i>
</p>

<p>In the above picture, the terrain has a Mesh Collider attached.  Mesh Colliders work the best for terrain or environments made from irregular shapes. The Rigidbody has 3 child Colliders attached: capsule, cube and sphere. When Play mode begins, the Rigidbody falls due to gravity, and the 3 child Colliders fall with it. The 3 Collision primitives collide with the Mesh Collider, and the Rigidbody eventually balances and comes to rest on the 3 Colliders.
</p>

<p>Keep in mind, Mesh Colliders can't collide with each other, so the typical solution is to use primitive Colliders for any objects that move, and Mesh Colliders for static background objects.
</p>




<h2>Use the right size</h2>
<p>The size value of the your object's mesh is much more important than the mass of the Rigidbody.  If you find that your Rigidbody is not behaving exactly how you expect; it moves slowly, 'floats', or doesn't collide correctly; consider adjusting the scale of your mesh and/or the Rigidbody's <a href="../Components/class-Transform.html">Transform</a>.  Unity's default unit scale is 1 unit = 1 meter, so the scale of your imported mesh is maintained, and applied to physics calculations.  For example, a crumbling skyscraper is going to fall apart very differently than a tower made of toy blocks, so objects of different sizes should be modeled to accurate scale.
</p>

<p>If you are modelling a human make sure he is around 2 meters big in Unity. To check if your object has the right size compare it to the default cube. You can create a cube using <i>GameObject-&gt;Create Other-&gt;Cube</i>. The cube will be exactly 1 meter large. So your human should be twice as tall.
</p>

<p>If you aren't able to adjust the mesh itself, you can change the global scale of each particular mesh by control-clicking on your imported mesh and selecting 'Import Settings' from the context menu.  Here, you can change the scale and re-import your mesh.
</p>

<p>If your game requires that your GameObject needs to be instantiated at different scales, it is perfectly okay to directly adjust the values of your Transform's scale.  The down-side is that the physics simulation must do more work at the time the object is instantiated, and could cause a performance drop in your game.  This isn't a terrible loss, but it is not as efficient as finalizing your scale with the other two options.
</p>


<h2>Hints</h2>
<p><ul><li>
The relative masses of two objects determines how they react when they collide.
</li><li>Making one object have higher mass than another does not make it fall faster in free fall. Use drag for that.
</li><li>A low drag value makes an object seem heavy. A high one makes it seem light. Typical values for drag are between .001 (solid block of metal) and 10 (feather)
</li><li>If you are directly manipulating the Transform component of your object but still want physics, attach a Rigidbody and make it Kinematic.
</li></ul>
</p>



<p>The Character Controller is mainly used for third-person or first-person player control that does not make use of rigidbody physics.
</p>

<p><img class='figure' src='images/class-CharacterController-0.jpg' />
</p>

<p><i>The Character Controller</i>
</p>

<h2>Properties</h2>
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Height</nobr></b></td><td> The character's capsule collider height.  Changing this will scale the collider along the Y axis in both positive and negative directions.
</td></tr><tr><td><b><nobr>Radius</nobr></b></td><td> Length of the capsule collider's radius.  This is essentially the width of the collider.
</td></tr><tr><td><b><nobr>Slope Limit</nobr></b></td><td> Limits the collider to only climb slopes that are equal to or less than the indicated value.
</td></tr><tr><td><b><nobr>Step Offset</nobr></b></td><td> The character will step up a stair only if it is closer to the ground than the indicated value.
</td></tr><tr><td><b><nobr>Min Move Distance</nobr></b></td><td> If the character tries to move below the indicated value, it will not move at all. This can be used to reduce jitter. In most situations this value should be left at 0.
</td></tr><tr><td><b><nobr>Skin width</nobr></b></td><td> Two colliders can penetrate each other as deep as their skin width. Larger skin widths reduce jitter. Low skin width can cause the character to get stuck. A good value is to make this value 10% of the radius.
</td></tr><tr><td><b><nobr>Center</nobr></b></td><td> This will move the capsule collider in world space, and won't affect how the character pivots.
<p></td></tr></tr></table>
</p>

<h2>Details</h2>

<p>The traditional Doom first person controls are not physically realistic. The character runs 90 miles per hour, comes to halt immediately and turns on a dime. Because it is so unrealistic, use of rigidbodies and physics to create this behavior is impractical and will feel wrong. The solution is the specialized Character Controller. It is simply a capsule shaped collider which can be told to move in some direction from a script. The controller will then carry out the movement but be constrained by collisions. It will slide along walls, walk up stairs (if they are lower than <b>Step Offset</b>) and walk on slopes within the <b>Slope Limit</b>.
</p>

<p>The Controller does not react to forces on its own and it does not automatically push rigidbodies away.
</p>

<p>If you want to push rigidbodies or objects with the Character Controller, you can apply forces to any objects that are collided with in the OnControllerColliderHit() function through scripting.
</p>

<p>On the other hand, if you want your player character to be affected by physics then you might be better off using a {class-Rigidbody|rigidbody} instead of the Character Controller.
</p>

<h3>Fine-tuning your character</h3>

<p>You can modify the <b>Height</b> and <b>Radius</b> to fit your character's mesh. It is recommended to always use around 2 meters for a human-like character. You can also modify the <b>Center</b> of the capsule in case your pivot point is not at the center of character.
</p>

<p><b>Step Offset</b> can affect this too, make sure that this value is between 0.1 and 0.4 for a 2 meter sized human.
</p>

<p><b>Slope Limit</b> should not be too smaller. Often using a value of 90 degrees works most robust. This will not make your character be able to climb up walls due to the capsule shape.
</p>

<h3>Don't get stuck</h3>

<p>The <b>Skin Width</b> is one of the most critical properties to get right when tuning your Character Controller.
If your character gets stuck it is most likely because your <b>Skin Width</b> is too small. The <b>Skin Width</b> will let objects slightly penetrate the controller but it removes jitter and prevents it from getting stuck.
It's good practice to keep your <b>Skin Width</b> at least greater than 0.01 and more than 10% of the <b>Radius</b>.
</p>

<p>It is recommended to keep <b>Min Move Distance</b> at zero.
</p>

<p>See the Character Controller script reference <a class="wiki"  href="../ScriptReference/CharacterController.html ">here</a>
</p>

<p>You can download an <b><a class="wiki"  href="http://www.unity3d.com/examples/index.html">example project</a></b> showing pre-setup animated and moving character controllers <a class="wiki"  href="http://www.unity3d.com/examples/index.html">here</a>.
</p>

<h2>Hints</h2>
<p><ul><li>
Try adjusting your <b>Skin Width</b> if you find your character getting stuck frequently.
</li><li>The Character Controller can affect objects using physics if you write your own scripts.
</li><li>The Character Controller can not be affected by objects through physics.
</li></ul>
</p>


<p>The Box Collider is a basic cube-shaped collision primitive.
</p>

<p><img class='figure' src='images/class-BoxCollider-0.jpg' />
</p>

<p><i>Box collider here is used to approximate car's hull</i>
</p>

<h2>Properties</h2>
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Material</nobr></b></td><td> Reference to the <a href="../Components/class-PhysicMaterial.html">PhysicMaterial</a> that determines how this Collider interacts with others.
</td></tr><tr><td><b><nobr>Is Trigger</nobr></b></td><td> If enabled, this Collider is used for triggering events, and is ignored by the physics engine.

</td></tr><tr><td><b><nobr>Size</nobr></b></td><td> The size of the collider in the X, Y, Z directions.
</td></tr><tr><td><b><nobr>Center</nobr></b></td><td> The position of the collider in the object's local space.
<p></td></tr></tr></table>
</p>

<h2>Details</h2>
<p>The Box Collider can be resized into different shapes of rectangular prisms.  It works great for doors, walls, platforms, etc. It is also effective as a human torso in a ragdoll or car hull in a vehicle. Of course, it works perfectly for just boxes and crates as well!
</p>

<p><img class='figure' src='images/class-BoxCollider-1.jpg' />
</p>

<p><i>A standard Box Collider</i>
</p>


<p>Colliders work with Rigidbodies to bring physics in Unity to life.  Whereas Rigidbodies allow objects to be controlled by physics, Colliders allow objects to collide with each other.  Colliders must be added to objects independently of Rigidbodies.  A Collider does not necessarily need a Rigidbody attached, but a Rigidbody <span style="text-decoration:underline;">must</span> be attached in order for the object to react to collisions.
</p>

<p>When a collision between two Colliders occurs and if at least one of them has a Rigidbody attached, <a class="wiki"  href="../ScriptReference/Collider.html#OnCollisionEnter">three</a> <a class="wiki"  href="../ScriptReference/Collider.html#OnCollisionExit">collision</a> <a class="wiki"  href="../ScriptReference/Collider.html#OnCollisionStay">messages</a> are sent out to the objects attached to them. These events can be handled in scripting, and allow you to create unique behaviors with or without making use of the built-in Ageia physX engine.
</p>

<h3>Triggers</h3>
<p>An alternative way of using Colliders is to mark them as a Trigger, just check the IsTrigger property checkbox in the Inspector.  Triggers are effectively ignored by the physics engine, and have a unique set of <a class="wiki"  href="../ScriptReference/Collider.html#OnTriggerEnter">three</a> <a class="wiki"  href="../ScriptReference/Collider.html#OnTriggerExit">trigger</a> <a class="wiki"  href="../ScriptReference/Collider.html#OnTriggerStay">messages</a> that are sent out when a collision with a Trigger occurs.  Triggers are useful for triggering other events in your game, like cutscenes, automatic door opening, displaying tutorial messages, etc.  Use your imagination!
</p>

<p>Be aware that in order for two Triggers to send out trigger events when they collide, one of them must be attached to a Rigidbody. For a Trigger to collide with a normal Collider, one of them must have a Rigidbody attached.  For a detailed chart of different types of collisions, see the collision action matrix in the Advanced section below.
</p>

<h3>Friction and bouncyness</h3>

<p>Friction, bouncyness and softness is defined in the <a href="../Components/class-PhysicMaterial.html">physic material</a>. The <a href="../Manual/HOWTO-InstallStandardAssets.html">Standard Assets</a> contain the most common physic materials. To use one of them click on the material popup and select eg. Ice. You can also <a href="../Components/class-PhysicMaterial.html">create</a> your own physic materials and tweak all friction values.
</p>



<h2>Compound Colliders</h2>

<p>Compound Colliders are combinations of primitive Colliders, all together acting as a single Collider.  They come in handy when you have a complex mesh to use in collisions, but cannot use a Mesh Collider.  To create a Compound Collider, create child objects of your colliding object, then add a primitive Collider to each child object.  This allows you to position, rotate, and scale each Collider easily and independently of each other.
</p>

<p><img alt="" src=""img/wiki_up/RigidBody" border="0"  />
</p>

<p><i>A GameObject with a Rigidbody and multiple colliders attached</i>
</p>

<p>In the above picture, the terrain has a Mesh Collider attached.  Mesh Colliders work the best for terrain or environments made from irregular shapes. The Rigidbody has 3 child Colliders attached: capsule, cube and sphere. When Play mode begins, the Rigidbody falls due to gravity, and the 3 child Colliders fall with it. The 3 Collision primitives collide with the Mesh Collider, and the Rigidbody eventually balances and comes to rest on the 3 Colliders.
</p>

<p>Keep in mind, Mesh Colliders can't collide with each other, so the typical solution is to use primitive Colliders for any objects that move, and Mesh Colliders for static background objects.
</p>




<h2>Hints</h2>
<p><ul><li>
To add multiple Colliders for an object, create child objects and attach a Collider to each one.  This allows each Collider to be manipulated independently.
</li><li>You can look at the gizmos in the Scene view to see how the Collider is being calculated on your object.
</li><li>Colliders do their best to match the scale of an object. If you have a non-uniform scale (a scale which is different in each direction), only the Mesh Collider can match completely.
</li></ul>
</p>


<h2>Advanced</h2>
<h3>Collider combinations</h3>
<p>There are numerous different combinations of collisions that can happen in Unity.  Each game is unique, and different combinations may work better for different types of games.  If you're using physics in your game, it will be very helpful to understand the different basic Collider types, their common uses, and how they interact with other types of objects.
</p>

<h4><span style="text-decoration:underline;">Static Collider</span></h4>
<p>These are Game Objects that <span style="text-decoration:underline;">do not</span> have a Rigidbody attached, but <span style="text-decoration:underline;">do</span> have a Collider attached.  These objects should remain still, or move very little.  These work great for your environment geometry.  They will not move if a Rigidbody collides with them.
</p>

<h4><span style="text-decoration:underline;">Rigidbody Collider</span></h4>
<p>These Game Objects contain both a Rigidbody and a Collider.  They are completely affected by the physics engine through scripted forces and collsions.  They might collide with a Game Object that only contains a Collider.  These will likely be your primary type of Object in games that use physics.
</p>

<h4><span style="text-decoration:underline;">Kinematic Rigidbody Collider</span></h4>
<p>This Game Object contains a Collider and a Rigidbody which is marked IsKinematic.  To move this Object, you modify its <a href="../Components/class-Transform.html">Transform</a> component, rather than applying forces. They're similar to Static Colliders but will work better when you want to move the Collider around frequently.  There are some other specialized scenarios for using this Object.
</p>

<p>This object can be used for circumstances in which you would normally want a Static Collider to send a trigger event.  Since a Trigger must have a Rigidbody attached, you should add a Rigidbody, then check IsKinematic.  This will prevent your Object from moving from physics influence, and allow you to receive trigger events when you want to.
</p>

<p>Kinematic Rigidbodies can easily be turned on and off.  This is great for creating ragdolls, when you normally want a character to follow an animation, then turn into a ragdoll when a collision occurs, prompted by an explosion or anything else you choose.  When this happens, simply turn all your Kinematic Rigidbodies into normal Rigidbodies through scripting.
</p>

<p>If you have Rigidbodies come to rest, so they are not moving for some time, they will "fall asleep".  That is, they will not be calculated during the physics update since they are not going anywhere.  If you move a Kinematic Rigidbody out from underneath normal Rigidbodies that are at rest on top of it, the sleeping Rigidbodies will "wake up" and be correctly calculated again in the physics update.  So if you have a lot of Static Colliders that you want to move around and have different object fall on them correctly, use Kinematic Rigidbody Colliders.
</p>

<h3>Collision action matrix</h3>
<p>Depending on the configurations of the two colliding Objects, a number of different actions can occur.  The chart below outlines what you can expect from two colliding Objects, based on the components that are attached to them.  Some of the combinations only cause one of the two Objects to be affected by the collision, so keep the standard rule in mind &mdash; physics will not be applied to objects that do not have Rigidbodies attached.
</p>


<p><table class="wikitable"><tr><td class="wikicell"  colspan="7"><div align="center"><b>Collision detection occurs and messages are sent upon collision</b></div></td></tr><tr><td class="wikicell" ></td><td class="wikicell" >Static Collider</td><td class="wikicell" >Rigidbody Collider</td><td class="wikicell" >Kinematic Rigidbody Collider</td><td class="wikicell" >Static Trigger Collider</td><td class="wikicell" >Rigidbody Trigger Collider</td><td class="wikicell" >Kinematic Rigidbody Trigger Collider</td></tr><tr><td class="wikicell" >Static Collider</td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td></tr><tr><td class="wikicell" >Rigidbody Collider</td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td></tr><tr><td class="wikicell" >Kinematic Rigidbody Collider</td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td></tr><tr><td class="wikicell" >Static Trigger Collider</td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td></tr><tr><td class="wikicell" >Rigidbody Trigger Collider</td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td></tr><tr><td class="wikicell" >Kinematic Rigidbody Trigger Collider</td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td></tr></table>
</p>


<p><table class="wikitable"><tr><td class="wikicell"  colspan="7"><div align="center"><b>Trigger messages are sent upon collision</b></div></td></tr><tr><td class="wikicell" ></td><td class="wikicell" >Static Collider</td><td class="wikicell" >Rigidbody Collider</td><td class="wikicell" >Kinematic Rigidbody Collider</td><td class="wikicell" >Static Trigger Collider</td><td class="wikicell" >Rigidbody Trigger Collider</td><td class="wikicell" >Kinematic Rigidbody Trigger Collider</td></tr><tr><td class="wikicell" >Static Collider</td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td></tr><tr><td class="wikicell" >Rigidbody Collider</td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td></tr><tr><td class="wikicell" >Kinematic Rigidbody Collider</td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td></tr><tr><td class="wikicell" >Static Trigger Collider</td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td></tr><tr><td class="wikicell" >Rigidbody Trigger Collider</td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td></tr><tr><td class="wikicell" >Kinematic Rigidbody Trigger Collider</td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td></tr></table>
</p>



<p>The Sphere Collider is a basic sphere-shaped collision primitive.
</p>

<p><img class='figure' src='images/class-SphereCollider-0.jpg' />
</p>

<p><i>(Image of a Sphere Collider in Inspector)</i>
</p>

<h2>Properties</h2>
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Material</nobr></b></td><td> Reference to the <a href="../Components/class-PhysicMaterial.html">PhysicMaterial</a> that determines how this Collider interacts with others.
</td></tr><tr><td><b><nobr>Is Trigger</nobr></b></td><td> If enabled, this Collider is used for triggering events, and is ignored by the physics engine.

</td></tr><tr><td><b><nobr>Radius</nobr></b></td><td> The size of the collider.
</td></tr><tr><td><b><nobr>Center</nobr></b></td><td> The position of the collider in the object's local space.
<p></td></tr></tr></table>
</p>

<h2>Details</h2>
<p>The Sphere Collider can be resized to uniform scale, but not along individual axes. It works great for falling boulders, ping pong balls, marbles, etc.
</p>

<p><img class='figure' src='images/class-SphereCollider-1.jpg' />
</p>

<p><i>A standard Sphere Collider</i>
</p>


<p>Colliders work with Rigidbodies to bring physics in Unity to life.  Whereas Rigidbodies allow objects to be controlled by physics, Colliders allow objects to collide with each other.  Colliders must be added to objects independently of Rigidbodies.  A Collider does not necessarily need a Rigidbody attached, but a Rigidbody <span style="text-decoration:underline;">must</span> be attached in order for the object to react to collisions.
</p>

<p>When a collision between two Colliders occurs and if at least one of them has a Rigidbody attached, <a class="wiki"  href="../ScriptReference/Collider.html#OnCollisionEnter">three</a> <a class="wiki"  href="../ScriptReference/Collider.html#OnCollisionExit">collision</a> <a class="wiki"  href="../ScriptReference/Collider.html#OnCollisionStay">messages</a> are sent out to the objects attached to them. These events can be handled in scripting, and allow you to create unique behaviors with or without making use of the built-in Ageia physX engine.
</p>

<h3>Triggers</h3>
<p>An alternative way of using Colliders is to mark them as a Trigger, just check the IsTrigger property checkbox in the Inspector.  Triggers are effectively ignored by the physics engine, and have a unique set of <a class="wiki"  href="../ScriptReference/Collider.html#OnTriggerEnter">three</a> <a class="wiki"  href="../ScriptReference/Collider.html#OnTriggerExit">trigger</a> <a class="wiki"  href="../ScriptReference/Collider.html#OnTriggerStay">messages</a> that are sent out when a collision with a Trigger occurs.  Triggers are useful for triggering other events in your game, like cutscenes, automatic door opening, displaying tutorial messages, etc.  Use your imagination!
</p>

<p>Be aware that in order for two Triggers to send out trigger events when they collide, one of them must be attached to a Rigidbody. For a Trigger to collide with a normal Collider, one of them must have a Rigidbody attached.  For a detailed chart of different types of collisions, see the collision action matrix in the Advanced section below.
</p>

<h3>Friction and bouncyness</h3>

<p>Friction, bouncyness and softness is defined in the <a href="../Components/class-PhysicMaterial.html">physic material</a>. The <a href="../Manual/HOWTO-InstallStandardAssets.html">Standard Assets</a> contain the most common physic materials. To use one of them click on the material popup and select eg. Ice. You can also <a href="../Components/class-PhysicMaterial.html">create</a> your own physic materials and tweak all friction values.
</p>


<h2>Compound Colliders</h2>

<p>Compound Colliders are combinations of primitive Colliders, all together acting as a single Collider.  They come in handy when you have a complex mesh to use in collisions, but cannot use a Mesh Collider.  To create a Compound Collider, create child objects of your colliding object, then add a primitive Collider to each child object.  This allows you to position, rotate, and scale each Collider easily and independently of each other.
</p>

<p><img alt="" src=""img/wiki_up/RigidBody" border="0"  />
</p>

<p><i>A GameObject with a Rigidbody and multiple colliders attached</i>
</p>

<p>In the above picture, the terrain has a Mesh Collider attached.  Mesh Colliders work the best for terrain or environments made from irregular shapes. The Rigidbody has 3 child Colliders attached: capsule, cube and sphere. When Play mode begins, the Rigidbody falls due to gravity, and the 3 child Colliders fall with it. The 3 Collision primitives collide with the Mesh Collider, and the Rigidbody eventually balances and comes to rest on the 3 Colliders.
</p>

<p>Keep in mind, Mesh Colliders can't collide with each other, so the typical solution is to use primitive Colliders for any objects that move, and Mesh Colliders for static background objects.
</p>


<h2>Hints</h2>
<p><ul><li>
To add multiple Colliders for an object, create child objects and attach a Collider to each one.  This allows each Collider to be manipulated independently.
</li><li>You can look at the gizmos in the Scene view to see how the Collider is being calculated on your object.
</li><li>Colliders do their best to match the scale of an object. If you have a non-uniform scale (a scale which is different in each direction), only the Mesh Collider can match completely.
</li><li>If you make an explosion, it can be very effective to add a rigidbody with lots of drag and a sphere collider to it in order to push it out a bit from the wall it hits.
</li></ul>
</p>


<h2>Advanced</h2>
<h3>Collider combinations</h3>
<p>There are numerous different combinations of collisions that can happen in Unity.  Each game is unique, and different combinations may work better for different types of games.  If you're using physics in your game, it will be very helpful to understand the different basic Collider types, their common uses, and how they interact with other types of objects.
</p>

<h4><span style="text-decoration:underline;">Static Collider</span></h4>
<p>These are Game Objects that <span style="text-decoration:underline;">do not</span> have a Rigidbody attached, but <span style="text-decoration:underline;">do</span> have a Collider attached.  These objects should remain still, or move very little.  These work great for your environment geometry.  They will not move if a Rigidbody collides with them.
</p>

<h4><span style="text-decoration:underline;">Rigidbody Collider</span></h4>
<p>These Game Objects contain both a Rigidbody and a Collider.  They are completely affected by the physics engine through scripted forces and collsions.  They might collide with a Game Object that only contains a Collider.  These will likely be your primary type of Object in games that use physics.
</p>

<h4><span style="text-decoration:underline;">Kinematic Rigidbody Collider</span></h4>
<p>This Game Object contains a Collider and a Rigidbody which is marked IsKinematic.  To move this Object, you modify its <a href="../Components/class-Transform.html">Transform</a> component, rather than applying forces. They're similar to Static Colliders but will work better when you want to move the Collider around frequently.  There are some other specialized scenarios for using this Object.
</p>

<p>This object can be used for circumstances in which you would normally want a Static Collider to send a trigger event.  Since a Trigger must have a Rigidbody attached, you should add a Rigidbody, then check IsKinematic.  This will prevent your Object from moving from physics influence, and allow you to receive trigger events when you want to.
</p>

<p>Kinematic Rigidbodies can easily be turned on and off.  This is great for creating ragdolls, when you normally want a character to follow an animation, then turn into a ragdoll when a collision occurs, prompted by an explosion or anything else you choose.  When this happens, simply turn all your Kinematic Rigidbodies into normal Rigidbodies through scripting.
</p>

<p>If you have Rigidbodies come to rest, so they are not moving for some time, they will "fall asleep".  That is, they will not be calculated during the physics update since they are not going anywhere.  If you move a Kinematic Rigidbody out from underneath normal Rigidbodies that are at rest on top of it, the sleeping Rigidbodies will "wake up" and be correctly calculated again in the physics update.  So if you have a lot of Static Colliders that you want to move around and have different object fall on them correctly, use Kinematic Rigidbody Colliders.
</p>

<h3>Collision action matrix</h3>
<p>Depending on the configurations of the two colliding Objects, a number of different actions can occur.  The chart below outlines what you can expect from two colliding Objects, based on the components that are attached to them.  Some of the combinations only cause one of the two Objects to be affected by the collision, so keep the standard rule in mind &mdash; physics will not be applied to objects that do not have Rigidbodies attached.
</p>


<p><table class="wikitable"><tr><td class="wikicell"  colspan="7"><div align="center"><b>Collision detection occurs and messages are sent upon collision</b></div></td></tr><tr><td class="wikicell" ></td><td class="wikicell" >Static Collider</td><td class="wikicell" >Rigidbody Collider</td><td class="wikicell" >Kinematic Rigidbody Collider</td><td class="wikicell" >Static Trigger Collider</td><td class="wikicell" >Rigidbody Trigger Collider</td><td class="wikicell" >Kinematic Rigidbody Trigger Collider</td></tr><tr><td class="wikicell" >Static Collider</td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td></tr><tr><td class="wikicell" >Rigidbody Collider</td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td></tr><tr><td class="wikicell" >Kinematic Rigidbody Collider</td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td></tr><tr><td class="wikicell" >Static Trigger Collider</td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td></tr><tr><td class="wikicell" >Rigidbody Trigger Collider</td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td></tr><tr><td class="wikicell" >Kinematic Rigidbody Trigger Collider</td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td></tr></table>
</p>


<p><table class="wikitable"><tr><td class="wikicell"  colspan="7"><div align="center"><b>Trigger messages are sent upon collision</b></div></td></tr><tr><td class="wikicell" ></td><td class="wikicell" >Static Collider</td><td class="wikicell" >Rigidbody Collider</td><td class="wikicell" >Kinematic Rigidbody Collider</td><td class="wikicell" >Static Trigger Collider</td><td class="wikicell" >Rigidbody Trigger Collider</td><td class="wikicell" >Kinematic Rigidbody Trigger Collider</td></tr><tr><td class="wikicell" >Static Collider</td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td></tr><tr><td class="wikicell" >Rigidbody Collider</td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td></tr><tr><td class="wikicell" >Kinematic Rigidbody Collider</td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td></tr><tr><td class="wikicell" >Static Trigger Collider</td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td></tr><tr><td class="wikicell" >Rigidbody Trigger Collider</td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td></tr><tr><td class="wikicell" >Kinematic Rigidbody Trigger Collider</td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td></tr></table>
</p>



<p>The Capsule Collider is made of two half-spheres joined together by a cylinder.  It is the same shape as the Capsule primitive.
</p>

<p><img class='figure' src='images/class-CapsuleCollider-0.jpg' />
</p>

<p><i>(Image of a rocket using a Capsule Collider for detecting impact)</i>
</p>

<h2>Properties</h2>
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Material</nobr></b></td><td> Reference to the <a href="../Components/class-PhysicMaterial.html">PhysicMaterial</a> that determines how this Collider interacts with others.
</td></tr><tr><td><b><nobr>Is Trigger</nobr></b></td><td> If enabled, this Collider is used for triggering events, and is ignored by the physics engine.

</td></tr><tr><td><b><nobr>Radius</nobr></b></td><td> The radius of the Collider.
</td></tr><tr><td><b><nobr>Height</nobr></b></td><td> The total height of the capsule.
</td></tr><tr><td><b><nobr>Direction</nobr></b></td><td> The axis of the capsule's lengthwise orientation in the object's local space.
</td></tr><tr><td><b><nobr>Center</nobr></b></td><td> The position of the Collider in the object's local space.
<p></td></tr></tr></table>
</p>

<h2>Details</h2>
<p>You can adjust the Capsule Collider's radius and height independently of each other.  It is used in the <a href="../Components/class-CharacterController.html">CharacterController</a> and works great for poles, or can be combined with other Colliders for unusual shapes.
</p>

<p><img class='figure' src='images/class-CapsuleCollider-1.jpg' />
</p>

<p><i>A standard Capsule Collider</i>
</p>


<p>Colliders work with Rigidbodies to bring physics in Unity to life.  Whereas Rigidbodies allow objects to be controlled by physics, Colliders allow objects to collide with each other.  Colliders must be added to objects independently of Rigidbodies.  A Collider does not necessarily need a Rigidbody attached, but a Rigidbody <span style="text-decoration:underline;">must</span> be attached in order for the object to react to collisions.
</p>

<p>When a collision between two Colliders occurs and if at least one of them has a Rigidbody attached, <a class="wiki"  href="../ScriptReference/Collider.html#OnCollisionEnter">three</a> <a class="wiki"  href="../ScriptReference/Collider.html#OnCollisionExit">collision</a> <a class="wiki"  href="../ScriptReference/Collider.html#OnCollisionStay">messages</a> are sent out to the objects attached to them. These events can be handled in scripting, and allow you to create unique behaviors with or without making use of the built-in Ageia physX engine.
</p>

<h3>Triggers</h3>
<p>An alternative way of using Colliders is to mark them as a Trigger, just check the IsTrigger property checkbox in the Inspector.  Triggers are effectively ignored by the physics engine, and have a unique set of <a class="wiki"  href="../ScriptReference/Collider.html#OnTriggerEnter">three</a> <a class="wiki"  href="../ScriptReference/Collider.html#OnTriggerExit">trigger</a> <a class="wiki"  href="../ScriptReference/Collider.html#OnTriggerStay">messages</a> that are sent out when a collision with a Trigger occurs.  Triggers are useful for triggering other events in your game, like cutscenes, automatic door opening, displaying tutorial messages, etc.  Use your imagination!
</p>

<p>Be aware that in order for two Triggers to send out trigger events when they collide, one of them must be attached to a Rigidbody. For a Trigger to collide with a normal Collider, one of them must have a Rigidbody attached.  For a detailed chart of different types of collisions, see the collision action matrix in the Advanced section below.
</p>

<h3>Friction and bouncyness</h3>

<p>Friction, bouncyness and softness is defined in the <a href="../Components/class-PhysicMaterial.html">physic material</a>. The <a href="../Manual/HOWTO-InstallStandardAssets.html">Standard Assets</a> contain the most common physic materials. To use one of them click on the material popup and select eg. Ice. You can also <a href="../Components/class-PhysicMaterial.html">create</a> your own physic materials and tweak all friction values.
</p>


<h2>Compound Colliders</h2>

<p>Compound Colliders are combinations of primitive Colliders, all together acting as a single Collider.  They come in handy when you have a complex mesh to use in collisions, but cannot use a Mesh Collider.  To create a Compound Collider, create child objects of your colliding object, then add a primitive Collider to each child object.  This allows you to position, rotate, and scale each Collider easily and independently of each other.
</p>

<p><img alt="" src=""img/wiki_up/RigidBody" border="0"  />
</p>

<p><i>A GameObject with a Rigidbody and multiple colliders attached</i>
</p>

<p>In the above picture, the terrain has a Mesh Collider attached.  Mesh Colliders work the best for terrain or environments made from irregular shapes. The Rigidbody has 3 child Colliders attached: capsule, cube and sphere. When Play mode begins, the Rigidbody falls due to gravity, and the 3 child Colliders fall with it. The 3 Collision primitives collide with the Mesh Collider, and the Rigidbody eventually balances and comes to rest on the 3 Colliders.
</p>

<p>Keep in mind, Mesh Colliders can't collide with each other, so the typical solution is to use primitive Colliders for any objects that move, and Mesh Colliders for static background objects.
</p>


<h2>Hints</h2>
<p><ul><li>
To add multiple Colliders for an object, create child objects and attach a Collider to each one.  This allows each Collider to be manipulated independently.
</li><li>You can look at the gizmos in the Scene view to see how the Collider is being calculated on your object.
</li><li>Colliders do their best to match the scale of an object. If you have a non-uniform scale (a scale which is different in each direction), only the Mesh Collider can match completely.
</li></ul>
</p>


<h2>Advanced</h2>
<h3>Collider combinations</h3>
<p>There are numerous different combinations of collisions that can happen in Unity.  Each game is unique, and different combinations may work better for different types of games.  If you're using physics in your game, it will be very helpful to understand the different basic Collider types, their common uses, and how they interact with other types of objects.
</p>

<h4><span style="text-decoration:underline;">Static Collider</span></h4>
<p>These are Game Objects that <span style="text-decoration:underline;">do not</span> have a Rigidbody attached, but <span style="text-decoration:underline;">do</span> have a Collider attached.  These objects should remain still, or move very little.  These work great for your environment geometry.  They will not move if a Rigidbody collides with them.
</p>

<h4><span style="text-decoration:underline;">Rigidbody Collider</span></h4>
<p>These Game Objects contain both a Rigidbody and a Collider.  They are completely affected by the physics engine through scripted forces and collsions.  They might collide with a Game Object that only contains a Collider.  These will likely be your primary type of Object in games that use physics.
</p>

<h4><span style="text-decoration:underline;">Kinematic Rigidbody Collider</span></h4>
<p>This Game Object contains a Collider and a Rigidbody which is marked IsKinematic.  To move this Object, you modify its <a href="../Components/class-Transform.html">Transform</a> component, rather than applying forces. They're similar to Static Colliders but will work better when you want to move the Collider around frequently.  There are some other specialized scenarios for using this Object.
</p>

<p>This object can be used for circumstances in which you would normally want a Static Collider to send a trigger event.  Since a Trigger must have a Rigidbody attached, you should add a Rigidbody, then check IsKinematic.  This will prevent your Object from moving from physics influence, and allow you to receive trigger events when you want to.
</p>

<p>Kinematic Rigidbodies can easily be turned on and off.  This is great for creating ragdolls, when you normally want a character to follow an animation, then turn into a ragdoll when a collision occurs, prompted by an explosion or anything else you choose.  When this happens, simply turn all your Kinematic Rigidbodies into normal Rigidbodies through scripting.
</p>

<p>If you have Rigidbodies come to rest, so they are not moving for some time, they will "fall asleep".  That is, they will not be calculated during the physics update since they are not going anywhere.  If you move a Kinematic Rigidbody out from underneath normal Rigidbodies that are at rest on top of it, the sleeping Rigidbodies will "wake up" and be correctly calculated again in the physics update.  So if you have a lot of Static Colliders that you want to move around and have different object fall on them correctly, use Kinematic Rigidbody Colliders.
</p>

<h3>Collision action matrix</h3>
<p>Depending on the configurations of the two colliding Objects, a number of different actions can occur.  The chart below outlines what you can expect from two colliding Objects, based on the components that are attached to them.  Some of the combinations only cause one of the two Objects to be affected by the collision, so keep the standard rule in mind &mdash; physics will not be applied to objects that do not have Rigidbodies attached.
</p>


<p><table class="wikitable"><tr><td class="wikicell"  colspan="7"><div align="center"><b>Collision detection occurs and messages are sent upon collision</b></div></td></tr><tr><td class="wikicell" ></td><td class="wikicell" >Static Collider</td><td class="wikicell" >Rigidbody Collider</td><td class="wikicell" >Kinematic Rigidbody Collider</td><td class="wikicell" >Static Trigger Collider</td><td class="wikicell" >Rigidbody Trigger Collider</td><td class="wikicell" >Kinematic Rigidbody Trigger Collider</td></tr><tr><td class="wikicell" >Static Collider</td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td></tr><tr><td class="wikicell" >Rigidbody Collider</td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td></tr><tr><td class="wikicell" >Kinematic Rigidbody Collider</td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td></tr><tr><td class="wikicell" >Static Trigger Collider</td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td></tr><tr><td class="wikicell" >Rigidbody Trigger Collider</td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td></tr><tr><td class="wikicell" >Kinematic Rigidbody Trigger Collider</td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td></tr></table>
</p>


<p><table class="wikitable"><tr><td class="wikicell"  colspan="7"><div align="center"><b>Trigger messages are sent upon collision</b></div></td></tr><tr><td class="wikicell" ></td><td class="wikicell" >Static Collider</td><td class="wikicell" >Rigidbody Collider</td><td class="wikicell" >Kinematic Rigidbody Collider</td><td class="wikicell" >Static Trigger Collider</td><td class="wikicell" >Rigidbody Trigger Collider</td><td class="wikicell" >Kinematic Rigidbody Trigger Collider</td></tr><tr><td class="wikicell" >Static Collider</td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td></tr><tr><td class="wikicell" >Rigidbody Collider</td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td></tr><tr><td class="wikicell" >Kinematic Rigidbody Collider</td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td></tr><tr><td class="wikicell" >Static Trigger Collider</td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td></tr><tr><td class="wikicell" >Rigidbody Trigger Collider</td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td></tr><tr><td class="wikicell" >Kinematic Rigidbody Trigger Collider</td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td></tr></table>
</p>




<p>The Mesh Collider takes a <a href="../Components/class-Mesh.html">Mesh Asset</a> and builds its Collider based on that mesh.  It is far more accurate for collision detection than using primitives for complicated meshes, but it cannot collide with other Mesh Colliders.
</p>

<p><img class='figure' src='images/class-MeshCollider-0.jpg' />
</p>

<p><i>A Mesh Collider used on the flag tower object</i>
</p>

<h2>Properties</h2>
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Material</nobr></b></td><td> Reference to the <a href="../Components/class-PhysicMaterial.html">PhysicMaterial</a> that determines how this Collider interacts with others.
</td></tr><tr><td><b><nobr>Is Trigger</nobr></b></td><td> If enabled, this Collider is used for triggering events, and is ignored by the physics engine.

</td></tr><tr><td><b><nobr>Mesh</nobr></b></td><td> Reference to the Mesh to use for collisions.
</td></tr><tr><td><b><nobr>Smooth Sphere Collisions</nobr></b></td><td> When this is enabled, collision mesh normals are smoothed. You should enable this on smooth surfaces eg. rolling terrain without hard edges to make sphere rolling smoother.
<p></td></tr></tr></table>
</p>

<h2>Details</h2>
<p>The Mesh Collider builds its collision representation from the <a href="../Components/class-Mesh.html">Mesh</a> attached to the GameObject, and reads the properties of the attached <a href="../Components/class-Transform.html">Transform</a> to set its position and scale correctly.
</p>

<p>Collision meshes use backface culling. If an object collides with a mesh that will be back face culled graphically it will also not collide with it physically.
</p>


<p>Colliders work with Rigidbodies to bring physics in Unity to life.  Whereas Rigidbodies allow objects to be controlled by physics, Colliders allow objects to collide with each other.  Colliders must be added to objects independently of Rigidbodies.  A Collider does not necessarily need a Rigidbody attached, but a Rigidbody <span style="text-decoration:underline;">must</span> be attached in order for the object to react to collisions.
</p>

<p>When a collision between two Colliders occurs and if at least one of them has a Rigidbody attached, <a class="wiki"  href="../ScriptReference/Collider.html#OnCollisionEnter">three</a> <a class="wiki"  href="../ScriptReference/Collider.html#OnCollisionExit">collision</a> <a class="wiki"  href="../ScriptReference/Collider.html#OnCollisionStay">messages</a> are sent out to the objects attached to them. These events can be handled in scripting, and allow you to create unique behaviors with or without making use of the built-in Ageia physX engine.
</p>

<h3>Triggers</h3>
<p>An alternative way of using Colliders is to mark them as a Trigger, just check the IsTrigger property checkbox in the Inspector.  Triggers are effectively ignored by the physics engine, and have a unique set of <a class="wiki"  href="../ScriptReference/Collider.html#OnTriggerEnter">three</a> <a class="wiki"  href="../ScriptReference/Collider.html#OnTriggerExit">trigger</a> <a class="wiki"  href="../ScriptReference/Collider.html#OnTriggerStay">messages</a> that are sent out when a collision with a Trigger occurs.  Triggers are useful for triggering other events in your game, like cutscenes, automatic door opening, displaying tutorial messages, etc.  Use your imagination!
</p>

<p>Be aware that in order for two Triggers to send out trigger events when they collide, one of them must be attached to a Rigidbody. For a Trigger to collide with a normal Collider, one of them must have a Rigidbody attached.  For a detailed chart of different types of collisions, see the collision action matrix in the Advanced section below.
</p>

<h3>Friction and bouncyness</h3>

<p>Friction, bouncyness and softness is defined in the <a href="../Components/class-PhysicMaterial.html">physic material</a>. The <a href="../Manual/HOWTO-InstallStandardAssets.html">Standard Assets</a> contain the most common physic materials. To use one of them click on the material popup and select eg. Ice. You can also <a href="../Components/class-PhysicMaterial.html">create</a> your own physic materials and tweak all friction values.
</p>


<h2>Hints</h2>
<p><ul><li>
Mesh Colliders <span style="text-decoration:underline;">cannot</span> collide with each other.  Therefore, they are most useful for background objects like environment geometry.
</li><li>It is usually better to use primitive Colliders for objects under physics control.
</li><li>When you attach a Mesh Collider to a Game Object, its Mesh property will default to the mesh being rendered. You can change that by assigning a different Mesh.
To add multiple Colliders for an object, create child objects and attach a Collider to each one.  This allows each Collider to be manipulated independently.
</li><li>You can look at the gizmos in the Scene view to see how the Collider is being calculated on your object.
</li><li>Colliders do their best to match the scale of an object. If you have a non-uniform scale (a scale which is different in each direction), only the Mesh Collider can match completely.
</li></ul>
</p>


<h2>Advanced</h2>
<h3>Collider combinations</h3>
<p>There are numerous different combinations of collisions that can happen in Unity.  Each game is unique, and different combinations may work better for different types of games.  If you're using physics in your game, it will be very helpful to understand the different basic Collider types, their common uses, and how they interact with other types of objects.
</p>

<h4><span style="text-decoration:underline;">Static Collider</span></h4>
<p>These are Game Objects that <span style="text-decoration:underline;">do not</span> have a Rigidbody attached, but <span style="text-decoration:underline;">do</span> have a Collider attached.  These objects should remain still, or move very little.  These work great for your environment geometry.  They will not move if a Rigidbody collides with them.
</p>

<h4><span style="text-decoration:underline;">Rigidbody Collider</span></h4>
<p>These Game Objects contain both a Rigidbody and a Collider.  They are completely affected by the physics engine through scripted forces and collsions.  They might collide with a Game Object that only contains a Collider.  These will likely be your primary type of Object in games that use physics.
</p>

<h4><span style="text-decoration:underline;">Kinematic Rigidbody Collider</span></h4>
<p>This Game Object contains a Collider and a Rigidbody which is marked IsKinematic.  To move this Object, you modify its <a href="../Components/class-Transform.html">Transform</a> component, rather than applying forces. They're similar to Static Colliders but will work better when you want to move the Collider around frequently.  There are some other specialized scenarios for using this Object.
</p>

<p>This object can be used for circumstances in which you would normally want a Static Collider to send a trigger event.  Since a Trigger must have a Rigidbody attached, you should add a Rigidbody, then check IsKinematic.  This will prevent your Object from moving from physics influence, and allow you to receive trigger events when you want to.
</p>

<p>Kinematic Rigidbodies can easily be turned on and off.  This is great for creating ragdolls, when you normally want a character to follow an animation, then turn into a ragdoll when a collision occurs, prompted by an explosion or anything else you choose.  When this happens, simply turn all your Kinematic Rigidbodies into normal Rigidbodies through scripting.
</p>

<p>If you have Rigidbodies come to rest, so they are not moving for some time, they will "fall asleep".  That is, they will not be calculated during the physics update since they are not going anywhere.  If you move a Kinematic Rigidbody out from underneath normal Rigidbodies that are at rest on top of it, the sleeping Rigidbodies will "wake up" and be correctly calculated again in the physics update.  So if you have a lot of Static Colliders that you want to move around and have different object fall on them correctly, use Kinematic Rigidbody Colliders.
</p>

<h3>Collision action matrix</h3>
<p>Depending on the configurations of the two colliding Objects, a number of different actions can occur.  The chart below outlines what you can expect from two colliding Objects, based on the components that are attached to them.  Some of the combinations only cause one of the two Objects to be affected by the collision, so keep the standard rule in mind &mdash; physics will not be applied to objects that do not have Rigidbodies attached.
</p>


<p><table class="wikitable"><tr><td class="wikicell"  colspan="7"><div align="center"><b>Collision detection occurs and messages are sent upon collision</b></div></td></tr><tr><td class="wikicell" ></td><td class="wikicell" >Static Collider</td><td class="wikicell" >Rigidbody Collider</td><td class="wikicell" >Kinematic Rigidbody Collider</td><td class="wikicell" >Static Trigger Collider</td><td class="wikicell" >Rigidbody Trigger Collider</td><td class="wikicell" >Kinematic Rigidbody Trigger Collider</td></tr><tr><td class="wikicell" >Static Collider</td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td></tr><tr><td class="wikicell" >Rigidbody Collider</td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td></tr><tr><td class="wikicell" >Kinematic Rigidbody Collider</td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td></tr><tr><td class="wikicell" >Static Trigger Collider</td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td></tr><tr><td class="wikicell" >Rigidbody Trigger Collider</td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td></tr><tr><td class="wikicell" >Kinematic Rigidbody Trigger Collider</td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td></tr></table>
</p>


<p><table class="wikitable"><tr><td class="wikicell"  colspan="7"><div align="center"><b>Trigger messages are sent upon collision</b></div></td></tr><tr><td class="wikicell" ></td><td class="wikicell" >Static Collider</td><td class="wikicell" >Rigidbody Collider</td><td class="wikicell" >Kinematic Rigidbody Collider</td><td class="wikicell" >Static Trigger Collider</td><td class="wikicell" >Rigidbody Trigger Collider</td><td class="wikicell" >Kinematic Rigidbody Trigger Collider</td></tr><tr><td class="wikicell" >Static Collider</td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td></tr><tr><td class="wikicell" >Rigidbody Collider</td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td></tr><tr><td class="wikicell" >Kinematic Rigidbody Collider</td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td></tr><tr><td class="wikicell" >Static Trigger Collider</td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center"> </div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td></tr><tr><td class="wikicell" >Rigidbody Trigger Collider</td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td></tr><tr><td class="wikicell" >Kinematic Rigidbody Trigger Collider</td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td><td class="wikicell" ><div align="center">&bull;</div></td></tr></table>
</p>




<p>The <b>Wheel Collider</b> is a special collider for grounded vehicles. It has built-in collision detection, wheel physics, and a slip-based tire friction model.
</p>

<p><img class='figure' src='images/class-WheelCollider-0.jpg' />
</p>

<p><i>The <b>Wheel Collider</b> Component. Car model courtesy of ATI Technologies Inc.</i>
</p>

<h2>Properties</h2>
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Center</nobr></b></td><td> Center of the wheel in object local space.
</td></tr><tr><td><b><nobr>Radius</nobr></b></td><td> Radius of the wheel.
</td></tr><tr><td><b><nobr>Suspension Distance</nobr></b></td><td> Maximum extension distance of wheel suspension, measured in local space. Suspension always extends downwards the local Y-axis.
</td></tr><tr><td><b><nobr>Suspension Spring</nobr></b></td><td> The suspension attempts to reach a target position by adding spring and damping forces.
<dl><dt>Spring</dt><dd> <b>Spring</b> force attempts to reach the <b>Target Position</b>. A larger value makes the suspension reach the <b>Target Position</b> faster.</dd><dt>Damper</dt><dd> Dampens the suspension velocity. A larger value makes the suspension <b>Spring</b> move slower.</dd><dt>Target Position</dt><dd> The suspension's rest distance along <b>Suspension Distance</b>. 0 maps to fully extended suspension, and 1 maps to fully compressed suspension. Default value is zero, which matches the behavior of regular car's suspension.</dd></dl>
</td></tr><tr><td><b><nobr>Mass</nobr></b></td><td> The Mass of the wheel.
</td></tr><tr><td><b><nobr>Forward/Sideways Friction</nobr></b></td><td> Properties of tire friction when the wheel is rolling forward and sideways. See <i>Wheel Friction Curves</i> section below.
<p></td></tr></tr></table>
</p>

<h2>Details</h2>

<p>The wheel's collision detection is performed by casting a ray from <b>Center</b> downwards the local Y-axis. The wheel has a <b>Radius</b> and can extend downwards according to <b>Suspension Distance</b>. The vehicle is controlled from scripting using the <i>motorTorque</i>, <i>brakeTorque</i> and <i>steerAngle</i> properties of the Wheel Collider component; see the <a class="wiki"  href="../ScriptReference/WheelCollider.html">Wheel Collider scripting reference</a> for more information.
</p>

<p>The Wheel Collider computes friction separately from the rest of physics engine, using a slip based friction model. This allows for more realistic behaviour, but also makes Wheel Colliders ignore standard <a href="../Components/class-PhysicMaterial.html">Physic Material</a> settings.
</p>

<h3>Wheel collider setup</h3>

<p>You do not turn or roll WheelCollider objects to control the car - the objects that have WheelCollider attached should always be fixed relative to the car itself. However, you might want to turn and roll the graphical wheel representations. The best way to do this is to setup separate objects for WheelColliders and visible wheels:
</p>

<p><img class='figure' src='images/class-WheelCollider-1.jpg' />
</p>

<p><i>Wheel Collider objects are separated from visible wheel models</i>
</p>

<h3>Collision geometry</h3>

<p>Because cars can achieve large velocities, getting race track collision geometry right is very important. Specifically, the <a href="../Components/class-MeshCollider.html">collision mesh</a> should not have small bumps or dents that make up the visible models (e.g. fence poles). Usually collision mesh for the race track is made separately from the visible mesh, making the collision mesh as smooth as possible. It also should not have thin objects - if you have a thin track border, make it wider in collision mesh (or completely remove the other side if the car can never go there).
</p>

<p><img class='figure' src='images/class-WheelCollider-2.jpg' />
</p>

<p><i>Visible geometry (left) is much more complex than collision geometry (right)</i>
</p>

<h3>Wheel Friction Curves</h3>

<p>Tire friction can be described by the <i>Wheel Friction Curve</i> shown below. There are separate curves for wheel's forward (rolling) direction and sideways direction. In both directions it is first determined how much the tire is slipping (based on the speed difference between the tire's rubber and the road). Then this slip value is used to find out tire force exerted on the contact point.
</p>

<p>The curve takes a measure of tire slip as an input and gives a force as output. The curve is approximated by a two-piece spline. The first section goes from <i>(0 , 0)</i> to <i>(<b>ExtremumSlip</b> , <b>ExtremumValue</b>)</i>, at which point the curve's tangent is zero. The second section goes from <i>(<b>ExtremumSlip</b> , <b>ExtremumValue</b>)</i> to <i>(<b>AsymptoteSlip</b> , <b>AsymptoteValue</b>)</i>, where curve's tangent is again zero:
</p>

<p><img class='figure' src='images/class-WheelCollider-3.jpg' />
</p>

<p><i>Typical shape of a wheel friction curve</i>
</p>

<p>The property of real tires is that for low slip they can exert high forces, since the rubber compensates for the slip by stretching. Later when the slip gets really high, the forces are reduced as the tire starts to slide or spin. Thus,  tire friction curves have a shape like in the image above.
</p>

<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Extremum Slip/Value</nobr></b></td><td> Curve's extremum point.
</td></tr><tr><td><b><nobr>Asymptote Slip/Value</nobr></b></td><td> Curve's asymptote point.
</td></tr><tr><td><b><nobr>Stiffness</nobr></b></td><td> Multiplier for the <b>Extremum Value</b> and <b>Asymptote Value</b> (default is 1). Changes the stiffness of the friction. Setting this to zero will completely disable all friction from the wheel. Usually you modify stiffness at runtime to simulate various ground materials from scripting.
<p></td></tr></tr></table>
</p>

<h2>Hints</h2>
<ul><li> You might want to decrease physics timestep length in <a href="../Components/class-TimeManager.html">Time Manager</a> to get more stable car physics, especially if it's a racing car that can achieve high velocities.
</li><li> To keep a car from flipping over too easily you can lower it's <a href="../Components/class-Rigidbody.html">Rigidbody</a> center of mass a bit from script, and apply &quot;down pressure&quot; force that depends on car velocity.
</li></ul>



<p>The Hinge Joint groups together 2 <a href="../Components/class-Rigidbody.html">Rigidbodies</a>, constraining them to move like they are connected by a hinge. It is perfect for doors, but can also be used to model chains, pendulums, etc.
</p>

<p><img class='figure' src='images/class-HingeJoint-0.jpg' />
</p>

<p><i>The Hinge Joint</i>
</p>

<h2>Properties</h2>
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Connected Body</nobr></b></td><td> Optional reference to the Rigidbody that the joint is dependent upon. If not set, the joint connects to the world.
</td></tr><tr><td><b><nobr>Anchor</nobr></b></td><td> The Position of the anchor around which the body swings. The Position is defined in local space.
</td></tr><tr><td><b><nobr>Axis</nobr></b></td><td> The Direction of the axis around which the body swings. The Axis is defined in local space.
</td></tr><tr><td><b><nobr>Use Spring</nobr></b></td><td> Spring makes the rigid body reach for a specific angle compared to its connected body.
</td></tr><tr><td><b><nobr>Spring</nobr></b></td><td> The force the object asserts to move into the position.
</td></tr><tr><td><b><nobr>Damper</nobr></b></td><td> the higher this value, the more the object will slow down.
</td></tr><tr><td><b><nobr>Target Position</nobr></b></td><td> Target angle of the spring. The spring pulls towards this angle measured in degrees.
</td></tr><tr><td><b><nobr>Use Motor</nobr></b></td><td> The motor makes the object spin around.
</td></tr><tr><td><b><nobr>Target Velocity</nobr></b></td><td> The speed the object tries to attain.
</td></tr><tr><td><b><nobr>Force</nobr></b></td><td> The force applied in order to attain the speed.
</td></tr><tr><td><b><nobr>Free Spin</nobr></b></td><td> If enabled, the motor is never used to brake the spinning, only accelerate it.
</td></tr><tr><td><b><nobr>Use Limits</nobr></b></td><td> If enabled, the angle of the hinge will be restricted within the <b>Min</b> &amp; <b>Max</b> values.
</td></tr><tr><td><b><nobr>Min</nobr></b></td><td> The lowest angle the rotation can go.
</td></tr><tr><td><b><nobr>Max</nobr></b></td><td> The highest angle the rotation can go.
</td></tr><tr><td><b><nobr>Min Bounce</nobr></b></td><td> How much the object bounces when it hits the minimum stop.
</td></tr><tr><td><b><nobr>Max Bounce</nobr></b></td><td> How much the object bounces when it hits the maximum stop.
</td></tr><tr><td><b><nobr>Break Force</nobr></b></td><td> The force that needs to be applied for this joint to break.
</td></tr><tr><td><b><nobr>Break Torque</nobr></b></td><td> The torque that needs to be applied for this joint to break.
<p></td></tr></tr></table>
</p>

<h2>Details</h2>

<p>A single Hinge Joint should be applied to an object per desired hinge.  The hinge will rotate at the point specified by the <b>Anchor</b> property, moving around the specified <b>Axis</b> property.  You DO NOT need to assign a Game Object to the joint's <b>Connected Body</b> property.  You should only assign a Game Object to the <b>Connected Body</b> property if you want the joint's Transform to be dependent on the attached object's Transform.
</p>

<p>Think about how the hinge of a door works. The <b>Axis</b> in this case is up, positive along the Y axis. The <b>Anchor</b> is placed somewhere at the intersection between door and wall.  You would not need to assign the wall to the <b>Connected Body</b>, because the joint will be connected to the world by default.
</p>

<p><img class='figure' src='images/class-HingeJoint-1.jpg' />
</p>

<p><i>A practical Hinge Joint with no <b>Connected Body</b></i>
</p>

<p>Now think about a doggy door hinge. The doggy door's <b>Axis</b> would be sideways, positive along the relative X axis.  The main door should be assigned as the <b>Connected Body</b>, so the doggy door's hinge is dependent on the main door's Transform.
</p>

<p><img class='figure' src='images/class-HingeJoint-2.jpg' />
</p>

<p><i>A practical Hinge Joint with a proper <b>Connected Body</b></i>
</p>


<h3>Chains</h3>

<p>Multiple Hinge Joints can also be strung together to create a chain.  Add a joint to each link in the chain, and attach the next link as a <b>Connected Body</b>.  The result should be similar to the following picture.
</p>

<p><img class='figure' src='images/class-HingeJoint-3.jpg' />
</p>

<p><i>A Nunchaku made exclusively with primitives and Hinge Joints</i>
</p>

<h3>Vehicles</h3>

<p>Hinge Joints can be implemented as axles on vehicles, as seen here in Forest Johnson's racing game. However, it's often better just to use a <a href="../Components/class-WheelCollider.html">Wheel Collider</a> for vehicles.
</p>

<p><img class='figure' src='images/class-HingeJoint-4.jpg' />
</p>

<h2>Hints</h2>
<p><ul><li>
You do not need to assign a <b>Connected Body</b> to your joint for it to work.
</li><li>Use <b>Break Force</b> in order to make dynamic damage systems. This is really cool as it allows the player to break a door off its hinge by blasting it with a rocket launcher or running into it with a car.
</li><li>The <b>Spring</b>, <b>Motor</b>, and <b>Limits</b> properties allow you to fine-tune your joint's behaviors.
</li></ul>
</p>


<p>The Spring Joint groups together 2 Rigidbodies, constraining them to move like they are connected by a spring.
</p>

<p><img class='figure' src='images/class-SpringJoint-0.jpg' />
</p>

<p><i>The Spring Joint</i>
</p>

<h2>Properties</h2>
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Connected Body</nobr></b></td><td> Optional reference to the Rigidbody that the joint is dependent upon.
</td></tr><tr><td><b><nobr>Anchor</nobr></b></td><td> Position in the object's local space (at rest) that defines the center of the joint.
</td></tr><tr><td><b><nobr>X</nobr></b></td><td> Position of the joint's center along the X axis.
</td></tr><tr><td><b><nobr>Y</nobr></b></td><td> Position of the joint's center along the Y axis.
</td></tr><tr><td><b><nobr>Z</nobr></b></td><td> Position of the joint's center along the Z axis.
</td></tr><tr><td><b><nobr>Spring</nobr></b></td><td> Strength of the spring.  The farther from the Anchor, the stronger the spring will pull.
</td></tr><tr><td><b><nobr>Damper</nobr></b></td><td> Amount that the spring is reduced when active.
</td></tr><tr><td><b><nobr>Min Distance</nobr></b></td><td> Distances greater than this will not cause the Spring to activate.
</td></tr><tr><td><b><nobr>Max Distance</nobr></b></td><td> Distances less than this will not cause the Spring to activate.
</td></tr><tr><td><b><nobr>Break Force</nobr></b></td><td> The force that needs to be applied for this joint to break.
</td></tr><tr><td><b><nobr>Break Torque</nobr></b></td><td> The torque that needs to be applied for this joint to break.
<p></td></tr></tr></table>
</p>

<h2>Details</h2>

<p>Spring Joints allow you to define a point in 3D space that any particular object is drawn to.  As an object travels further away from that point, the Spring Joint applies forces that will pull it back to its <b>Anchor</b> position.  This creates an effect very similar to a rubber band or a slingshot.
</p>

<h3>Connected Rigidbody</h3>
<p>You do not need to connect a Rigidbody for your joint to work.  Use of <b>Connected Rigidbodies</b> depends on the situation, and the effect you are trying to achieve.  Generally, you should only connect a Rigidbody if your object is dependent on it <span style="text-decoration:underline;">and</span> the object will be moving and rotating.  If there is no <b>Connected Rigidbody</b>, your Spring will connect to the world.
</p>

<h3>Spring &amp; Damper</h3>

<p><b>Spring</b> is the strength of the Joint's force that draws the object back toward its designated <b>Anchor</b>.  If this is 0, then there is no force that will pull on the object, and it will behave as if no Spring is attached at all.
</p>

<p><b>Damper</b> is the resistance encountered by the <b>Spring</b> force.  The lower this is, the springier the object will be.  As the <b>Damper</b> is increased, the amount of bounciness caused by the Spring will be reduced.
</p>

<h3>Min &amp; Max Distance</h3>

<p>If the position of your object falls in-between the <b>Min &amp; Max Distances</b>, then the spring will not affect your object.  The position must be moved outside of these values for the Spring to activate.
</p>

<h2>Hints</h2>
<p><ul><li>
You do not need to assign a <b>Connected Body</b> to your joint for it to work.
</li><li>Spring Joints require your object to have a <b>Rigidbody</b> attached
</li></ul>
</p>



<p><img class='figure' src='images/class-FixedJoint-0.jpg' />
</p>

<p><i>The Fixed Joint</i>
</p>

<h2>Properties</h2>
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Connected Body</nobr></b></td><td> Optional reference to the Rigidbody that the joint is dependent upon. If not set, the joint connects to the world.
</td></tr><tr><td><b><nobr>Break Force</nobr></b></td><td> The force that needs to be applied for this joint to break.
</td></tr><tr><td><b><nobr>Break Torque</nobr></b></td><td> The torque that needs to be applied for this joint to break.
<p></td></tr></tr></table>
</p>

<h2>Details</h2>

<p>Fixed Joints lock an object's movement to be dependent upon another object.  This is somewhat similar to Parenting but is implemented through physics rather than object hierarchy.  The best scenarios for using them are when you have objects that you want to easily break apart from each other, or connect two object's movement without parenting.
</p>

<h3>Dynamic joints</h3>

<p>There may be scenarios in your game where you want objects to stick together permanently or temporarily.  <b>Fixed Joints</b> may be a good component to use for these scenarios, since you will not have to script a change in your object's hierarchy to achieve the desired effect.  The trade-off is that you must use Rigidbodies for any objects to want to use a <b>Fixed Joint</b>.
</p>

<p>For example, if you want to use a &quot;sticky grenade&quot;, you can write a script that will detect collision with another Rigidbody (like an enemy), and then create a <b>Fixed Joint</b> that will attach itself to that Rigidbody.  Then as the enemy moves around, the joint will keep the grenade stuck to them.
</p>

<h3>Breaking joints</h3>

<p>You can use the <b>Break Force</b> and <b>Break Torque</b> properties to set limits for the joint's strength.  If these are less than infinity, and a force/torque greater than these limits are applied to the object, its Fixed Joint will be destroyed and will no longer be confined by its restraints.
</p>

<h2>Hints</h2>
<p><ul><li>
You do not need to assign a <b>Connected Body</b> to your joint for it to work.
</li><li>Fixed Joints require your objed to have a <b>Rigidbody</b> attached
</li></ul>
</p>


<p>The Constant Force component is a quick utility for adding constant forces to a rigidbody.
This works great for one shot objects like rockets, if you don't want it to start with a large velocity but instead accelerate.
</p>

<p><img class='figure' src='images/class-ConstantForce-0.jpg' />
</p>

<p><i>A rocket propelled forward by the constant force component</i>
</p>

<h2>Properties</h2>
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Force</nobr></b></td><td> The vector of a force to be applied in world space.
</td></tr><tr><td><b><nobr>Relative Force</nobr></b></td><td> The vector of a force to be applied in the objects local space.
</td></tr><tr><td><b><nobr>Torque</nobr></b></td><td> The vector of a torque, applied in world space. The object will begin spinning <i>around</i> this vector. The longer the vector is, the faster the rotation.
</td></tr><tr><td><b><nobr>Relative Torque</nobr></b></td><td> The vector of a torque, applied in local space. The object will begin spinning <i>around</i> this vector. The longer the vector is, the faster the rotation.
<p></td></tr></tr></table>
</p>

<h3> Details</h3>

<p>To make a rocket that accelerates forward set the relative force to be along the positive z-axis. Then use the rigidbody's drag property to make it not exceed a some maximum velocity. (The higher the drag the lower the maximum velocity will be.)
In the rigidbody also make sure to turn off gravity so that the rocket will always stay on it's path.
</p>

<h2>Hints</h2>
<p><ul><li>
To make an object flow upwards, add a constant force with the Force property having a positive Y value.
</li><li>To make an object fly forwards,  add a constant force with the Relative Force property having a positive Z value.
</li></ul>
</p>



<p>The physic material is used to adjust friction and bouncing effects of colliding objects.
</p>

<p>To create a physic material select the menu <b>Assets -&gt; Create -&gt; Physic Material</b>.  Then drag the physic material from the project pane on a collider in the scene.
</p>

<p><img class='figure' src='images/class-PhysicMaterial-0.jpg' />
</p>

<p><i>The Physic Material</i>
</p>

<h2>Properties</h2>
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Static Friction</nobr></b></td><td> The friction used when an object is lying on a surface. Usually a value from 0 to 1. A value of zero feels like ice, a value of 1 will make it very hard to get the object moving.
</td></tr><tr><td><b><nobr>Dynamic Friction</nobr></b></td><td> The friction used when already moving. Usually a value from 0 to 1. A value of zero feels like ice, a value of 1 will make it come to rest very quickly unless a lot of force / gravity pushes the object.
</td></tr><tr><td><b><nobr>Bouncyness</nobr></b></td><td> How bouncy is the surface? A value of 0 will not bounce. A value of 1 will bounce without any loss of energy.
</td></tr><tr><td><b><nobr>Friction Combine Mode</nobr></b></td><td> How the friction of two colliding objects is combined.
</td></tr><tr><td><b><nobr>Average</nobr></b></td><td> The two friction values are averaged.
</td></tr><tr><td><b><nobr>Min</nobr></b></td><td> The smallest of the two values is used.
</td></tr><tr><td><b><nobr>Max</nobr></b></td><td> The largest of the two values is used.
</td></tr><tr><td><b><nobr>Multiply</nobr></b></td><td> The friction values are multiplied with each other.
</td></tr><tr><td><b><nobr>Bounce Combine Mode</nobr></b></td><td> How the bouncyness of two colliding objects is combined.
</td></tr><tr><td><b><nobr>Average</nobr></b></td><td> The two values are averaged.
</td></tr><tr><td><b><nobr>Min</nobr></b></td><td> The smallest of the two values is used.
</td></tr><tr><td><b><nobr>Max</nobr></b></td><td> The largest of the two values is used.
</td></tr><tr><td><b><nobr>Multiply</nobr></b></td><td> The values are multiplied with each other.
</td></tr><tr><td><b><nobr>Friction Direction 2</nobr></b></td><td> The direction of anisotropy. Anisotropic friction is enabled if the vector3 is not zero. Dynamic Friction 2 and Static Friction 2 will be applied along Friction Direction 2.
</td></tr><tr><td><b><nobr>Dynamic Friction 2</nobr></b></td><td> If anisotropic friction is enabled, dynamicFriction2 will be applied along Friction Direction 2.
</td></tr><tr><td><b><nobr>Static Friction 2</nobr></b></td><td> If anisotropic friction is enabled, staticFriction2 will be applied along Friction Direction 2.
</td></tr><tr><td><b><nobr>Static Friction 2</nobr></b></td><td> If anisotropic friction is enabled, staticFriction2 will be applied along Friction Direction 2.
</td></tr><tr><td><b><nobr>Use Spring</nobr></b></td><td> If use Spring is checked, surface will be springy.
</td></tr><tr><td><b><nobr>Spring</nobr></b></td><td> The spring of the surface
</td></tr><tr><td><b><nobr>Spring</nobr></b></td><td> The spring coefficient. A high value will pull the surfaces towards the rest position faster.
</td></tr><tr><td><b><nobr>Damper</nobr></b></td><td> The damper coefficient. A high value will dampen the relative movement of the two surfaces.
</td></tr><tr><td><b><nobr>Target Position</nobr></b></td><td> The rest position of the spring.
<p></td></tr></tr></table>
</p>

<h2>Details</h2>

<p>Friction is the quantity which prevents surfaces from sliding off each other. This value is critical when trying to stack objects.
Friction comes in two forms, dynamic and static. Static friction is used when the object is lying still. It will prevent the object from starting to move. If a large enough force is applied to the object it will start moving. At this point dynamic friction will come into play. Dynamic friction will now attempt to slow down the object while in contact with another.
</p>

<h2>Hints</h2>
<p><ul><li>
Don't try to use a standard physic material for the main character. Make a customized one and get it perfect.
</li></ul>
</p>



<p>Character Joint's are mainly used for Ragdoll effects. They are an extended ball-socket joint which allows you to limit the joint on each axis.
</p>

<p>If you just want to set up a ragdoll go <a href="../Components/wizard-RagdollWizard.html">here</a>.
</p>

<p><i>The Character Joint</i>
</p>

<h2>Properties</h2>
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Connected Body</nobr></b></td><td> Optional reference to the Rigidbody that the joint is dependent upon. If not set, the joint connects to the world.
</td></tr><tr><td><b><nobr>Axis</nobr></b></td><td> The twist axes. Visualized with the orange gizmo cone.
</td></tr><tr><td><b><nobr>Swing Axis</nobr></b></td><td> The swing axis. Visualized with the green gizmo cone.
</td></tr><tr><td><b><nobr>Low Twist Limit</nobr></b></td><td> The lower limit of the joint


</td></tr><tr><td><b><nobr>Break Force</nobr></b></td><td> The force that needs to be applied for this joint to break.
</td></tr><tr><td><b><nobr>Break Torque</nobr></b></td><td> The torque that needs to be applied for this joint to break.
<p></td></tr></tr></table>
</p>

<h2>Details</h2>

<p>Character joint's give you a lot of possibilities for contstraining motion like with a universal joint.
</p>

<p>The twist axis (visualized with the orange gizmo) gives you most control over the limits as you can specify a lower and upper limit in degrees. (The limit angle is measured relative to the starting position.)
A value of -30 in <i>Low Twist Limit - Limit</i> and 60 in <i>High Twist Limit - Limit</i> limits the rotation around the twist axis (orange gizmo) between -30 and 60 degrees.
</p>

<p>The Swing 1 Limit limits the rotation around the swing axis (green axis). The limit angle is symmetric. Thus a value of eg. 30 will limit the rotation between -30 and 30.
</p>

<p>The Swing 2 Limit axis doesn't have a gizmo but the axis is orthogonal to the 2 other axes.
Just like the previous axis the limit is symmetric, thus a value of eg. 40 will limit the rotation around that axis between -40 and 40 degrees.
</p>

<h3>Breaking joints</h3>

<p>You can use the <b>Break Force</b> and <b>Break Torque</b> properties to set limits for the joint's strength.  If these are less than infinity, and a force/torque greater than these limits are applied to the object, its Fixed Joint will be destroyed and will no longer be confined by its restraints.
</p>

<h2>Hints</h2>
<p><ul><li>
You do not need to assign a <b>Connected Body</b> to your joint for it to work.
</li><li>Character Joints require your object to have a <b>Rigidbody</b> attached
</li></ul>
</p>


<p>These components implement sound in Unity.
</p>

<ul><li> <a href="../Components/class-AudioListener.html">Audio Listener</a> - Add this to a camera to get 3D positional sound.
</li><li> <a href="../Components/class-AudioSource.html">Audio Source</a> - Add this component to an object to make it make a sound.
</li></ul>



<p>The Audio Listener acts as a microphone-like device. It receives input from any given <a href="../Components/class-AudioSource.html">Audio Source</a> in the scene and plays sounds through the computer speakers.  It is traditionally attached to the main <a href="../Components/class-Camera.html">Camera</a>.
</p>

<p><img class='figure' src='images/class-AudioListener-0.jpg' />
</p>

<p><i>The Audio Listener, attached to the Main Camera</i>
</p>

<h2>Properties</h2>
<p>The Audio Listener has no properties.  It simply must be added to work.
</p>

<h2>Details</h2>
<p>The Audio Listener works in conjunction with <a href="../Components/class-AudioSource.html">Audio Sources</a>, allowing you to create the aural experience of your games.  When the Audio Listener is attached to an object in your scene, any Sources that are close enough to the Listener will be picked up and played through the player's computer speakers.  Each scene can only have 1 Audio Listener to work properly.
</p>

<p>As long as the Sources are in mono format, the Listener will automatically position the sound in the correct speaker, at the correct volume.  Stereo Sources will automatically play in both speakers.  For example, if your character walks off a street into a night club, the night club's music should probably be stereo, while the individual voices of characters in the club should be mono.
</p>

<p>You should attach the Audio Listener to either the main camera or to the game object that represents the player. Try both to find what suits your game best.
</p>

<h2>Hints</h2>
<p><ul><li>
Each scene can only have one Audio Listener.
</li><li>You access the project-wide audio settings using the <a href="../Components/class-AudioManager.html">AudioManager</a>, found in the Edit-&gt;Project Settings-&gt;Audio menu.
</li></ul>
</p>




<p>The Audio Source takes an <a href="../Components/class-AudioClip.html">Audio Clip</a> and plays it from a position in the world.
</p>

<p><img class='figure' src='images/class-AudioSource-0.jpg' />
</p>

<p><i>The Audio Source in the scene view and Inspector</i>
</p>

<h2> Properties</h2>
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Audio Clip</nobr></b></td><td> Reference to the sound clip file that will be played
</td></tr><tr><td><b><nobr>Play On Awake</nobr></b></td><td> If enabled, the sound will start playing the moment the scene launches. If disabled, you need to start it using the Play() command from scripting.
</td></tr><tr><td><b><nobr>Volume</nobr></b></td><td> How loud the sound is at 1 world unit's (1 meter) distance from Audio Listener.
</td></tr><tr><td><b><nobr>Min Volume</nobr></b></td><td> The minimum value of the sound. No matter how far away you get, the sound will get softer.
</td></tr><tr><td><b><nobr>Max Volume</nobr></b></td><td> How loud the sound gets at the loudest. No matter how close you get, the sound will never get louder.
</td></tr><tr><td><b><nobr>Rolloff Factor</nobr></b></td><td> How fast the sound fades. the higher the value, the shorter the range the Listener can hear the sound.
</td></tr><tr><td><b><nobr>Loop</nobr></b></td><td> Enable this to make the <b>Audio Clip</b> loop when it finishes playing.
<p></td></tr></tr></table>
</p>

<h2> Hints</h2>
<p><ul><li>
The key to a nice sound environment is tweaking the <b>Rolloff Factor</b>.
</li><li>The 3D audio effects will only work for mono audio clips. Stereo audio clips will be mixed as-is into the sound output.
</li></ul>
</p>




<p>GameObjects are containers for all other Components. All objects in your game are inherently GameObjects.
</p>

<p><ul class="toc"><li class="toclevel"><a href="../Components/class-GameObject.html">GameObject</a></li></ul>
</p>



<p>GameObjects are containers for all other Components. All objects in your game are inherently GameObjects.
</p>

<p><img class='figure' src='images/class-GameObject-0.jpg' />
</p>

<p><i>The GameObject viewed in the Inspector</i>
</p>

<h2>Details</h2>

<p>GameObjects do not add any characteristics to the game themselves.  Rather, they are containers that hold Components, which implement all actual functionality. For example, a <a href="../Components/class-Light.html">Light</a> is a Component which is attached to a GameObject. From scripts, Components can easily communicate with each other through message sending or the GetComponent(<i>TypeName</i>) method. This allows you to write small, reusable scripts that can be attached to multiple GameObjects and reused for different purposes.
</p>

<p>Aside from being a container for the components, GameObjects have a <b>Tag</b>, a <b>Layer</b> and a <b>Name</b>.
</p>

<p><b>Tags</b> are used to quickly find objects, utilizing the Tag name. <b>Layers</b> can be used to cast rays, render, or apply lighting to certain groups of objects only. Tags and Layers can be set with the <a href="../Components/class-TagManager.html">Tag Manager</a>, found in <b>Edit -&gt; Project Settings -&gt; Tags</b>.
</p>

<h2>Hints</h2>
<ul><li> For more information see the GameObject <a class="wiki"  href="../ScriptReference/GameObject.html">scripting documentation</a>.
</li><li> More information about how to use layers can be found <a href="../ScriptingConcepts/Layers.html">here</a>.
</li></ul>




<p>This group is for all components that handle object positioning.
<ul class="toc"><li class="toclevel"><a href="../Components/class-Transform.html">Transform</a></li></ul>
</p>


<p>The Transform component determines the physical location, rotation, and scale of all objects in the scene. Every object has a Transform.
</p>

<p><img class='figure' src='images/class-Transform-0.jpg' />
</p>

<p><i>The Transform component of the Game Object is viewable and editable in the Inspector</i>
</p>



<h2>Properties</h2>
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Position</nobr></b></td><td>Position of the Transform in X, Y, and Z coordinates

</td></tr><tr><td><b><nobr>Rotation</nobr></b></td><td>Rotation of the Transform around the X, Y, and Z axes, measured in degrees
</td></tr><tr><td><b><nobr>Scale</nobr></b></td><td>Scale of the Transform along X, Y, and Z axes.  Value &quot;1&quot; is the size at which the object was imported.
<p></td></tr></tr></table>
All properties of a Transform are measured relative to the Transform's parent.  If the Transform has no parent, the properties are measured relative to the World.
</p>



<h2>Using Transforms</h2>
<p>Transforms are always manipulated in 3-D space using X, Y, and Z axes.  In Unity, these axes are represented by the colors red, green, and blue respectively.
</p>

<p><img class='figure' src='images/class-Transform-1.jpg' />
</p>

<p><i>Color-coded relationship between 3 axes and Transform properties</i>
</p>

<p>Transform components can be directly manpulated using the Scene view or the Inspector.  The Inspector will list the properties stated above for easy editing.
</p>

<p><img class='figure' src='images/class-Transform-2.jpg' />
</p>

<p><i>Translation along the X axis (Left/Right)</i>
</p>

<p><img class='figure' src='images/class-Transform-3.jpg' />
</p>

<p><i>Translation along the Y axis (Up/Down)</i>
</p>

<p><img class='figure' src='images/class-Transform-4.jpg' />
</p>

<p><i>Translation along the Z axis (Forward/Backward)</i>
</p>

<p>You can also modify Transforms in your Scene by interacting with them, using the Move, Rotate, and Scale tools.  These tools are located in the upper left-hand corner of the Unity UI.
</p>

<p><img class='figure' src='images/class-Transform-5.jpg' />
</p>

<p><i>The View, Translate, Rotate, and Scale tools</i>
</p>

<p>The tools will be usable on any object in your scene.  Click on the object, and you will see the tool gizmo appear around it.  Depending on the current tool, the gizmo will look slightly different.  Clicking the object will also cause the Transform component to become visible in the Inspector.  If the Inspector does not display the Transform component or its properties, then you do not have an object highlighted in the scene view.
</p>

<p><img class='figure' src='images/class-Transform-6.jpg' />
</p>

<p><i>Different Gizmos for the 3 tools can be directly edited in Scene view</i>
</p>


<p>To manipulate the Transform, click and drag on one of the 3 gizmo axes, you'll notice its color changes to yellow.  As you drag the mouse, you will see the object translate, rotate, or scale along the axis.  When you release the mouse button, you'll notice that the axis remains yellow.  You can click the middle mouse button and drag the mouse to manipulate the Transform around the yellow axis.  To access all 3 axes at once click and drag the center point of all 3 gizmos.
</p>

<p><img class='figure' src='images/class-Transform-7.jpg' />
</p>

<p><i>Any individual axis will change yellow when you click on it</i>
</p>



<h3>Parenting</h3>
<p>Parenting is one of the most important concepts to understand when using Unity. It is a method of attaching two or more objects together, creating a &quot;Parent&quot; and a &quot;Child&quot; or &quot;Children&quot;  Each object can have multiple children, but only one parent.
</p>

<p>The principle behind parenting is simple; you can attach objects to each other - just like your arms are attached to your body. When you turn your body, your arms move. An object can only have one parent (just like each of your arms can only be attached to one body), but each object can have many children (your body does have two arms, after all).
</p>

<p><img class='figure' src='images/class-Transform-8.jpg' />
</p>

<p><i>Example of the Parenting concept</i>
</p>

<p>In the above example, we say that the arms are parented to the body, and the hands are parented to the arms. The scenes you make in Unity will contain collections of these <i>Transform hierarchies</i>. The topmost parent object is called the <i>Root object</i>. When you move, scale, or rotate a parent, all the changes in its Transform are applied to its children as well.
</p>

<p>You can build compound objects by parenting multiple separate objects together, like the skeletal structure of a human ragdoll. You can also create small yet effective objects with single parents.  For example, if you have a horror game that takes place at night, you can create an effective atmosphere with a flashlight.  To create this object, you would parent a  spotlight Transform to the flashlight Transform.  Then, any alteration of the flashlight Transform will affect the spotlight, creating a convincing flashlight effect.
</p>

<p>Creating and removing parents is performed in the <i>Hierarchy</i> window.  The hierarchy window will display all the objects currently in your scene.  To create a parent, drag the desired child object over the desired parent object in your Hierarchy, and release.  You have then <i>parented</i> your child to its new parent.  To remove the child from its parent, click and drag the child object outside of the parent object.
</p>


<h2>Importance of scale</h2>
<p>The scale of the Transform determines the difference between the size of your mesh in your modeling application, and the size of your mesh in Unity. The mesh's size in Unity (and therefore the Transform's scale) is <span style="text-decoration:underline;">very</span> important, especially  during physics simulation.   There are 3 factors that can determine the scale of your object:
</p>
<ul><li>The size of your mesh in your 3D modeling application
</li><li>The Global scale setting in your <i>Import Settings</i> menu
</li><li>The scale values of your Transform component
</li></ul>

<p>Ideally, you should not adjust the scale of your object in the Transform component.  The best option is to create your models at real-life scale, so you won't have to change your Transform's scale.  The second-best option is to adjust the scale at which your mesh is imported in the <i>Import Settings</i> for your individual mesh.  Certain optimizations occur based on the import size, and instantiating an object that has an adjusted scale value can decrease performance.  For more information, read through the <a href="../Components/class-Rigidbody.html">Rigidbody</a> component's section on optimizing scale.
</p>


<h2>Hints</h2>
<p><ul><li>
When parenting Transforms, make sure the new parent is located at 0,0,0 before applying the child.  This will save you many headaches later.
</li><li>Particle systems are the only type of Transform that are not affected by Scale. In order to scale a particle system, you need to modify the particle emitter, animator and renderer properties.
</li><li>If you are using Rigidbodies for physics simulation, there is some important information about the Scale property to be read on the  <a href="../Components/class-Rigidbody.html">Rigidbody</a> page.
</li><li>You can change the colors of the axes (and other UI elements) from the Unity Menu -&gt; Preferences -&gt; Colors &amp; keys.
</li><li>If you can avoid scaling, avoid scaling.  Try to have the scales of your object finalized in your 3D modeling application, or in the <i>Import Settings</i> of your mesh.
</li></ul>
</p>


<p>This group handles all components that have to do with rendering in-game and user interface elements.  Lighting and special effects are also included in this group.
</p>

<p><ul class="toc"><li class="toclevel"><a href="../Components/class-Camera.html">Camera</a></li><li class="toclevel"><a href="../Components/class-Light.html">Light</a></li><li class="toclevel"><a href="../Components/class-Projector.html">Projector</a></li><li class="toclevel"><a href="../Components/class-Halo.html">Halo</a></li><li class="toclevel"><a href="../Components/class-LensFlare.html">LensFlare</a></li><li class="toclevel"><a href="../Components/class-GuiTexture.html">GuiTexture</a></li><li class="toclevel"><a href="../Components/class-GuiText.html">GuiText</a></li><li class="toclevel"><a href="../Components/class-Skybox.html">Skybox</a></li><li class="toclevel"><a href="../Components/class-GUILayer.html">GUILayer</a></li><li class="toclevel"><a href="../Components/class-FlareLayer.html">FlareLayer</a></li><li class="toclevel"><a href="../Components/class-HaloLayer.html">HaloLayer</a></li></ul>
</p>



<p>Cameras are the devices that capture and display the world to the player.  By customizing and manipulating cameras, you can make the presentation of your game truly unique.  You can have an unlimited number of cameras in a scene. They can be set to render in any order, at any place on the screen, or only certain parts of the screen.
</p>

<p><img class='figure' src='images/class-Camera-0.jpg' />
</p>

<p><i>Unity's flexible Camera object</i>
</p>

<h2>Properties</h2>
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Clear Flags</nobr></b></td><td> Determines which parts of the screen will be cleared.  This is handy when using multiple Cameras to draw different game elements.
</td></tr><tr><td><b><nobr>Background color</nobr></b></td><td> Color applied to the remaining screen after all elements in view have been drawn and there is no skybox.
</td></tr><tr><td><b><nobr>Normalized View Port Rect</nobr></b></td><td> Four values that indicate where on the screen this camera view will be drawn, in Screen Coordinates.
</td></tr><tr><td><b><nobr>    Xmin</nobr></b></td><td>The beginning horizontal position that the camera view will be drawn.
</td></tr><tr><td><b><nobr>    Ymin</nobr></b></td><td>The beginning vertical position that the camera view will be drawn.
</td></tr><tr><td><b><nobr>    Xmax</nobr></b></td><td>The ending horizontal position that the camera view will be drawn.
</td></tr><tr><td><b><nobr>    Ymax</nobr></b></td><td>The ending vertical position that the camera view will be drawn.
</td></tr><tr><td><b><nobr>Near Clip Plane</nobr></b></td><td> The closest point relative to the camera that drawing will occur.
</td></tr><tr><td><b><nobr>Far Clip Plane</nobr></b></td><td> The furthest point relative to the camera that drawing will occur.
</td></tr><tr><td><b><nobr>Field of view</nobr></b></td><td> Width of the Camera's view angle, measured in degrees along the local Y axis.
</td></tr><tr><td><b><nobr>Is ortho graphic</nobr></b></td><td> Toggles the camera's capability to simulate perspective.
</td></tr><tr><td><b><nobr>Orthographic size</nobr></b></td><td> The viewport size of the Camera when it is Orthographic.
</td></tr><tr><td><b><nobr>Depth</nobr></b></td><td> The camera's position in the draw order. Cameras with a higher depth will be drawn on top of cameras with a lower depth value.
</td></tr><tr><td><b><nobr>Culling Mask</nobr></b></td><td> Include or omit layers of objects to be rendered by the Camera.  Assign layers to your objects in the Inspector.
</td></tr><tr><td><b><nobr>Render Target (Pro)</nobr></b></td><td> Reference to a Render Texture that will contain the output of the Camera view
<p></td></tr></tr></table>
</p>

<h2>Details</h2>
<p>Cameras are essential for displaying your game to the player.  They can be customized, scripted, or parented to achieve just about any kind of effect imaginable.  For a puzzle game, you might keep the Camera static for a full view of the puzzle.  For a first-person shooter, you would parent the Camera to the player character, and place it at the character's eye level.  For a racing game, you'd likely want to have the Camera follow your player's vehicle.
</p>

<p>You can create multiple Cameras and assign each one to a different depth.  Cameras are drawn from low depth to high depth.  In other words, a Camera with a depth of 2 will be drawn on top of a Camera with a depth of 1.  You can adjust the values of the <b>Normalized View Port Rectangle</b> property to resize and position the Camera's view onscreen.  This can create multiple mini-views like missile cams, map views, rear-view mirrors, etc.
</p>

<p><img class='figure' src='images/class-Camera-1.jpg' />
</p>

<p><i>Multiple Cameras making use of <b>Normalized View Port Rectangle</b></i>
</p>

<h3>Clear Flags</h3>

<p>Each Camera stores a color and depth information when it renders its view.  The portions of the screen that are not filled with a game object are empty, and will display the skybox by default.  When you are using multiple Cameras, each one stores its own color and depth information in buffers, accumulating more data as each Camera renders.  As any particular Camera in your scene renders its view, you can set the <b>Clear Flags</b> to clear different collections of the buffer information. This is done by choosing one of the four options:
</p>

<h4><span style="text-decoration:underline;">Skybox</span></h4>
<p>This is the default setting.  Any empty portions of the screen will display the current Camera's skybox.  If the current Camera has no skybox set, it will default to the skybox chosen in the <a href="../Components/class-RenderSettings.html">Render Settings</a> (found in <b>Edit -&gt; Render Settings</b>).  It will then fall back to the <b>Background Color</b>.
</p>

<h4><span style="text-decoration:underline;">Solid Color</span></h4>
<p>Any empty portions of the screen will display the current Camera's <b>Background Color</b>.
</p>

<h4><span style="text-decoration:underline;">Depth Only</span></h4>
<p>For example, if you wanted to draw a player's gun without letting it get clipped inside the environment, you would set one Camera at Depth 0 to draw the environment, and another Camera at Depth 1 to draw the weapon alone.  The weapon Camera's <b>Clear Flags</b> should be set to to &quot;depth only&quot;.  This will keep the graphical display of the environment on the screen, but discard all information about where each object exists in 3-D space.  When the gun is drawn, the opaque parts will completely cover anything drawn, regardless of how close the gun is to the wall.
</p>

<p><img class='figure' src='images/class-Camera-2.jpg' />
</p>

<p><i>The gun is drawn last, after clearing the depth buffer of the cameras before it</i>
</p>

<h4><span style="text-decoration:underline;">Don't Clear</span></h4>
<p>This mode does not clear either the color or the depth buffer.  The result is that each frame is drawn over the next, resulting in a smear-looking effect.  This isn't typically used in games, and would likely be best used with a custom shader.
</p>

<h3>Clip Planes</h3>

<p>The <b>Near</b> and <b>Far Clip Plane</b> properties determine where the Camera's view begins and ends.  The planes are laid out perpendicular to the Camera's direction and are measured from the its position.  The <b>Near plane</b> is the closest location that will be rendered, and the <b>Far plane</b> is the furthest.
</p>

<p><img class='figure' src='images/class-Camera-3.jpg' />
</p>

<p><i>Far Clip Plane set to small versus large distance</i>
</p>

<p>The clipping planes also determine how depth buffer precision is distributed over the scene. In general, to get better precision you should move the <b>Near plane</b> as far as possible.
</p>

<h3>Culling Mask</h3>

<p>The Culling Mask is used for selectively rendering groups of objects using Layers.  More information on using layers can be found <a href="../ScriptingConcepts/Layers.html">here</a>.
</p>

<p>Commonly, it is good practice to put your User Interface on a different layer, then render it by itself with a separate camera set to render the UI layer by itself.
</p>

<p>In order for the UI to display on top of the other Camera views, you'll also need to set the <b>Clear Flags</b> to &quot;Depth only&quot; and make sure that the UI Camera's <b>Depth</b> is higher than the other Cameras.
</p>

<h3>Normalized Viewport Rectangle</h3>

<p><b>Normalized Viewport Rectangles</b> are specifically for defining a certain portion of the screen that the current camera view will be drawn upon.  You can put a map view in the lower-right hand corner of the screen, or a missile-tip view in the upper-left corner.  With a bit of design work, you can use Viewport Rectangle to create some unique behaviors.
</p>

<p>It's easy to create a two-player split screen effect using Normalized Viewport Rectangle.  After you have created your two cameras, change player one's Ymin value to 0.5, and player two's Ymax: value to 0.5.  This will make player one's camera display from halfway up the screen to the top, and player two's camera will start at the bottom and stop halfway up the screen.
</p>

<p><img class='figure' src='images/class-Camera-4.jpg' />
</p>

<p><i>Two-player display created with Normalized Viewport Rectangle</i>
</p>

<h3>Orthographic</h3>

<p>Marking a Camera as orthographic removes all perspective from the Camera's view.
</p>

<p><img class='figure' src='images/class-Camera-5.jpg' />
</p>

<p><i>A non-orthographic and orthographic camera viewports</i>
</p>


<h3>Render Texture</h3>

<p>This feature is only available for Unity Pro licenses.  It will place the camera's view onto a <a href="../Components/class-RenderTexture.html"> Texture</a> that can then be applied to another object.  This makes it easy to create sports arena video monitors, surveillance cameras, reflections etc.
</p>

<p><img class='figure' src='images/class-Camera-6.jpg' />
</p>

<p><i>Render Texture used to create a live Arena-Cam</i>
</p>

<h2>Hints</h2>
<p><ul><li>
Cameras can be instantiated, parented, and scripted just like any other Game Object.
</li><li>To increase the sense of speed in a racing game, use a high field of view.
</li><li>Cameras can be used in physics simulation if you add a Rigidbody component.
</li><li>There is no limit to the number of Cameras you can have in your scenes.
</li><li>Orthographic cameras are great for making 3-D user interfaces
</li><li>Pro license holders have the option of rendering a Camera's view to a texture, called Render-to-Texture, for even more unique effects.
</li><li>Unity comes with pre-installed Camera scripts, found in <b>Components -&gt; Camera Control</b>.  Experiment with them to get a taste of what's possible.
</li><li>If you are experiencing depth artifacts (close surfaces flickering), try setting <b>Near Plane</b> to as large value as possible in your scene.
</li></ul>
</p>



<p>Lights will bring personality and flavor to your game. You use lights to illuminate the scenes and objects to create the perfect visual mood. Lights can be used to simulate the sun, match light, flashlights, gun-fire, or explosions, just to name a few.
</p>

<p><img class='figure' src='images/class-Light-0.jpg' />
</p>

<p><i>The Light Component</i>
</p>

<p>There are three types of lights in Unity:
</p>
<ul><li> <i>Point lights</i> shine from a location equally in all directions, like a light bulb.
</li><li> <i>Directional lights</i> are placed infinitely far away and affect everything in the scene, like the sun.
</li><li> <i>Spot lights</i> shine from a point in a direction and only illuminate objects within a cone - like the headlights of a car.
</li></ul>

<p><img class='figure' src='images/class-Light-1.jpg' />
</p>

<p><i>The three different light types in Unity</i>
</p>

<h2>Properties</h2>

<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>Type</nobr></b></td><td> The current type of light object
<dl><dt>Directional</dt><dd> A light placed infinitely far away. It affects everything in the scene and can not attenuate.</dd><dt>Point</dt><dd> A light that shines equally in all directions from its location, affecting all objects within its <b>Range</b>.</dd><dt>Spot</dt><dd> A light that shines everywhere within a cone (<b>Spot Angle</b>), and a <b>Range</b>. Only objects within this region are affected by the light.</dd></dl>
</td></tr><tr><td><b><nobr>Color</nobr></b></td><td> The color of the light emitted
</td></tr><tr><td><b><nobr>Attenuate</nobr></b></td><td> Does the light diminish with increasing distance? If disabled, objects' brightness will &quot;pop&quot; as they enter and exit the light's region of influence. It can be useful to turn off when you want to do some special effects. If the light is directional, this property is ignored.
</td></tr><tr><td><b><nobr>Range</nobr></b></td><td> How far light is emitted from the center of the object.
</td></tr><tr><td><b><nobr>Spot Angle</nobr></b></td><td> If the light is a Spot light, this determines the angle of the cone in degrees.
</td></tr><tr><td><b><nobr>Cookie</nobr></b></td><td> You can assign a texture to a light. The alpha channel of this texture is used as a mask that determines how bright the light is at different places. If the light is a <b>Spot</b> or a <b>Directional</b> light, this must be a 2D texture. If the light is a <b>Point</b> light, it must be a cubemap.
</td></tr><tr><td><b><nobr>Draw Halo</nobr></b></td><td> If checked, a spherical halo of light will be drawn with a radius equal to <b>Range</b>.
</td></tr><tr><td><b><nobr>Flare</nobr></b></td><td> Optional reference to the <a href="../Components/class-Flare.html">Flare</a> that will be rendered at the light's position.
</td></tr><tr><td><b><nobr>Render Mode</nobr></b></td><td> Choose whether this light is rendered as a vertex light, pixel light, or determined automatically. For a detailed description of this tradoff, see <i>Performance Considerations</i> below. Options include
<dl><dt>Auto</dt><dd> The rendering method is determined at runtime depending on the brightness of nearby lights and current <a href="../Components/class-QualitySettings.html">QualitySettings</a>.</dd><dt>Force Pixel</dt><dd> This light is always rendered at per-pixel quality. Use this for very important effects only (e.g. headlights of a player's car).</dd><dt>Force Vertex</dt><dd> This light is always rendered as a vertex-lit light.</dd></dl>
</td></tr><tr><td><b><nobr> Culling Mask</nobr></b></td><td> Use to selectively exclude groups of objects from being affected by the light; see <a href="../ScriptingConcepts/Layers.html">Layers</a>.
<p></td></tr></tr></table>
</p>

<h2>Details</h2>

<p>There are three basic light types in Unity. Each type can be customized to fit your needs.
</p>

<p>You can use a texture that contains an alpha channel and assign it to be projected from any of the light types. This texture then becomes the cookie. The cookie's alpha mask modulates the light amount, creating light and dark spots on surfaces. They are a great way af adding lots of complexity to a scene, and hence providing a lot of atmosphere.
</p>

<p>All builtin shaders in Unity seamlessly work with any type of light (<i>VertexLit</i> type shaders ignore light cookies though).
</p>

<h3>Point Lights</h3>

<p><img class='figure' src='images/class-Light-2.jpg' />
</p>

<p>Point lights shine out from a point in all directions. They are the most common lights in computer games - typically used for explosions, light bulbs, etc.  They have an average cost on the graphics processor.
</p>

<p>Point light cookies must be cubemaps with an alpha channel. This cubemap gets projected out in all directions.
</p>


<p><img class='figure' src='images/class-Light-3.jpg' />
</p>


<h3>Spot Lights</h3>

<p><img class='figure' src='images/class-Light-4.jpg' />
</p>

<p>Spot lights only shine in one direction, in a cone.  They are Perfect for flashlights or car headlights.  They cost the most expensive on the graphics processor.
</p>

<p>The cookie is projected down the cone of the spot light. This is good for creating an effect of light shining through a window. It is very important that the texture is black at the edges and its wrapping mode is set to <i>clamp</i>. For more info on this, see Texture
		print STDERR "WARN: nonexistent page href="tiki-editpage.php?page=class-FileTexture" , removing link
";
	
</p>


<h3>Directional Lights</h3>
<p>Directional lights are used mainly in outdoor scenes for sun &amp; moonlight.  The light affect all surfaces of objects in your scene.  They are the least expensive on the graphics processor.
</p>

<p><img class='figure' src='images/class-Light-5.jpg' />
</p>

<p>With a directional light, the cookie is projected down the center of the light's Z axis. If you want to stretch it out over a large area, set the texture's wrapping mode to 'repeat' (select the texture in the project window, and in the Inspector for the texture instead of 'Clamp' select 'Repeat').
</p>

<p><img class='figure' src='images/class-Light-6.jpg' />
</p>

<p>The above is a great way to add some quick detail to large outdoor scenes. You can even slide the light slowly over the scene to give the impression of moving clouds.
</p>


<h2>Performance considerations</h2>
<p>Lights can be rendered in one of two methods: vertex lighting and per-pixel lighting. Vertex lighting only calculates the lighting at the vertices of the game models, and interpolates the lighting over the surfaces of the models. Per-pixel lights are calculated at every screen pixel, and hence are much more expensive.  Some older graphics cards only support vertex lighting.
</p>

<p><img class='figure' src='images/class-Light-7.jpg' />
</p>

<p>Lights have a big impact on rendering speed - therefore a tradeoff has to be made betwen lighting quality and game speed. Since per-pixel lights are much more expensive than per-vertex lights, Unity will only render the brightest lights at per-pixel quality. The actual number of pixel lights can be set as in the <a href="../Components/class-QualitySettings.html">Quality Settings</a>.
</p>

<p>You can explicitly control if a light should be rendered as a vertex or pixel light using the <b>Render Mode</b> setting of the light. By default Unity will classify the light automatically based on how much the object is affected by the light.
</p>

<p>The actual lights that are rendered as pixel lights are determined on an object-by-object case. This means:
</p>
<ul><li> Huge objects with bright lights could use all the pixel lights (depending on the quality settings). If the player is far from these, nearby lights will be rendered as vertex lights.  Therefore, it is better to split huge objects up in a couple of small ones.
</li></ul>

<p>See <a href="../Manual/Optimizing Graphics Performance.html">here</a> for more information about optimizing rendering performance.
</p>

<h2>Creating Cookies</h2>

<p>For more information on creating cookies, please see the tutorial on how to create a Spot Light cookie <a href="../Manual/HOWTO-LightCookie.html">here</a>.
</p>

<h2>Hints</h2>
<p><ul><li>
Spotlights with textures can be extremely effective for making light coming in from windows. In this case, disable attenuation, and set the range to just reach the floor.
</li><li>Low-intensity point lights are good for providing depth to a scene.
</li><li>Put a light near a particle system and assign a 'lighted' shader from the Particles group to its material. This works really well with projection textures.
</li><li>For high performance, use the <i>Vertex Lit</i> shader. This shader only does per-vertex lighting, giving a much higher throughput on low-end cards.
</li></ul>
</p>



<p>Projectors allow you to project an arbitrary material on all objects that intersect its frustum.
</p>

<p><img class='figure' src='images/class-Projector-0.jpg' />
</p>

<p><i>The Projector</i>
</p>

<h2>Properties</h2>
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Near Clip Plane</nobr></b></td><td> The Near clip plane of the Projector. Objects in front of the near clip plane will not be affected.
</td></tr><tr><td><b><nobr>Far Clip Plane</nobr></b></td><td> The Far clip plane of the Projector. Objects beyond this distance will not be affected.
</td></tr><tr><td><b><nobr>Field Of View</nobr></b></td><td> The field of view in degrees. This is only used if the Projector is not Ortho Graphic.
</td></tr><tr><td><b><nobr>Aspect Ratio</nobr></b></td><td> The Aspect Ratio of the Projector. This allows you to tune the height vs width of the Projector.
</td></tr><tr><td><b><nobr>Is Ortho Graphic</nobr></b></td><td> If enabled, the Projector will be Ortho Graphic instead of perspective.
</td></tr><tr><td><b><nobr>Ortho Graphic Size</nobr></b></td><td> The Ortho Graphic size of the Projection. this is only used if Is Ortho Graphic is turned on.
</td></tr><tr><td><b><nobr>Material</nobr></b></td><td> The Material that will be Projected onto Objects.
</td></tr><tr><td><b><nobr>Ignore Layers</nobr></b></td><td> Objects that are in one of the Ignore Layers will not be affected. By default, Ignore Layers is none so all geometry that intersects the Projector frustum will be affected.
<p></td></tr></tr></table>
</p>

<h2>Details</h2>
<p>With a projector you can:
</p>
<ol><li> Create shadows
</li><li> Make a real world projector on a tripod with another <a href="../Components/class-Camera.html">camera</a> that films some other part of the world using a render texture
</li><li> Create bullet marks
</li><li> Funky lighting effects.
</li></ol>

<p><img class='figure' src='images/class-Projector-1.jpg' />
</p>

<p><i>A projector used to create a Blob Shadow for this hovercraft</i>
</p>

<p>If you want to create a simple shadow effect, simply drag the <b>StandardAssets/Blob-Shadow/Blob shadow projector</b> prefab into your scene. You can modify the material to use a different Blob shadow texture.
</p>

<h2>Hints</h2>
<ul><li> Projector Blob shadows can create very impressive <i>Splinter Cell</i>-like lighting effects if used to shadow the environment properly.
</li><li> When no Falloff texture is used in the projector's material, it can project both forward and backward, creating &quot;double projection&quot;. To fix this, use an alpha-only Falloff texture that has a black leftmost pixel column.
</li></ul>




<p>Halos are light areas around light sources, used to give the impression of small dust particles in the air.
</p>

<p><img class='figure' src='images/class-Halo-0.jpg' />
</p>

<p><i>A light with a Halo.</i>
</p>

<h2>Properties</h2>

<p>Halos use the Halo Texture set up in <a href="../Components/class-RenderSettings.html"> Render Settings</a>. If none is set up, it uses a default one. A <a href="../Components/class-Light.html"> Light</a> component can be setup to automatically show halo, without a separate Halo component.
</p>

<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Color</nobr></b></td><td> Color of the halo.
</td></tr><tr><td><b><nobr> Size</nobr></b></td><td> Size of the halo.
<p></td></tr></tr></table>
</p>

<h2>Hints</h2>
<ul><li> To see halos in the scene view, check <b>Fx</b> button in the toolbar.
</li><li> A <a href="../Components/class-Camera.html"> camera</a> has to have a <a href="../Components/class-HaloLayer.html"> Halo Layer</a> component attached to make halos visible.
</li></ul>



<p>Lens flares simulate the effect of lights refracting inside camera lens. They are used to represent really bright lights or, more subtly, just to add a bit more atmosphere to your scene.
</p>

<p><img class='figure' src='images/class-LensFlare-0.jpg' />
</p>

<p><i>A lens flare over the skybox</i>
</p>

<p>The easiest way to setup a lens flare is just to assign Flare property of the <a href="../Components/class-Light.html">Light</a>. Unity contains a couple of flares in the <a href="../Manual/HOWTO-InstallStandardAssets.html"> Standard Assets package</a>.
</p>

<p>Otherwise, create an empty game object (<i>Game Object-&gt;Create Empty</i>), add this component to it (<i>Component-&gt;Rendering-&gt;Lens Flare</i>) and choose the flare in the Inspector.
</p>

<p>To see the effect of lens flare in the Scene View, check the <b>Fx</b> button in the toolbar:
</p>

<p><img class='figure' src='images/class-LensFlare-1.jpg' />
</p>


<h2>Properties</h2>
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Flare</nobr></b></td><td> A <a href="../Components/class-Flare.html">Flare</a> to render. The flare defines all aspects of the lens flare's appearance.
</td></tr><tr><td><b><nobr>Color</nobr></b></td><td> Some flares can be colorized to better fit in with your scene's mood.
</td></tr><tr><td><b><nobr>Brightness</nobr></b></td><td> How large and bright the lens flare is.
<p></td></tr></tr></table>
</p>

<h2>Details</h2>

<p>You can directly set flares as a property of a <a href="../Components/class-Light.html">Light</a> component, or set them up separately as Lens Flare component. If you attach them to a light, they will automatically track the position and direction of the light. To get more precise control, use this component.
</p>

<p>A <a href="../Components/class-Camera.html">camera</a> has to have a <a href="../Components/class-FlareLayer.html">Flare Layer</a> component attached to make flares visible (by default there is a flare layer in cameras, so you don't have to do anything special).
</p>

<h2>Hints</h2>
<p><ul><li>
Be discrete about your usage of lens flares.
</li><li>If you use a very bright lens flare, make sure it's direction fits with your scene's primary light source.
</li><li> To design your own flares, you need to create some flare Assets. Start by duplicating some of the ones we provided in the the <i>Lens Flares</i> folder of the Standard Assets, then modify from that.
</li></ul>
</p>




<p>GUI Textures are displayed as flat images in 2D. They are made especially for User Interface elements, buttons, or decorations.  Their positioning and scaling is performed along the x and y axes only, and they are measured in Screen Coordinates, rather than World Coordinates.
</p>

<p><img class='figure' src='images/class-GuiTexture-0.jpg' />
</p>

<p><i>The GUI Texture</i>
</p>

<h2>Properties</h2>
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Texture</nobr></b></td><td> Reference to the <a href="../Components/class-Texture2D.html">Texture2D</a> that will be used as the texture's display.
</td></tr><tr><td><b><nobr>Color</nobr></b></td><td> Value that will tint the <b>Texture</b> drawn on screen.
</td></tr><tr><td><b><nobr>Pixel Inset</nobr></b></td><td> Used for pixel-level control of the scaling and positioning of the GUI Texture. All values are measured relative to the position of the GUI Texture's <b>Transform</b>.
</td></tr><tr><td><b><nobr>    Xmin</nobr></b></td><td> Left-most pixel position of the texture.
</td></tr><tr><td><b><nobr>    Ymin</nobr></b></td><td> Bottom-most pixel position of the texture.
</td></tr><tr><td><b><nobr>    Xmax</nobr></b></td><td> Right-most pixel position of the texture.
</td></tr><tr><td><b><nobr>    Ymax</nobr></b></td><td> Top-most pixel position of the texture.
</td></tr><tr><td><b><nobr>Left Border</nobr></b></td><td> Number of pixels from the left that are not affected by scale.
</td></tr><tr><td><b><nobr>Right Border</nobr></b></td><td> Number of pixels from the right that are not affected by scale.
</td></tr><tr><td><b><nobr>Top Border</nobr></b></td><td> Number of pixels from the top that are not affected by scale.
</td></tr><tr><td><b><nobr>Bottom Border</nobr></b></td><td> Number of pixels from the bottom that are not affected by scale.
<p></td></tr></tr></table>
</p>

<h2>Details</h2>

<p>To create a gui texture
</p>
<ol><li> Select a texture in the project view
</li><li> Choose <b>Game Object -&gt; Create Other -&gt; GUI Texture</b>
</li></ol>


<p>GUI Textures are perfect for presenting game interface backgrounds, buttons, or other elements to the player.  Through scripting, you can easily provide visual feedback for different &quot;states&quot; of the texture &mdash; when the mouse is hovering over the texture, or is actively clicking it for example.  Here is the basic breakdown of how the GUI Texture is calculated:
</p>

<p><img class='figure' src='images/class-GuiTexture-1.jpg' />
</p>

<p>Here's a real-world example of GUI Texture at work from Unity forum member Bampf's game <span style="text-decoration:underline;">Pawns</span>.
</p>

<p><img class='figure' src='images/class-GuiTexture-2.jpg' />
</p>

<h3>Borders</h3>

<p>The number of pixels that will not scale with the texture at each edge of the image.  As you rarely know the resolution your game runs in, chances are your GUI will get scaled. Some GUI textures have a border at the edge that is meant to be an exact number of pixels. In order for this to work, set the border sizes to match those from the texture.
</p>

<h3>Pixel Inset</h3>

<p>The purpose of the <b>Pixel Inset</b> is to prevent textures from scaling with screen resolution, and keeping thim in a fixed pixel size. This allows you to render a texture without any scaling.  This means that players who run your game in higher resolutions will see your textures in smaller areas of the screen, allowing them to have more screen real-estate for your gameplay graphics.
</p>

<p>To use it effectively, you need to set the scale of the GUI Texture's <b>Transform</b> to 0, 0, 0. Now, the <b>Pixel Inset</b> is in full control of the texture's size and you can set the <b>Pixel Inset</b> values to be the exact pixel size of your texture.
</p>

<h2>Hints</h2>
<p><ul><li>
The depth of each layered GUI Texture is determined by its individual Z Transform position, not the global Z position.
</li><li><b>GUI Textures</b> are great for making menu screens, or pause/escape menu screens.
</li><li>You should use <b>Pixel Inset</b> on any GUI Textures that you want to be a specific number of pixels for the width and height.
</li></ul>
</p>





<p>GUI Text displays text of any font you import in screen coordinates.
</p>

<p><img class='figure' src='images/class-GuiText-0.jpg' />
</p>

<p><i>The GUI Text</i>
</p>

<h2>Properties</h2>
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Text</nobr></b></td><td> The string of text to display.
</td></tr><tr><td><b><nobr>Anchor</nobr></b></td><td> Which point of the text shares the position of the Transform.
</td></tr><tr><td><b><nobr>Alignment</nobr></b></td><td> How multiple lines are aligned within the GUIText.
</td></tr><tr><td><b><nobr>Line Spacing</nobr></b></td><td> How much space will be in-between lines of text.
</td></tr><tr><td><b><nobr>Tab Size</nobr></b></td><td> How much space will be inserted for a tab '\t' character. As a multiplum of the space character offset.
</td></tr><tr><td><b><nobr>Font</nobr></b></td><td> The <a href="../Components/class-Font.html">font</a> to use when rendering the text.
</td></tr><tr><td><b><nobr>Material</nobr></b></td><td> Reference to the Material containing the characters to be drawn. If set, this property overrides the one in the <a href="../Components/class-Font.html">Font</a> asset.
</td></tr><tr><td><b><nobr>Pixel Correct</nobr></b></td><td> If enabled, all text characters will be drawn in the size of the imported font texture. If disabled, the characters will be resized based on the transform's scale.
<p></td></tr></tr></table>
</p>

<h2>Details</h2>

<p>GUI Texts are used to print text onto the screen in 2D. The camera has to have a <a href="../Components/class-GUILayer.html">GUI Layer</a> attached in order to render the text.  Cameras include a GUI Layer by default, so don't remove it if you want to display a GUI Text.  GUI Texts are positioned using only the X and Y axes.  Rather than being positioned in World Coordinates, GUI Texts are positioned in Screen Coordinates, where (0,0) is the bottom-left and (1,1) is the top-right corner of the screen
</p>

<p>To import a font see the <a href="../Components/class-Font.html">Font class</a>.
</p>

<h3>Pixel Correct</h3>

<p>By default Fonts are rendered pixel correct. This makes them look crisp and they will stay the same size in pixels independent of the screen resolution.
</p>

<h2>Hints</h2>
<p><ul><li>
When entering text into the <b>Text</b> property, you can create a line break by holding <i>Alt</i> and pressing <i>Return</i>.
</li><li>You can download free true type fonts from <a class="wiki"  href="http://www.1001freefonts.com/fonts/afonts.htm">http://www.1001freefonts.com/fonts/afonts.htm</a> (download the windows fonts since they contain true type fonts).
</li><li>If you are scripting the <b>Text</b> property, you can add line breaks by inserting the escape character &quot;\n&quot; in your strings.
</li></ul>
</p>



<p>Skyboxes are a wrapper around your entire scene that display the vast beyond of your world.
</p>

<p><img class='figure' src='images/class-Skybox-0.jpg' />
</p>

<p><i>One of the default sky boxes found under Standard Assets/Skyboxes</i>
</p>

<h2>Properties</h2>
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Material</nobr></b></td><td> The Material used to render the skybox, which contains the 6 Skybox textures. This Material should use the Skybox shader, and each of the textures should be assigned to the proper global direction.
<p></td></tr></tr></table>
</p>

<h2>Details</h2>

<p>Skyboxes are rendered before anything else in the scene in order to give the impression of complex scenery at the horizon. They are a box of 6 textures, one for each primary direction (+/-X, +/-Y, +/-Z).
</p>

<h3> Per camera overridable skyboxes</h3>

<h3> Per scene skyboxes</h3>
<p>You have 2 options for implementing Skyboxes.  You can add them to an individual <a href="../Components/class-Camera.html">Camera</a> (usually the main Camera) or you can set up a default Skybox in <a href="../Components/class-RenderSettings.html">Render Settings's</a> <b>Skybox Material</b> property.  The Render Settings is most useful if you want all cameras in your scene to share the same Skybox.
</p>

<p>Adding the Skybox component to a Camera is useful if you want to override the default skybox set up in the Render Settings.  E.g. You might have two split screens and want the second camera to use a different skybox.  To add a Skybox component to a Camera, click to highlight the camera and go to <b>Component -&gt; Rendering -&gt; Skybox</b>.
</p>

<p>Unity's Standard Assets contain 6 pre setup Skybox materials. (Standard Assets/Skyboxes)
</p>

<p>If you want to create a new Skybox see <a href="../Manual/HOWTO-UseSkybox.html">here</a>.
</p>

<h2>Hints</h2>
<p><ul><li>
If you have a skybox assigned to a camera, make sure to set the camera's clear mode to Skybox</li><li>
You can modify fog in the RenderSettings
</li></ul>
</p>



<p>A GUI Layer component is attached to a camera to enable rendering of 2D GUIs.
</p>

<p>When a gui layer is attached to a camera it will simply render all gui elements in the scene.
</p>

<p>You can enable and disable rendering GUI in a single camera by clicking on the check box of the GUI Layer in the inspector.
</p>

<p>For more information about GUI elements see <a href="../Components/class-GuiTexture.html">GUI Texture</a> and <a href="../Components/class-GuiText.html">GUI Text</a>.
</p>



<p>The Flare Layer component can be attached to <a href="../Components/class-Camera.html"> cameras</a> to make <a href="../Components/class-LensFlare.html"> lens flares</a> appear in the image. By default cameras have a Flare Layer already attached.
</p>



<p>The Halo Layer can be attached to <a href="../Components/class-Camera.html"> cameras</a> to make <a href="../Components/class-Halo.html"> Halo</a> objects appear in the image. It has no properties of its own.
</p>



<p>This group handles all render-to-texture based fullscreen image postprocessing effects. They are only available with the <a class="wiki"  href="http://www.unity3d.com/shop">Pro Version of Unity</a>. They add a lot to the look and feel of your game. Especially glow can make your game look a lot better without spending much  time on artwork.
</p>

<p><ul class="toc"><li class="toclevel"><a href="../Components/script-GlowEffect.html">script-GlowEffect</a></li><li class="toclevel"><a href="../Components/script-BlurEffect.html">script-BlurEffect</a></li><li class="toclevel"><a href="../Components/script-NoiseEffect.html">script-NoiseEffect</a></li><li class="toclevel"><a href="../Components/script-ColorCorrectionEffect.html">script-ColorCorrectionEffect</a></li><li class="toclevel"><a href="../Components/script-EdgeDetectEffect.html">script-EdgeDetectEffect</a></li><li class="toclevel"><a href="../Components/script-GrayscaleEffect.html">script-GrayscaleEffect</a></li><li class="toclevel"><a href="../Components/script-TwirlEffect.html">script-TwirlEffect</a></li><li class="toclevel"><a href="../Components/script-MotionBlur.html">script-MotionBlur</a></li><li class="toclevel"><a href="../Components/script-VortexEffect.html">script-VortexEffect</a></li><li class="toclevel"><a href="../Components/script-SepiaToneEffect.html">script-SepiaToneEffect</a></li></ul>
</p>



<p>Glow (sometimes called <i>Bloom</i>) can dramatically enhance the rendered image by making overbright parts &quot;glow&quot; (e.g. sun, light sources, strong highlights).
</p>

<p>Unity includes a Glow image postprocessing effect, and all builtin shaders are made to support it nicely. As with all image effects, Glow is available in Unity Pro only. Make sure to have the <a href="../Manual/HOWTO-InstallStandardAssets.html">Pro Standard Assets installed</a>.
</p>

<p><img class='figure' src='images/script-GlowEffect-0.jpg' />
</p>

<p><i>Glow effect applied to the scene</i>
</p>

<h2>Details</h2>

<p>Glow uses the alpha channel of the final image to represent &quot;color brightness&quot;. All colors are treated as RGB, multiplied by the alpha channel. You can view the contents of the alpha channel in SceneView.
</p>

<p>All builtin shaders write the following information to alpha:
</p>
<ul><li> Main texture's alpha multiplied by main color's alpha (not affected by lighting).
</li><li> Specular and Glossy shaders add specular highlight multiplied by specular color's alpha.
</li><li> Alpha (translucent) shaders do not modify alpha channel at all.
</li><li> Particle shaders do not modify alpha channel, except for Particles/Multiply which darkens anything that is in alpha.
</li><li> Skybox shaders write alpha of the texture multiplied by tint alpha
</li></ul>

<p>Most of the time you'll want to do this to get reasonable glow:
</p>
<ul><li> Set material's main color alpha to zero <b>or</b> use a texture with zero alpha channel. In the latter case, you can put non-zero alpha in the texture to cause these parts to glow.
</li><li> Set the specular color alpha for Specular/Glossy shaders to be 100%.
</li><li> Keep in mind what alpha the camera clears to (if it clears to a solid color), or what alpha the skybox material uses.
</li><li> Add the Glow image effect to the camera. Tweak <i>Glow Intensity</i> and <i>Blur Iterations</i> values, you can also take a look at the comments in the shader script source.
</li><li> The alpha channel on the Skybox can be used to great effect to add more glow when looking at the sun
</li></ul>

<h2>Tips:</h2>
<ul><li> Use the alpha rendering mode in the scene view toolbar to quickly see which objects output different values to the alpha channel.
</li><li> You need to attach the image effect to the camera while edit mode. To see the effect you have to go into playmode afterwards.
</li></ul>


<p>Glow works on graphics cards with support for pixel shaders. Eg. GeForce FX 5200 or Radeon 8500 and up.
All image effects automatically disable themselves when they can not run on an end-users graphics card.
</p>



<p>Blur image effect blurs the rendered image in real-time.
</p>

<p>As with the other image effects, Blur is only available in Unity Pro. Make sure to have the <a href="../Manual/HOWTO-InstallStandardAssets.html">Pro Standard Assets installed</a>.
</p>

<p><img class='figure' src='images/script-BlurEffect-0.jpg' />
</p>

<p><i>Blur effect applied to the scene</i>
</p>

<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Iterations</nobr></b></td><td> The amount of blurriness desired. Higher iteration count makes the image more blurry, but each additional iteration has some performance cost.
</td></tr><tr><td><b><nobr> Blur Spread</nobr></b></td><td> Higher values will spread out the blur more at the same iteration count, but at some expense in quality. Usually values from 0.6 to 0.7 are a good compromise between quality and speed.
<p></td></tr></tr></table>
</p>

<h2>Tips:</h2>
<ul><li> You need to attach the image effect to the camera while edit mode. To see the effect you have to go into playmode afterwards.
</li></ul>


<p>Blur effect works only on graphics cards with support for pixel shaders. Eg. GeForce FX 5200 or Radeon 8500 and up.
All image effects automatically disable themselves when they can not run on an end-users graphics card.
</p>



<p>Unity has an image postprocessing effect that can simulate both TV and VCR noise.
</p>

<p>As with the other image effects, Noise is only available in Unity Pro. Make sure to have the <a href="../Manual/HOWTO-InstallStandardAssets.html">Pro Standard Assets installed</a>.
</p>

<p><img class='figure' src='images/script-NoiseEffect-0.jpg' />
</p>

<p><i>Noise effect with high intensity applied to the scene</i>
</p>

<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Monochrome</nobr></b></td><td> If set, noise is more similar to TV noise. If not set, it more resembles VCR noise - it distorts color values in YUV space, so you also get hue changes, mostly towards magenta/green gues.
</td></tr><tr><td><b><nobr> Grain Intensity Min/Max</nobr></b></td><td> The intensity of noise takes random values between <i>Min</i> and <i>Max</i>.
</td></tr><tr><td><b><nobr> Grain Size</nobr></b></td><td> The size of a single grain texture pixel in screen pixels. Increasing this will make noise grains larger.
</td></tr><tr><td><b><nobr> Scratch Intensity Min/Max</nobr></b></td><td> The intensity of additional scratch/dust takes random values between <i>Min</i> and <i>Max</i>.
</td></tr><tr><td><b><nobr> Scratch FPS</nobr></b></td><td> Scratches jump to different positions on the screen at this frames per second.
</td></tr><tr><td><b><nobr> Scratch Jitter</nobr></b></td><td> While being in the same position, scratches can still jitter a bit.
<p></td></tr></tr></table>
</p>

<h2>Tips:</h2>
<ul><li> You need to attach the image effect to the camera while edit mode. To see the effect you have to go into playmode afterwards.
</li></ul>

<p>Noise effect works only on graphics cards with support for pixel shaders (model 2.0). Eg. GeForce FX 5200 or Radeon 9500 and up.
All image effects automatically disable themselves when they can not run on an end-users graphics card.
</p>



<p>Color correction allows you apply arbitrary color correction to your scene as a postprocessing effect (just like the Curves tool in Photoshop or Gimp). This page explains how to setup color correction in Photoshop and then apply <i>exactly</i> the same color correction at runtime in Unity.
</p>

<p>Color Correction is only available in Pro version of Unity. Make sure to have the <a href="../Manual/HOWTO-InstallStandardAssets.html">Pro Standard Assets installed</a>.
</p>

<p><img class='figure' src='images/script-ColorCorrectionEffect-0.jpg' /> <img class='figure' src='images/script-ColorCorrectionEffect-1.jpg' />
</p>

<p><i>Color correction applied to the scene to get strongly posterized look. Color ramp used (magnified) is shown at the right.</i>
</p>

<h2>Getting color correction from Photoshop into Unity</h2>

<ol><li> Take a screenshot of a typical scene in your game
</li><li> Open it in Photoshop and color correct using the <i>Image-&gt;Adjustments-&gt;Curves</i>
</li><li> Save the <i>.acv</i> file file from the dialog using <i>Save...</i>
</li><li> Open <i>Pro Standard Assets/Image Based/color correction ramp.png</i> in Photoshop
</li><li> Now apply color correction to the ramp image: open <i>Image-&gt;Adjustments-&gt;Curves</i> again and load your saved <i>.acv</i> file
</li><li> Select your camera in Unity and select <i>Component-&gt;Image Effects-&gt;Color Correction</i> to add color correction effect. Select your modified color ramp.
</li><li> Hit Play to see the effect in action!
</li></ol>

<h2>Details</h2>

<p>Color correction works by remapping the original image colors through the color ramp image (sized 256x1):
</p>
<ol><li> result.red = pixel's red value in ramp image at (original.red + RampOffsetR) index
</li><li> result.green = pixel's green value in ramp image at (original.green + RampOffsetG) index
</li><li> result.blue = pixel's blue value in ramp image at (original.blue + RampOffsetB) index
</li></ol>
<p>So for example, to invert the colors in the image you only need to flip the original color ramp horizontally (so that it goes from white to black instead of from black to white).
</p>

<p>A simpler version of color remapping that only remaps based on luminance can be achieved with <a href="../Components/script-GrayscaleEffect.html">Grayscale</a> image effect.
</p>

<h2>Tips:</h2>
<ul><li> You need to attach the image effect to the camera while edit mode. To see the effect you have to go into playmode afterwards.
</li></ul>

<p>Color correction works only on graphics cards with support for pixel shaders (2.0). E.g. GeForce FX 5200 or Radeon 9500 and up.
All image effects automatically disable themselves when they can not run on an end-users graphics card.
</p>



<p>Edge Detect image effect adds black edges to the image where color differences exceed some threshold.
</p>

<p>As with all image effects, they are available in Unity Pro only. Make sure to have the <a href="../Manual/HOWTO-InstallStandardAssets.html">Pro Standard Assets installed</a>.
</p>

<p><img class='figure' src='images/script-EdgeDetectEffect-0.jpg' />
</p>

<p><i>Edge Detect image effect applied to the scene</i>
</p>

<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Threshold</nobr></b></td><td> Edges will be displayed whenever color difference in neighboring pixels exceeds this amount. Increase this value to make edges less sensitive to texture or lighting changes.
<p></td></tr></tr></table>
</p>

<h2>Tips:</h2>
<ul><li> You need to attach the image effect to the camera while edit mode. To see the effect you have to go into playmode afterwards.
</li></ul>

<p>Edge Detect works on graphics cards with support for pixel shaders (2.0). E.g. GeForce FX 5200 or Radeon 9500 and up.
All image effects automatically disable themselves when they can not run on an end-users graphics card.
</p>



<p>Grayscale is a simple image effect that changes colors to grayscale by default. It can also use color ramp texture to remap luminance to arbitrary colors.
</p>

<p>As with all image effects, it is available in Unity Pro only. Make sure to have the <a href="../Manual/HOWTO-InstallStandardAssets.html">Pro Standard Assets installed</a>.
</p>

<p><img class='figure' src='images/script-GrayscaleEffect-0.jpg' />
</p>

<p><i>Grayscale image effect applied to the scene</i>
</p>

<h2>Remapping colors</h2>

<p>Grayscale can do a simple version of color correction, i.e. remap grayscale image into arbitrary colors. This can be used for effects like heat vision.
</p>

<p>The process of color remapping is very similar to <a href="../Components/script-ColorCorrectionEffect.html">ColorCorrection</a> effect:
</p>
<ol><li> Take a screenshot of a typical scene in your game.
</li><li> Open it in Photoshop and convert to grayscale.
</li><li> Color correct it using the <i>Image-&gt;Adjustments-&gt;Curves</i>.
</li><li> Save the <i>.acv</i> file file from the dialog using <i>Save...</i>
</li><li> Open <i>Pro Standard Assets/Image Based/color correction ramp.png</i> in Photoshop
</li><li> Now apply color correction to the ramp image: open <i>Image-&gt;Adjustments-&gt;Curves</i> again and load your saved <i>.acv</i> file
</li><li> Select your camera in Unity and select <i>Component-&gt;Image Effects-&gt;Grayscale</i> to add the effect. Select your modified color ramp.
</li><li> Hit Play to see the effect in action!
</li></ol>

<h3>Details</h3>

<p>Color remapping works by remapping the original image luminance through the color ramp image (sized 256x1):
</p>
<ul><li> result color = pixel's color in the ramp image at (OriginalLuminance + RampOffset) index
</li></ul>
<p>So for example, to invert the colors in the image you only need to flip the original color ramp horizontally (so that it goes from white to black instead of from black to white).
</p>

<p>A more complex version of color remapping that does arbitrary color correction can be achieved with <a href="../Components/script-ColorCorrectionEffect.html">ColorCorrection</a> image effect.
</p>

<h2>Tips:</h2>
<ul><li> You need to attach the image effect to the camera while edit mode. To see the effect you have to go into playmode afterwards.
</li></ul>

<p>Grayscale works on graphics cards with support for pixel shaders (2.0). E.g. GeForce FX 5200 or Radeon 9500 and up.
All image effects automatically disable themselves when they can not run on an end-users graphics card.
</p>




<p>Twirl image effect distorts the rendered image. Similar to <a href="../Components/script-VortexEffect.html">Vortex</a>, it distorts the image in a circular region.
</p>

<p>As with all image effects, it is available in Unity Pro only. Make sure to have the <a href="../Manual/HOWTO-InstallStandardAssets.html">Pro Standard Assets installed</a>.
</p>

<p><img class='figure' src='images/script-TwirlEffect-0.jpg' />
</p>

<p><i>Twirl image effect applied to the scene</i>
</p>

<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Radius</nobr></b></td><td> The radius of the circle where image distortion takes place. Radius of 0.5 is half the height of the screen (so the circle's diameter is whole screen in height).
</td></tr><tr><td><b><nobr> Angle</nobr></b></td><td> Controls the amount of distortion applied.
</td></tr><tr><td><b><nobr> Center</nobr></b></td><td> X/Y position the distortion area on the screen, Z is ignored.
<p></td></tr></tr></table>
</p>

<h2>Tips:</h2>
<ul><li> You need to attach the image effect to the camera while edit mode. To see the effect you have to go into playmode afterwards.
</li></ul>

<p>Twirl works on graphics cards with support for pixel shaders (2.0). E.g. GeForce FX 5200 or Radeon 9500 and up.
All image effects automatically disable themselves when they can not run on an end-users graphics card.
</p>



<p>Motion Blur image effect enhances fast-moving scenes by leaving &quot;motion trails&quot; of previously rendered frames.
</p>

<p>As with the other image effects, Motion Blur is only available in Unity Pro. Make sure to have the <a href="../Manual/HOWTO-InstallStandardAssets.html">Pro Standard Assets installed</a>.
</p>

<p><img class='figure' src='images/script-MotionBlur-0.jpg' />
</p>

<p><i>Motion Blur effect applied to the rotating scene</i>
</p>

<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Blur Amount</nobr></b></td><td> How much of the previous frames to leave in the image. Higher values make longer motion trails.
</td></tr><tr><td><b><nobr>Extra Blur</nobr></b></td><td> If checked, this makes motion trails more blurry, by applying some extra blur to previous frames.
<p></td></tr></tr></table>
</p>

<h2>Tips:</h2>
<ul><li> You need to attach the image effect to the camera while edit mode. To see the effect you have to go into playmode afterwards.
</li></ul>

<p>Motion Blur effect works all graphics cards that support rendering to a texture. E.g. GeForce2, Radeon 7000 and up.
All image effects automatically disable themselves when they can not run on an end-users graphics card.
</p>



<p>Vortex image effect distorts the rendered image. Similar to <a href="../Components/script-TwirlEffect.html">Twirl</a>, it distorts the image in a circular region.
</p>

<p>As with all image effects, it is available in Unity Pro only. Make sure to have the <a href="../Manual/HOWTO-InstallStandardAssets.html">Pro Standard Assets installed</a>.
</p>

<p><img class='figure' src='images/script-VortexEffect-0.jpg' />
</p>

<p><i>Vortex image effect applied to the scene</i>
</p>

<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Radius</nobr></b></td><td> The radius of the circle where image distortion takes place. Radius of 0.5 is half the height of the screen (so the circle's diameter is whole screen in height).
</td></tr><tr><td><b><nobr> Angle</nobr></b></td><td> Controls the amount of distortion applied.
</td></tr><tr><td><b><nobr> Center</nobr></b></td><td> X/Y position the distortion area on the screen, Z is ignored.
<p></td></tr></tr></table>
</p>

<h2>Tips:</h2>
<ul><li> You need to attach the image effect to the camera while edit mode. To see the effect you have to go into playmode afterwards.
</li></ul>

<p>Vortex works on graphics cards with support for pixel shaders (2.0). E.g. GeForce FX 5200 or Radeon 9500 and up.
All image effects automatically disable themselves when they can not run on an end-users graphics card.
</p>



<p>Sepia Tone is a simple image effects that changes image colors.
</p>

<p>As with all image effects, it is available in Unity Pro only. Make sure to have the <a href="../Manual/HOWTO-InstallStandardAssets.html">Pro Standard Assets installed</a>.
</p>

<p><img class='figure' src='images/script-SepiaToneEffect-0.jpg' />
</p>

<p><i>Sepia Tone image effect applied to the scene</i>
</p>

<h2>Tips:</h2>
<ul><li> You need to attach the image effect to the camera while edit mode. To see the effect you have to go into playmode afterwards.
</li></ul>

<p>Sepia Tone works on graphics cards with support for pixel shaders (2.0). E.g. GeForce FX 5200 or Radeon 9500 and up.
All image effects automatically disable themselves when they can not run on an end-users graphics card.
</p>



<p>Unity has a simple wizard that let's you create your own ragdoll in no time. You simply have to drag the different limbs on the respective properties in the wizard. Then select create and Unity will automatically generate all colliders, rigidbodies and joints that make up the Ragdoll for you.
</p>





<p><ul class="toc"><li class="toclevel"><a href="../Components/class-Animation.html">Animation</a></li><li class="toclevel"><a href="../Components/class-AnimationClip.html">AnimationClip</a></li></ul>
</p>



<p><img class='figure' src='images/class-Animation-0.jpg' />
</p>

<p><i>The Animation inspector</i>
</p>

<h2>Properties</h2>
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Animation</nobr></b></td><td> The default animation that will be played when Play Automatically is enabled.
</td></tr><tr><td><b><nobr>Animations</nobr></b></td><td> A list of animations that can be accessed from scripts
</td></tr><tr><td><b><nobr>Wrap Mode</nobr></b></td><td> How are animations played, <b>Looping</b>, <b>Once</b>, <b>PingPong</b>, <b>Default</b>
</td></tr><tr><td><b><nobr>Play Automatically</nobr></b></td><td> Should the animation be played automatically when starting the game?
</td></tr><tr><td><b><nobr>Play Fixed Frame Rate</nobr></b></td><td> Should the animation playback at fixed frame rate. This is useful for animations interacting with physics.
<p></td></tr></tr></table>
</p>

<p>See the <a href="../Manual/Character-Animation.html">Character Animation page</a> on how to import and animate characters.
See the <a href="../Manual/Animation.html"> Animation page</a> on how to create simple keyframe animations inside of Unity.
</p>



<p><img class='figure' src='images/class-AnimationClip-0.jpg' />
</p>

<p><i>An imported animation selected in the project view</i>
</p>

<p>Animation clips store all animation data that can be used for animated characters or simple animations.
</p>

<p>They contain only one property which can not be modified. The sample rate. This is the sample rate at which the clip was created. Note that Unity performs keyframe reduction when importing animations, thus this is not the number of keys.
</p>





<p><ul class="toc"><li class="toclevel"><a href="../Components/class-AudioManager.html">AudioManager</a></li><li class="toclevel"><a href="../Components/class-TagManager.html">TagManager</a></li><li class="toclevel"><a href="../Components/class-TimeManager.html">TimeManager</a></li><li class="toclevel"><a href="../Components/class-InputManager.html">InputManager</a></li><li class="toclevel"><a href="../Components/class-PhysicsManager.html">PhysicsManager</a></li><li class="toclevel"><a href="../Components/class-QualitySettings.html">QualitySettings</a></li><li class="toclevel"><a href="../Components/class-PlayerSettings.html">PlayerSettings</a></li><li class="toclevel"><a href="../Components/class-RenderSettings.html">RenderSettings</a></li></ul>
</p>



<p>The Audio manager allows you to tweak the maximum volume of all sounds playing in the scene.
To see it choose <b>Edit -&gt; Project Settings -&gt; Audio</b>.
</p>

<p><img class='figure' src='images/class-AudioManager-0.jpg' />
</p>

<p><i>The Audio Manager</i>
</p>

<h2>Properties</h2>
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Volume</nobr></b></td><td> The volume of all sounds playing
<p></td></tr></tr></table>
</p>

<h2>Details</h2>

<p>Currently Doppler Velocity and Doppler Factor do not have any effect on ppc osx machines. This will be fixed in a future version of Unity.
</p>



<p>The Tag manager allows you to set up Layers and Tags.
To see it choose <b>Edit -&gt; Project Settings -&gt; Tags</b>.
</p>

<p><img class='figure' src='images/class-TagManager-0.jpg' />
</p>

<p><i>The Tag Manager</i>
</p>

<h2>Properties</h2>
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Tags</nobr></b></td><td> You can add new elements by typing in the last element</td></tr><tr><td><b><nobr>
User Layer</nobr></b></td><td> You can add custom named User Layers
<p></td></tr></tr></table>
</p>

<h2>Details</h2>

<p><b>Layers</b> can be used to cast rays, render, or apply lighting to certain groups of objects only. You can choose the layer in the <a href="../Components/class-GameObject.html">game object inspector</a>. More information about how to use layers can be found <a href="../ScriptingConcepts/Layers.html">here</a>.
</p>


<p><b>Tags</b> are used to quickly find objects from scripts, utilizing the Tag name.
When a new tag is added, you can choose it from the <a href="../Components/class-GameObject.html">game object</a> tag popup.
</p>





<p><img class='figure' src='images/class-TimeManager-0.jpg' />
</p>

<p><i>The Time Manager</i>
</p>

<h2>Properties</h2>
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Fixed Timestep</nobr></b></td><td> A framerate-independent interval that dictates when physics calculations and scripted fixed updates are performed.
</td></tr><tr><td><b><nobr>Time Scale</nobr></b></td><td> The speed at which time progress. Change this value to simulate bullet-time effects. A value of 1 means real-time. A value of .5 means half speed; a value of 2 is double speed.
<p></td></tr></tr></table>
</p>

<h2>Details</h2>

<h3>Fixed Timestep</h3>
<p>Fixed time stepping is very important for stable physics simulation. Not all computers are made equal, and different hardware configurations will run Unity games with varying performance.  Therefore, physics must be calculated independently of the game's frame rate.  Physics calculations like collision detection and rigidbody movement are performed in discrete fixed time steps that are not dependent on frame rate. This makes the simulation more consistent across different computers or when changes in the frame rate occur. For example, the frame rate can drop due to an appearance of many game onscreen, or because the user launched another application in the background.
</p>

<p>Here's how the fixed time step is calculated.  Before every frame is drawn onscreen, Unity advances the fixed time by fixed delta time and performs physics calculations until it reaches the current time.  This directly correlates to the <b>Fixed Timestep</b> property.  The smaller the value of <b>Fixed Timestep</b>, the more frequently physics will be calculated.  The number of Fixed frames per second can be calculated by dividing 1 by <b>Fixed Timestep</b>.  Therefore, 1 / 0.02 = 50 fixed frames per second and 1 / 0.05 = 20 fixed frames per second.
</p>

<p>Simply put, a smaller fixed update value leads to more accurate physics simulation but is heavier on the CPU.
</p>

<h2>Hints</h2>
<p><ul><li>
Give the player control over time by changing <b>Time Scale</b> dynamically through scripting.
</li></ul>
</p>




<p>The Input Manager is where you define all the different input axes and game actions for your project.
</p>

<p><img class='figure' src='images/class-InputManager-0.jpg' />
</p>

<p><i>The Input Manager Inspector</i>
</p>

<p>To see the Input Manager choose: <b>Edit -&gt; Project Settings -&gt; Input</b>
</p>

<h2>Properties</h2>
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Axes</nobr></b></td><td> Contains all the defined input axes for the current project.
</td></tr><tr><td><b><nobr>    Size</nobr></b></td><td> the number of different input axes in this project.
</td></tr><tr><td><b><nobr>    Element 0, 1, ...</nobr></b></td><td> The particular axis you are currently modifying.
</td></tr><tr><td><b><nobr>        Name</nobr></b></td><td> The string that refers to the axis in the game launcher and through scripting.
</td></tr><tr><td><b><nobr>        Descriptive Name</nobr></b></td><td> A detailed definition of the <b>Positive Button</b> function that is displayed in the game launcher.
</td></tr><tr><td><b><nobr>        Descriptive Negative Name</nobr></b></td><td> A detailed definition of the <b>Negative Button</b> function that is displayed in the game launcher.
</td></tr><tr><td><b><nobr>        Negative Button</nobr></b></td><td> The button that will send a negative value to the axis.
</td></tr><tr><td><b><nobr>        Positive Button</nobr></b></td><td> The button that will send a positive value to the axis.
</td></tr><tr><td><b><nobr>        Alt Negative Button</nobr></b></td><td> The secondary button that will send a negative value to the axis.
</td></tr><tr><td><b><nobr>        Alt Positive Button</nobr></b></td><td> The secondary button that will send a positive value to the axis.
</td></tr><tr><td><b><nobr>        Gravity</nobr></b></td><td> How fast will the input recenter. Only used when the type is <i>key / mouse button</i>
</td></tr><tr><td><b><nobr>        Dead</nobr></b></td><td> Any positive or negative values that are less than this number will register as zero.  Useful for joysticks.
</td></tr><tr><td><b><nobr>        Sensitivity</nobr></b></td><td> For keyboard input, a larger value will result in faster response time. A lower value will be more smooth. For Mouse delta the value will scale the actual mouse delta.
</td></tr><tr><td><b><nobr>        Snap</nobr></b></td><td> If enabled, the axis value will be immediately reset to zero after it receives opposite inputs. Only used when the type is <i>key / mouse button</i>
</td></tr><tr><td><b><nobr>        Invert</nobr></b></td><td> If enabled, the positive buttons will send negative values to the axis, and vice versa.
</td></tr><tr><td><b><nobr>        Type</nobr></b></td><td> Use Key / Mouse Button for any kind of buttons, Mouse Movement for mouse delta and scrollwheels, Joystick axis for analog joystick axes and Window movement for when the user shakes the window.
</td></tr><tr><td><b><nobr>        Axis</nobr></b></td><td> Axis of input from the device (joystick, mouse, gamepad, etc.)
</td></tr><tr><td><b><nobr>        Joy Num</nobr></b></td><td> Which joystick should be used. By default this is set to retrieve the input from all joysticks. This is only used for input axes and not buttons.
<p></td></tr></tr></table>
</p>

<h2>Details</h2>

<p>All the axes that you set up in the Input Manager serve two purposes:
</p>
<ul><li>They allow you to reference your inputs by axis name in scripting
</li><li>They allow the players of your game to customize the controls to their liking
</li></ul>

<p>All defined axes will be presented to the player in the game launcher, where they will see its name, detailed description, and default buttons.  From here, they will have the option to change any of the buttons defined in the axes.  Therefore, it is best to write your scripts making use of axes instead of individual buttons, as the player may want to customize the buttons for your game.
</p>

<p><img class='figure' src='images/class-InputManager-1.jpg' />
</p>

<p><i>The game launcher input window that is displayed when your built game is run</i>
</p>

<p>See also: <a href="../Manual/Input.html">Input</a>
</p>

<h2>Hints</h2>
<p><ul><li>
Axes are not the best place to define &quot;hidden&quot; or secret functions, as they will be displayed very clearly to the player in the game launcher.
</li></ul>
</p>



<p>You can access the Physics Manager by selecting <b>Edit -&gt; Project Settings -&gt; Physics</b>.
</p>

<p><img class='figure' src='images/class-PhysicsManager-0.jpg' />
</p>

<p><i>The Physics Manager</i>
</p>

<h2>Properties</h2>
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Gravity</nobr></b></td><td> The amount of gravity applied to all Rigidbodies. Usually gravity acts only on the Y-axis (negative is down). Gravity is m/s^2.
</td></tr><tr><td><b><nobr>Default Material</nobr></b></td><td> The default Physic Material that will be used if none has been assigned to an individual Collider.
</td></tr><tr><td><b><nobr>Bounce Threshold</nobr></b></td><td> Two colliding objects with a relative velocity below this value will not bounce. This value also reduces jitter so it is not recommended to set it to a very low value.
</td></tr><tr><td><b><nobr>Sleep Velocity</nobr></b></td><td> The default linear velocity, below which objects start going to sleep.
</td></tr><tr><td><b><nobr>Sleep Angular Velocity</nobr></b></td><td> The default angular (rotating) velocity, below which objects start going to sleep.
</td></tr><tr><td><b><nobr>Max Angular Velocity</nobr></b></td><td> The default maximimum angular velocity permitted for any Rigidbodies. The angular velocity of rigidbodies is clamped to <b>Max Angular Velocity</b> to avoid numerical instability with quickly rotating bodies. Because this may prevent intentional fast rotations on objects such as wheels, you can override this value for any Rigidbody by scripting Rigidbody.maxAngularVelocity.
</td></tr><tr><td><b><nobr>Min Penetration For Penalty</nobr></b></td><td> How deep in meters are two objects allowed to penetrate before the collision solver pushes them apart. A higher value will make objects penetrate more but reduces jitter.
</td></tr><tr><td><b><nobr>Solver Iteration Count</nobr></b></td><td> Determines how accurately joints and contacts are resolved. Usually a value of 7 works very well for almost all situations.
<p></td></tr></tr></table>
</p>

<h2>Details</h2>
<p>The Physics Manager is where you define the default behaviors of your world.
</p>

<p>For an explanation of Rigidbody Sleeping, read this page about <a href="../ScriptingConcepts/RigidbodySleeping.html">sleeping</a>.
</p>

<h2>Hints</h2>
<p><ul><li>
If you are having trouble with connected bodies oscillating and behaving eratically, setting a higher <b>Solver Iteration Count</b> may improve their stability, but will require more processing power.
</li></ul>
</p>



<p><img class='figure' src='images/class-QualitySettings-0.jpg' />
</p>

<p><i>The Quality Settings</i>
</p>

<p>You can tune Quality Settings by choosing <b>Edit -&gt; Project Settings -&gt; Quality</b>.
</p>

<h2>Properties</h2>
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Default Standalone Quality</nobr></b></td><td> Default quality setting used for standalone players.
</td></tr><tr><td><b><nobr>Default Web Player Quality</nobr></b></td><td> Default quality setting used for web players.
</td></tr><tr><td><b><nobr>Editor Quality</nobr></b></td><td> The current quality setting used in the editor for previewing.
</td></tr><tr><td><b><nobr>Fastest, Fast, Simple, ...</nobr></b></td><td> The quality setting details for different global quality settings</td></tr><tr><td><b><nobr>        Pixel Light Count</nobr></b></td><td> The maximum number of pixel light counts used. If there are more lights affecting an object, the light will automatically be represented as a vertex light.
</td></tr><tr><td><b><nobr>        Blend Weights</nobr></b></td><td> How many blend weights should Unity use on a skinned mesh. 2 Bones is usually a very good tradeoff between speed and quality.
</td></tr><tr><td><b><nobr>        Texture Quality</nobr></b></td><td> Should Unity decrease the resolution of all textures.
</td></tr><tr><td><b><nobr>        Anisotropic Textures</nobr></b></td><td> Anisotropic filtering increases texture quality when viewing the texture at a steep angle, but incurs a performance cost. You can modify Anisotropic filter level per texture, see <a href="../Components/class-Texture2D.html">Texture2D</a>.
</td></tr><tr><td><b><nobr>        Anti Aliasing</nobr></b></td><td> Should anti-aliasing be used. This removes blocky edges but incurs a performance cost.
</td></tr><tr><td><b><nobr>        Sync To VBL</nobr></b></td><td> Synchronize to screen refresh rate. This will slow down the game but avoid any tearing artifacts.
<p></td></tr></tr></table>
</p>

<p>You can adjust each of the 6 quality settings individually to fit your game.
The end-user can then choose the Quality Setting in the Screen Selector of the standalone player; or you can access and modify it from <a class="wiki"  href="../ScriptReference/QualitySettings.html">scripting</a>.
</p>

<p>The Quality Settings are by default initialized to some good values that work across a wide range of games.
</p>

<p>Note that Anti Aliasing and Sync To VBL currently do not live update when inside of the editor. You have to restart the editor or player to see the effect. This will be addressed in the future.
</p>



<p>Player Settings is where you define various parameters for the final game that you will build in Unity.
</p>

<p><img class='figure' src='images/class-PlayerSettings-0.jpg' />
</p>

<p><i>The Player Settings</i>
</p>

<p>To see the Player Settings choose <b>Edit -&gt; Project Settings -&gt; Player</b>
</p>

<h2>Properties</h2>
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Company Name</nobr></b></td><td> The name of your company. This is used to locate the preferences file.
</td></tr><tr><td><b><nobr>Product Name</nobr></b></td><td> The name that will appear on the menu bar when your game is running and is used to locate the preferences file.
</td></tr><tr><td><b><nobr>Default Screen Width</nobr></b></td><td> Default horizontal dimension of stand-alone player window.
</td></tr><tr><td><b><nobr>Default Screen Height</nobr></b></td><td> Default vertical dimension of stand-alone player window.
</td></tr><tr><td><b><nobr>Default Web Screen Width</nobr></b></td><td> Default horizontal dimension of web player window.
</td></tr><tr><td><b><nobr>Default Web Screen Height</nobr></b></td><td> Default vertical dimension of web player window.
</td></tr><tr><td><b><nobr>Default Is Full Screen</nobr></b></td><td> If enabled, the &quot;Windowed&quot; checkbox on the Resolution Dialog will be disabled by default.
</td></tr><tr><td><b><nobr>Display Resolution Dialog</nobr></b></td><td> If enabled, the Resolution Dialog will appear when the game is launched.
</td></tr><tr><td><b><nobr>Use Alpha in Dashboard</nobr></b></td><td> Enabling this will use the alpha channel rendered in Unity for the transparency of the OSX Dashboard Widget. This allows you to make a dashboard widget with the shape of a mesh for example.
</td></tr><tr><td><b><nobr>Run in Background</nobr></b></td><td> If enabled, your game will continue to run if the user gives focus to another application.
</td></tr><tr><td><b><nobr>Resolution Dialog Banner</nobr></b></td><td> Reference to the image you would like to display in the Resolution Dialog window.
</td></tr><tr><td><b><nobr>Always Display Watermark</nobr></b></td><td> If enabled, the Unity watermark will always be displayed in the lower-right hand corner of your game window.
<p></td></tr></tr></table>
</p>

<h2>Details</h2>

<p>The Player Settings window is where many technical preference defaults are set. See also <a href="../Components/class-QualitySettings.html">Quality Settings</a> where the different graphics quality levels can be set up.
</p>

<h3>Publishing a web player</h3>

<p><b>Default Web Screen Width</b> and <b>Default Web Screen Height</b> determine the size used in the html file. Of course you can modify the size in the html file later.
</p>

<p><b>Default Screen Width</b> and <b>Default Screen Height</b> are used by the web player when entering fullscreen mode through the context menu in the web player view.
</p>

<h3>Customizing your Resolution Dialog</h3>

<p><img class='figure' src='images/class-PlayerSettings-1.jpg' />
</p>

<p><i>The resolution / input selector presented to end-users</i>
</p>

<p>You have the option of adding a custom banner image to the Screen Resolution Dialog in the Standalone Player. The maximum image size is 432 x 163 pixels. The image will not be scaled up to fit the screen selector. Instead it will be centered and cropped.
</p>



<p>The Render Settings contain default values for a range of visual elements in your scene, like Lights and Skyboxes.
</p>

<p><img class='figure' src='images/class-RenderSettings-0.jpg' />
</p>

<p><i>The Render Settings</i>
</p>

<p>To see the Player Settings choose:
<b>Edit -&gt; Render Settings</b>
</p>

<h2>Properties</h2>
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Fog</nobr></b></td><td> If enabled, fog will be drawn throughout your scene.
</td></tr><tr><td><b><nobr>Fog Color</nobr></b></td><td> Color of the <b>Fog</b>.
</td></tr><tr><td><b><nobr>Fog Density</nobr></b></td><td> Density of the <b>Fog</b>.
</td></tr><tr><td><b><nobr>Ambient</nobr></b></td><td> Color of the scene's ambient light.
</td></tr><tr><td><b><nobr>Skybox Material</nobr></b></td><td> Default skybox that will be rendered if no cameras have a skybox attached.
</td></tr><tr><td><b><nobr>Halo Strength</nobr></b></td><td> Size of all light halos in relation to their <b>Range</b>.
</td></tr><tr><td><b><nobr>Flare Strength</nobr></b></td><td> Intensity of all flares in the scene.
</td></tr><tr><td><b><nobr>Halo Texture</nobr></b></td><td> Reference to a Texture2D that will appear as the glow for all Halos in lights.
</td></tr><tr><td><b><nobr>Specular Texture</nobr></b></td><td> Reference to a Cube map that defines how specular highlights are drawn. If null the specular lookup is used.
</td></tr><tr><td><b><nobr>Spot Cookie</nobr></b></td><td> Reference to a Texture2D that will appear as the cookie mask for all Spot lights.
<p></td></tr></tr></table>
</p>

<h2>Details</h2>

<p>The Render Settings is used to define some common visual aspects of all the scenes in your project.  It can be a great help if your entire game takes place outdoors.  You can assign a single <b>Skybox Material</b> in the Render Settings, and then you don't have to worry about setting any Skyboxes on your individual scene cameras.
</p>

<p>Likewise, if you want common rendering properties across all scenes except one or two properties of a particular scene, you can override those properties by changing the settings of the individual element.  <b>Fog</b> and <b>Ambient</b> properties are specific to the open scene, and do not apply to the whole project.
</p>

<h3>Fog</h3>

<p>Enabling <b>Fog</b> will give a misty haze to your scene.  This both increases performance on lower-end machines and adds ambience.  You can adjust the look and color of the Fog with <b>Fog Density</b> and <b>Fog Color</b>, respectively.
</p>

<p>Adding fog is often used to optimize performance by making sure that far away objects fade out and are not drawn.  Please note that enabling fog is not enough to enable this performance optimization. To do that you also need to adjust your <a href="../Components/class-Camera.html">Camera's</a> <b>Far Clip Plane</b>. So that geometry far away will not be drawn. It is best to tweak the fog to look correct first. Then make the <a href="../Components/class-Camera.html">Camera's</a> far clip plane smaller until you see the geometry being clipped away before the fog fades it out.
</p>

<p><img class='figure' src='images/class-RenderSettings-1.jpg' />
</p>

<p><i>Fog is enabled in this scene from Forest Johnson's Racing Game</i>
</p>

<h2>Hints</h2>
<ul><li> Don't under-estimate the visual impact your game can make by thoughtfully tweaking the Render Settings!
</li><li> Render settings are per-scene: each scene in your game can have different render settings.
</li></ul>




<p>Assets are the models, textures, sounds and all other &quot;content&quot; files from which you make your game.
</p>

<p>This section describes Components for all asset types. For a general overview of assets, see <a href="../Manual/Working with Assets.html"> Assets overview page</a>.
</p>

<p><ul class="toc"><li class="toclevel"><a href="../Components/class-Texture2D.html">Texture2D</a></li><li class="toclevel"><a href="../Components/class-Mesh.html">Mesh</a></li><li class="toclevel"><a href="../Components/class-AudioClip.html">AudioClip</a></li><li class="toclevel"><a href="../Components/class-Font.html">Font</a></li><li class="toclevel"><a href="../Components/class-Flare.html">Flare</a></li><li class="toclevel"><a href="../Components/class-RenderTexture.html">RenderTexture</a></li><li class="toclevel"><a href="../Components/class-Material.html">Material</a></li><li class="toclevel"><a href="../Components/class-CubemapTexture.html">CubemapTexture</a></li></ul>
</p>


<p>Textures bring your meshes, particles, and interfaces to life! They are image or movie files that you lay over or wrap around your objects. As they are so important, they have a lot of properties. If reading this for the first time, jump down to <i>Details</i>, and return to the actual settings when you need a reference.
</p>

<p>Which shaders you use for your objects put specific requirements on your textures, but the basic principle is that you can put any image file inside your project. If it meets the size requirements (specified below), it will get imported and optimized for game use.
</p>

<p>This extends to multi-layer Photoshop or TIFF files - they are flattened on import, so there is no size penalty for your game.
</p>

<h2>Properties</h2>
<p>The texture inspector looks a bit different from most others:
</p>

<p><img class='figure' src='images/class-Texture2D-0.jpg' />
</p>

<p>The top section contains a few settings, and the bottom part contains a texture preview. The changes you make to the bottom part only affect the display, and not the texture itself.
</p>

<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Filtering Mode</nobr></b></td><td> Selects how the texture is filtered when it gets stretched by 3D transformations.

<dl><dt>No Filtering</dt><dd> The texture becomes blocky up close</dd><dt>Bilinear</dt><dd> The texture becomes blurry up close</dd><dt>Trilinear</dt><dd> Like Bilinear, but the texture also blurs between the different mip levels...</dd></dl>

</td></tr><tr><td><b><nobr>Anisotropy</nobr></b></td><td>   Increases texture quality when viewing the texture at a steep angle. Good for floor textures
</td></tr><tr><td><b><nobr>Edge mode</nobr></b></td><td> Selects how the texture behaves when tiled
<dl><dt>Repeat</dt><dd> The texture repeats (tiles) itself.</dd><dt>Clamp</dt><dd>  The texture's edges get stretched. </dd></dl>

<p></td></tr></tr></table>
</p>

<h2>Import Settings</h2>

<p>Textures all come from image files in your project folder. How they are imported is specified by the texture's import settings. You change these by selecting the file texture in the project window and clicking the import settings button on the toolbar above:
</p>

<p><img class='figure' src='images/class-Texture2D-1.jpg' />
</p>

<p>This brings up the import settings dialog:
</p>

<p><img class='figure' src='images/class-Texture2D-2.jpg' />
</p>

<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Max. Texture Size</nobr></b></td><td> The maximum imported texture size. A lot of artists prefer to work with huge textures - scale the texture down to a suitable size with this.
</td></tr><tr><td><b><nobr>Texture Format</nobr></b></td><td> What internal representation is used for the texture. This is a tradeoff between size and quality. In the examples below we show the final size of a in-game texture of 256 by 256 pixels.

<dl><dt>RGB Compressed DXT1</dt><dd> Compressed RGB texture. This is the most common format for diffuse textures. 4 bits per pixel (32 KB for a 256x256 texture).</dd><dt>RGBA Compressed DXT3</dt><dd> Compressed RGBA texture. Provides a different compression method for alpha. Usually DXT5 looks better. 1 byte/pixel (64 KB for a 256x256 texture).</dd><dt>RGBA Compressed DXT5</dt><dd> Compressed RGBA texture. This is the main format used for diffuse &amp; specular control textures. 1 byte/pixel (64 KB for a 256x256 texture).</dd><dt>RGB 16 bit</dt><dd> 65 thousand colors with no alpha. Compressed DXT formats use less memory and usually look better. 128 KB for a 256x256 texture.</dd><dt>RGB 24 bit</dt><dd> Truecolor but without alpha. 192 KB for a 256x256 texture.</dd><dt>Alpha 8 bit</dt><dd> High quality alpha channel but without any color. 64 KB for a 256x256 texture.</dd><dt>RGBA 16 bit</dt><dd> Low-quality truecolor. Has 16 levels of red, green, blue and alpha. Compressed DXT3/5 formats use less memory and usually look better. 128 KB for a 256x256 texture.</dd><dt>RGBA 32 bit</dt><dd> Truecolor with alpha - this is the highest quality. At 256 KB for a 256x256 texture, this one is expensive. Most of the time, <b>DXT5</b> offers sufficient quality at a much smaller size. The main place this is used is for bump maps, as DXT compression there often carries a visible quality loss.</dd></dl>
</td></tr><tr><td><b><nobr>Build Alpha From Grayscale</nobr></b></td><td> If enabled, an alpha transparency channel will be generated by the image's existing values of light &amp; dark.
</td></tr><tr><td><b><nobr>Scale NonPower2 Sizes Up</nobr></b></td><td> If enabled on textures that have non-power-of-two sizes, this will scale texture up to the nearest power-of-two size at import time. For more info see Texture Sizes section below.
</td></tr><tr><td><b><nobr>Generate Cube Map</nobr></b></td><td> Generates a cubemap from the texture using different generation methods.
</td></tr><tr><td><b><nobr>Generate Mip Maps</nobr></b></td><td> Select this to enable mip-map generation. Mip maps are smaller versions of the texture that gets used when the texture is very small on screen. For more info, see Mip Maps, below.
</td></tr><tr><td><b><nobr>Correct Gamma</nobr></b></td><td> Select this to enable per-mip-level gamma correction.
</td></tr><tr><td><b><nobr>Border Mip Maps</nobr></b></td><td> Select this to avoid colors seeping out to the edge of the lower Mip levels. Used for light cookies (see below).
</td></tr><tr><td><b><nobr>Mip Map Filtering</nobr></b></td><td> 3 ways of mip map filtering is available to optimize image quality
<dl><dt>Box</dt><dd> The simplest way to fade out the mipmaps - the mip levels become smoother and smoother as they go down in size.</dd><dt>Kaiser</dt><dd> A sharpening Kaiser algorithm is run on the mip maps as they go down in size.</dd></dl>
By default, Box mode is selected. If your textures are to blurry in the distance, try some of the other options and see if they work. This is not an exact science, so play around and see what works for different textures.

</td></tr><tr><td><b><nobr>Fade Out Mips</nobr></b></td><td> Enable this to make the mipmaps fade to gray the mip levels progress. This is used for detail maps.
</td></tr><tr><td><b><nobr>Fade Out start</nobr></b></td><td> The first mip level to begin fading out at.
</td></tr><tr><td><b><nobr>Fade Out End</nobr></b></td><td> The mip level where the texture is completely grayed out
</td></tr><tr><td><b><nobr>Generate  Bump Map</nobr></b></td><td> Enable this to turn the color channels into a format suitable for real-time bumpmapping. For more info, see Bump Maps, below...
</td></tr><tr><td><b><nobr>Bumpyness</nobr></b></td><td> Increase the amount of bumpyness.
</td></tr><tr><td><b><nobr>Filtering</nobr></b></td><td> Determine how the bumpyness is calculated
<dl><dt>Standard</dt><dd> This generates normal maps that are smoother than with a sobel filter</dd><dt>Sobel</dt><dd> The solber filter generates normal maps that are sharper than Standard. </dd></dl>

<p></td></tr></tr></table>
</p>

<h2> Details</h2>

<h3> Supported Formats</h3>
<p>Unity can read the following file formats: PSD, TIFF, JPG, TGA, GIF, PNG,  BMP, IFF, PICT. It should be noted that Unity can import multi-layer PSD &amp; TIFF files just fine. They are flattened automatically on import but the layers are maintained in the assets themselves, so you don't lose any of your work when using these file types natively. This is important as it allows you to just have one copy of your textures that you can use from Photoshop, through your 3D modelling app and into Unity.
</p>

<h3> Texture Sizes</h3>
<p>Ideally texture sizes should be powers of two on the sides. These sizes are as follows: 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024 or 2048 pixels. The textures do not have to be square, i.e. width can be different from height.
</p>

<p>It is possible to use other (non power of two) texture sizes with Unity. Non power of two texture sizes work best when used on <a href="../Components/class-GuiTexture.html">GUI Textures</a>, however if used on anything else they will be converted to an uncompressed RGBA 32 bit format. That means they will take up more video memory (compared to DXT compressed textures) and will be slightly slower to load. In general you'll use non power of two sizes only for making GUI.
</p>

<p>Non power of two texture assets can be scaled up at import time using a <i>Scale NonPower2 Sizes Up</i> option in the import settings. Then Unity will scale texture contents up to the next power of two, and in the game they will behave just like any other texture. So they can still be compressed and very fast to load.
</p>

<h3> UV Mapping</h3>
<p>When mapping a 2D texture on to a 3D model, some sort of wrapping is done. This is called UV mapping and is done in your 3D modelling app. Inside Unity, you can scale and move the texture using <a href="../Components/class-Material.html">Materials</a>. Scaling bump &amp; detail maps are especially useful
</p>

<h3> Mip Maps</h3>
<p>Mip Maps are a list of progressively smaller versions of an image, used optimise performance on real-time 3D engines. Object that are far away from the camera use the smaller textures. Using mip maps uses 33% more memory, but not using mipmaps can be a huge performance loss. You should always you mipmaps for in-game textures; the only exceptions are textures that will never be minified (e.g. GUI textures).
</p>

<h3> Bump Maps</h3>
<p>Bump maps are used by bump map shaders to make low-polygon models look as if they contain more detail. Unity uses normal maps encoded as RGB images. You also have the option to generate a normal map from a grayscale height map image.
</p>

<h3> Detail Maps</h3>
<p>If you want to do a terrain, you normally use your main texture to show where there are grass, rocks sand, etc... If your terrain has a decent size, you will end up with a very blurry terrain. <a href="../Manual/HOWTO-UseDetailTexture.html">Detail textures</a> hide this fact by fading in small details as your main texture get up close.
</p>

<p>When drawing detail textures, a neutral gray is invisible, white makes the main texture twice as bright and black makes the main texture completely black.
</p>

<h3> Cube Maps</h3>
<p>If you want to use texture for reflection maps (e.g. use <i>Reflective</i> builtin shaders), you need to use <a href="../Components/class-CubemapTexture.html">Cubemap Textures</a>.
</p>

<h3> Light Cookies</h3>
<p>An interesting way to add a lot of visual detail to your scenes is to use cookies - greyscale textures you use to control the precise look of in-game lighting. This is fantastic for making moving clouds and giving an impression of dense foilage. The <a href="../Components/class-Light.html">Light</a> page has more info on all this, but the main thing is that for textures to be usable for cookies, the following properties need to be set:
</p>

<p>For <i>spotlight</i> cookies, use the following settings:
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Texture Format</nobr></b></td><td> Any setting that has an alpha channel</td></tr><tr><td><b><nobr>Build Alpha from RGB Grayscale</nobr></b></td><td> Enabled
</td></tr><tr><td><b><nobr>Generate Mip Maps</nobr></b></td><td> Enabled
</td></tr><tr><td><b><nobr>Border Mip Maps</nobr></b></td><td> Enabled
</td></tr></tr></table>
You should keep the edges of you cookie texture solid black in order to get the proper effect. In the texture inspector, set the Edge Mode to <b>Clamp</b>.
</p>

<p>For <i>directional</i> lights, use the following settings:
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Texture Format</nobr></b></td><td> Any setting that has an alpha channel</td></tr><tr><td><b><nobr>Build Alpha from RGB Grayscale</nobr></b></td><td> Enabled
</td></tr><tr><td><b><nobr>Generate Mip Maps</nobr></b></td><td> Enabled
</td></tr><tr><td><b><nobr>Border Mip Maps</nobr></b></td><td> Disabled
</td></tr></tr></table>
This texture will tile, so in the texture inspector, you must set the Edge Mode to <b>Repeat</b>.
</p>

<p>For <i>point</i> lights, you need to use <b>Cube Maps</b>. To generate one, either make six textures and assign them as detailed in <a href="../Components/class-CubemapTexture.html">Cubemap Textures</a> or generate on with the following settings:
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Texture Format</nobr></b></td><td> Any setting that has an alpha channel</td></tr><tr><td><b><nobr>Generate Cube Map</nobr></b></td><td> Any other setting than <b>None</b>.
</td></tr><tr><td><b><nobr>Build Alpha from RGB Grayscale</nobr></b></td><td> Enabled
</td></tr><tr><td><b><nobr>Generate Mip Maps</nobr></b></td><td> Enabled
</td></tr><tr><td><b><nobr>Border Mip Maps</nobr></b></td><td> Disabled
</td></tr></tr></table>
</p>



<p>Meshes make up a large part of your 3D worlds. You don't build your meshes in Unity, but in another application.
</p>

<p>In Unity, we have done everything in our power to make this process as simple as possible. There are a lot of details, but the following should hold:
</p>

<h1> How do I import objects from my 3D app?</h1>

<p>Unity supports importing from a lot of 3D applications. Choose the one you're working with below:
</p>
<ul><li> <a href="../Manual/HOWTO-ImportObjectMaya.html">Maya</a>
</li><li> <a href="../Manual/HOWTO-ImportObjectCinema4D.html">Cinema 4D</a>
</li><li> <a href="../Manual/HOWTO-ImportObjectMax.html">3D Studio MAX</a>
</li><li> <a href="../Manual/HOWTO-ImportObjectCheetah3D.html">Cheetah3D</a>
</li><li> <a href="../Manual/HOWTO-ImportObjectModo.html">Modo</a>
</li><li> <a href="../Manual/HOWTO-importObjectLightwave.html">Lightwave</a>
</li><li> <a href="../Manual/HOWTO-ImportObjectBlender.html">Blender</a>
</li></ul>

<h2> Other applications</h2>
<p>Unity can read <b>.FBX</b>, <b>.3DS</b>, <b>.dxf</b> and <b>.obj</b> files, so if your program can export to this format you're home free. FBX exporters for popular 3D packages can be found <a class="wiki"  href="http://autodesk.com/fbx">here</a>.
</p>

<h2>Hints</h2>
<ul><li> Store textures in a folder called <b>Textures</b> next to the exported mesh. This will guarantee that Unity can always find the Texture and automatically connect the Texture to the Material. For more information, see the <a href="../Components/class-Texture2D.html">Textures</a> reference.
</li></ul>

<h2>See Also</h2>
<ul><li> <a href="../Manual/HOWTO-bumpmap.html">How do I use bump maps?</a>
</li><li> <a href="../Components/class-Mesh.html">Mesh Import Settings</a>
</li><li> <a href="../Manual/HOWTO-FixZAxisIsUp.html">Fixing a mesh that has the z-axis facing upwards</a>
</li></ul>

<h2> Textures</h2>
<p>Unity will attempt to hook up materials to your imported scenes - Basically, just place textures in a folder called 'Textures' next to the sccene file, or in any folder above it.
</p>

<p><img class='figure' src='images/class-Mesh-0.jpg' />
</p>

<h2> Import settings.</h2>
<p>To access the importing settings for a 3D scene file, click the <b>Settings</b> button in the project window, or control-click a scene file and select <b>Import Settings...</b>.
</p>

<p><img class='figure' src='images/class-Mesh-1.jpg' />
</p>

<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Share Materials</nobr></b></td><td> Enable this to generate material files near the found texture files. When enabled,  different scenes will share the same material settings when they use the same textures. For the precise rules, see Material Generation below.
</td></tr><tr><td><b><nobr>One Material for...</nobr></b></td><td> This will generate materials per scene, so only this scene uses them.
</td></tr><tr><td><b><nobr>Don't generate materials</nobr></b></td><td> This will not generate materials at all.
</td></tr><tr><td><b><nobr>Mesh Scale Factor</nobr></b></td><td> Unity's physics system expects 1 meter in the game world to be 1 unit in the imported file. If you like to model at a different scale, this is the place to fix it.
</td></tr><tr><td><b><nobr>Meshes have colliders</nobr></b></td><td> If this is enabled, your meshes will be imported with Mesh Colliders automatically attached. This is recommended for background geometry, but never for geometry you move about. For more info see Colliders below.
</td></tr><tr><td><b><nobr>Automatically calculate normals</nobr></b></td><td> Enable this to automatically generate normals for the imported geometry. If enabled, the <b>Smoothing Angle</b> sets how sharp an edge has to be to be treated as a hard edge.
</td></tr><tr><td><b><nobr>Swap primary and secondary uv channel</nobr></b></td><td> Use this if Lightmapped shaders pick up wrong UV channels.
</td></tr><tr><td><b><nobr>Animation options</nobr></b></td><td> Controls how animations are imported.
<dl><dt>No Animation</dt><dd> No animation or skinning is imported.</dd><dt>Animation in root</dt><dd> Animations are stored in the scene's transform root objects. Use this when animating anything that has a hierarchy.</dd><dt>Animation in original roots</dt><dd> Animations are stored in root objects of your animation package (these might be different from root objects in Unity).</dd><dt>Animation stored in nodes</dt><dd> Animations are stored together with the objects they animate. Use this when you have a complex animation setup and want full scripting control.</dd></dl>
</td></tr><tr><td><b><nobr>Bake IK &amp; simulation</nobr></b></td><td> When using IK or simulation in your animation package, enable this. Unity will convert to FK on import.
</td></tr><tr><td><b><nobr>Keyframe reduction</nobr></b></td><td> Perform keyframe reduction on imported animations. You should always use this, as it takes less memory and is faster.
</td></tr><tr><td><b><nobr>Split animation into multiple clips</nobr></b></td><td> If you have multiple animations in a single file, here you can split it into multiple clips.
<p></td></tr></tr></table>
</p>

<h3> Material Generation</h3>

<p>Materials are found based on the following rules:
</p>

<ul><li> Unity gets the name of the main diffuse material bound to the objects in the scene.
</li><li> Unity looks for a material with this name in a Folder called 'Materials' next to the scene.
</li><li> Unity goes up the project folders, looking for the Material in each 'Materials' folder along the way.
</li></ul>

<p>If Unity can't find the Material, it tries to create one from the texture:
</p>

<ul><li> Unity checks for a texture with the correct name in the same folder as the scene.
</li><li> Unity checks for a texture with the correct name in a folder called 'Textures' next to the scene.
</li><li> Unity goes up the project folders, looking for the correct texture in each 'Textures' folder along the way.
</li><li> If Unity finds the texture, it creates a 'Materials' folder next to it and creates a material in there.
</li></ul>

<h3> Colliders</h3>

<p>Unity features two primary types of colliders: Mesh colliders and Primitive colliders. Mesh colliders are imported together with your geometry and are used for background objects. When you enable <b>Meshes Have Colliders</b> in the import settings, the mesh becomes solid as far as the physics system is concerned.
</p>

<p>If you are moving the object around (a car for example), you can not use mesh colliders. Instead, you will have to use primitive colliders. In this case you should disable the <b>Meshes Have Colliders</b> setting.
</p>

<h3> Animations</h3>

<p>Animations are automatically imported from the scene. For more details about animation import options see <a href="../Manual/Character-Animation.html">Character-Animation</a> chapter.
</p>

<h2>Hints</h2>

<p><ul><li>
Merge your meshes together. Make them share materials and textures. This has a huge performance benefit.
</li><li>If you need to set up your objects further in Unity (adding physics, scripts or other coolness), save yourself a world of pain and name your objects properly in your 3D application. Working with lots of <i>pCube17</i> or <i>Box42</i>-like objects is not fun.
</li><li>Make your meshes be centered on the world origin in your 3D app. This will make them easier to place in Unity.
</li></ul>
</p>



<p>Audio Clips are used by <a href="../Components/class-AudioSource.html">Audio Sources</a> to represent the audio asset imported into Unity.
</p>

<p><img class='figure' src='images/class-AudioClip-0.jpg' />
</p>

<p><i>The Audio Clip</i>
</p>

<p>Audio Clips just work.  The only thing you should have to do with them is reference them from within <a href="../Components/class-AudioSource.html">Audio Sources</a>.
</p>

<h2>Properties</h2>
<p>Sound assets only have 3 read-only properties.
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Format </nobr></b></td><td> The format the sound is stored in. Unity supports 4 raw formats and one compressed.
<dl><dt>Mono 8 bit</dt><dd> 8 bit uncompressed mono PCM audio</dd><dt>Mono 16 bit</dt><dd> 16 bit uncompressed mono PCM audio</dd><dt>Stereo 8 bit</dt><dd> 8 bit uncompressed stereo PCM audio</dd><dt>Stereo 16 bit</dt><dd> 16 bit uncompressed stereo PCM audio</dd><dt>Ogg Vorbis</dt><dd> Ogg Vorbis encoded stereo or mono audio</dd></dl>
</td></tr><tr><td><b><nobr>Length</nobr></b></td><td> The duration of the sound file in seconds.
</td></tr><tr><td><b><nobr>Frequency</nobr></b></td><td> The sampling frequency of the file.
</td></tr></tr></table>
</p>

<h2>Supported sound formats</h2>
<p>Unity currently supports the following file formats:
</p>

<p><dl><dt><b>AIFF</b></dt><dd> Both mono and stereo. The sound will be stored as-is inside the player-data. No compression will be attempted.</dd><dt><b>WAV</b></dt><dd> Both mono and stereo. The sound will be stored as-is inside the player-data. No compression will be attempted.</dd><dt><b>MP3</b></dt><dd> Mono and stereo. Note that the audio will be uncompressed in the editor and stored uncompressed in the player. If you want to conserve space, use Ogg Vorbis files instead.</dd><dt><b>Ogg Vorbis</b></dt><dd> Both mono and stereo. The file will be stored compressed in the player-data and streamed on the fly. When using Ogg vorbis it is recommended to always use 44khz frequency.</dd></dl>
</p>

<h2> Stereo or Mono?</h2>
<p>Stereo sounds are always played as is. They are not faded out over distance and they do not have panning. This makes them optimal for music and ambient sources.
</p>

<p>Mono sounds always fade out over distance and do panning. This is good for all effects requiring 3D positional sound.
</p>

<h2> Choosing the right format</h2>

<p>For music you should always use the ogg vorbis format. The frequency should be 44khz and it should be stereo. (44 khz is recommended since playback will be faster than with 22khz)
</p>

<p>Short audio clips  (eg. foot steps, bullet explosion) you should use <b>AIFF</b> or <b>WAV</b> with mono and either 22khz or 11khz. Usually you should not use 44khz since that takes up too much disk space and the quality difference is not hearable.
</p>

<p>Long audio clips should use ogg vorbis and mono. A good rule of thumb is that if a sound file is more than 200k uncompressed, then it makes sense to use ogg vorbis and stream the sound instead (when using ogg vorbis, always choose 44khz).
</p>

<h2>Hints</h2>
<p><ul><li>
Stereo sounds are always played as-is. If you want to use attenuation and other 3D audio effects, use mono sounds.
</li><li>You can get a free Ogg Vorbis converter from <a class="wiki"  href="http://sbooth.org/Max">http://sbooth.org/Max</a> (Mac) or from <a class="wiki"  href="http://www.rarewares.org/ogg.html">http://www.rarewares.org/ogg.html</a> (Windows)
</li></ul>
</p>



<p>Fonts can be created or imported for drawing using either the <a href="../Components/class-GuiText.html">GUI Text</a> the <a href="../Components/class-TextMesh.html">Text Mesh</a> components.
</p>

<h3>Importing True Type Font files (.ttf)</h3>

<p>To add a font to your project you need to place the <b>.ttf</b> file in your Assets folder. Unity will then automatically import it. You have to make sure that the font has a <i>.ttf</i> extension otherwise Unity will not recognize it.
</p>

<p>To change the <b>size</b> of the font, highlight the Font in the project view and choose <b>Assets -&gt; Import Settings...</b>.
</p>

<p>This brings up the dialog where where you can choose the size of the Font, and setting whether all font characters should be converted to upper case or lower case. Case conversion is optional, but using only lower or upper case characters reduces generated texture size.
</p>

<p><img class='figure' src='images/class-Font-0.jpg' />
</p>

<p>The imported Fonts show some properties in the Inspector but they can not be modified since they are automatically generated from the imported <i>.ttf</i> file.
</p>

<h3> Unicode support</h3>
<p>Unity has full Unicode support. Unicode text allows you to display German, French, Danish or Japanese characters that are usually not supported in an ASCII character set. You can also enter a lot of different special purpose characters like arrow signs or the option key sign, if your font supports it.
</p>

<p>When you import a font file you can select which characters the imported font should support. You should make sure Unicode is selected. Now create a new GUIText while the font is selected and voila you can enter Unicode characters in the GUIText's text field.
</p>

<p>Sometimes you want to display Unicode characters from a script. The Javascript and C# compilers fully support Unicode based scripts. You simply have to save your scripts with UTF-16 encoding.
</p>

<p>In Unitron, this can be done by opening the script and choosing <b>Text -&gt; Text Encoding -&gt; Unicode (UTF 16)</b>.
Now you can add Unicode characters to a string in your script and then assign the string to a GuiText.
</p>

<h2>Hints</h2>
<p><ul><li>
To display an imported font select the font and choose <b>GameObject -&gt; Create Other -&gt; Text</b>
</li></ul>
</p>


<p>Flare objects are the source assets for lens flares. You choose a <b>flare</b> from the project folder for a <b>lens flare</b> in your scene - like you choose textures for your mesh objects.
</p>

<p>Unity ships with a couple of pre-made flares in <a href="../Manual/HOWTO-InstallStandardAssets.html"> Standard Assets</a> package. If you want to add one of these to your scene, Use a <a href="../Components/class-LensFlare.html"> Lens Flare</a> component.
</p>

<p><img class='figure' src='images/class-Flare-0.jpg' />
</p>

<p><i>The Flare asset inspector</i>
</p>

<h2>Properties</h2>
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Elements</nobr></b></td><td> A list of images making up the flare. For a description, see Flare Element properties below.
</td></tr><tr><td><b><nobr>Fade In</nobr></b></td><td> If enabled, the flare will fade up to full strength when it becomes visible and fade out when it doesn't.
</td></tr><tr><td><b><nobr>Zoom In</nobr></b></td><td> If enabled, the elements scale up when the flare becomes visible and scale down again when it doesn't.
</td></tr><tr><td><b><nobr>FlareTexture</nobr></b></td><td> A texture containing images used by this flare.
</td></tr><tr><td><b><nobr>Texture Layout</nobr></b></td><td> How the individual flare element images are laid out inside the flare texture.<br><img class='figure' src='images/class-Flare-1.jpg' />
</td></tr><tr><td><b><nobr>Use Fog</nobr></b></td><td> If enabled, the flare will fade away with distance fog. This is used for small flares.
<p></td></tr></tr></table>
</p>

<h2>Details</h2>

<p>A flare consists of multiple elements, arranged along a line. One point of the line goes through the lens flare object in the scene, the other goes through the screen center. The elements are strung out on this line.
</p>

<h2>Flare Element Properties</h2>
<p>Each element of a flare can be tweaked in a number of ways. Each index of the <b>Elements</b> array reveals the following properties:
</p>

<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Image Index</nobr></b></td><td> Which sub-image to use from the flare texture (see flare textures section below).
</td></tr><tr><td><b><nobr>Position</nobr></b></td><td> The position of the element along the line going from the light position, through the screen center (0 = light, 1 = screen center)
</td></tr><tr><td><b><nobr>Size</nobr></b></td><td> The size of the element
</td></tr><tr><td><b><nobr>Color</nobr></b></td><td> Color tint of the element
</td></tr><tr><td><b><nobr>Use Light Color</nobr></b></td><td> Pick up the color from a light source?
</td></tr><tr><td><b><nobr>Rotate</nobr></b></td><td> If enabled, bottom of the image will always face the center of the screen, making the image spin as the flare moves around on the screen.
</td></tr><tr><td><b><nobr>Zoom</nobr></b></td><td> Make the flare size dependent on brightness?
<p></td></tr></tr></table>
</p>

<h2> Flare Textures</h2>
<p>For performace reasons all elements of one flare share the same texture. This texture contains a collection of the different images that get combined. The <b>Texture Layout</b> defines how the images are laid out in the flare texture. The following layouts are available:
</p>

<p><dl><dt><b>1 Large 4 Small</b></dt><dd> Designed for large sun-style flares where you need one of the flare elements to have a higher fidelity than the others.<br><img class='figure' src='images/class-Flare-2.jpg' /><br>This is designed to be used with textures that are twice as high as they are wide. The numbers in the figure above are the elements' <b>Image Index</b> values.</dd><dt><b>1 Large 2 Medium 8 small</b></dt><dd> Designed for complex flares that require 1 high-definition, 2 medium &amp; 8 small images.<br><img class='figure' src='images/class-Flare-3.jpg' /><br> This is used in the standard <i>50mm Zoom Flare</i> where the two medium ones are the rainbow-colored circles. This is designed to be used with textures that are twice as high as they are wide.</dd><dt><b>1 texture</b></dt><dd> A single image.<br><img class='figure' src='images/class-Flare-4.jpg' /></dd><dt><b>2x2 grid</b></dt><dd> A simple 2x2 grid.<br><img class='figure' src='images/class-Flare-5.jpg' /></dd><dt><b>3x3 grid</b></dt><dd> A simple 3x3 grid.<br><img class='figure' src='images/class-Flare-6.jpg' /></dd><dt><b>4x4 grid</b></dt><dd> A simple 4x4 grid.<br><img class='figure' src='images/class-Flare-7.jpg' /></dd></dl>
</p>

<h2> Hints</h2>
<ul><li> If you use many different flares, try to pack them into one flare texture as that will render faster.
</li></ul>



<p>Render Textures are textures that are created and updated at runtime. Most often you create a Render Texture and setup one of your <a href="../Components/class-Camera.html">Cameras</a> to render into it. Then you can use the contents of render texture in Materials just like you would use a regular texture. For example, <a href="../Manual/HOWTO-Water.html"> Water</a> prefabs in Unity Pro standard assets use render textures to make realtime reflections and refractions.
</p>

<p><img class='figure' src='images/class-RenderTexture-0.jpg' />
</p>

<p><i>The Render Texture Inspector showing the contents of water reflection texture (hence the view is upside down)</i>
</p>

<p>The Render Texture inspector displays the current contents of Render Texture in realtime and can be an invaluable debugging tool for effects that use render textures.
</p>

<h2>Properties</h2>

<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Size</nobr></b></td><td> Set the size of the render texture in pixels.
<p></td></tr></tr></table>
</p>

<h2>Example</h2>

<p>A very quick way to make a live arena-camera in your game:
</p>
<ol><li> Create a new Render Texture asset using <b>Assets -&gt; Create -&gt; Render Texture</b>.
</li><li> Create a new Camera using <b>Game Object -&gt; Create Other -&gt; Camera</b>.
</li><li> Assign the render texture as a <b>Target Texture</b> of the camera.
</li><li> Create a wide, tall and thin box; drag the render texture onto it to create a material that uses the render texture.
</li></ol>

<p><img class='figure' src='images/class-RenderTexture-1.jpg' />
</p>

<p><i>Red tinted box displays live view from the selected camera</i>
</p>




<p>Materials are attached onto Game Objects with <a href="../Components/class-MeshRenderer.html">Mesh</a> or <a href="../Components/class-ParticleRenderer.html">Particle Renderers</a>.  They play an essential part in defining how your object is displayed.
</p>

<p><img class='figure' src='images/class-Material-0.jpg' />
</p>

<p><i>Inspector for a simple material. It uses Diffuse shader which has only two properties - a color and a texture.</i>
</p>

<h2>Properties</h2>
<p>The properties of any Material will change depending on the selected <b>Shader</b>.  These are the most often used properties.
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Shader</nobr></b></td><td> The shader that will be used by the material.
</td></tr><tr><td><b><nobr>Main Color</nobr></b></td><td> Any kind of color tint can be applied.  Use white for no tint.
</td></tr><tr><td><b><nobr>Base</nobr></b></td><td> The Texture that will be displayed.
</td></tr></tr></table>
</p>

<h2>Details</h2>
<p>Materials are used to place <a href="../Components/class-Texture2D.html">Textures</a> onto your Game Objects.  You cannot add a Texture directly without a material.  Therefore, you create a material, assign a shader, and choose the texture to display along with it.  For more information on materials, take a look at the Manual's page about <a href="../Manual/Materials.html">Materials</a>.
</p>

<h3>Choosing Shaders</h3>

<p>After you create your material, the first thing you should decide is which Shader to use.  You choose it from the drop-down <b>Shader</b> menu.
</p>


<p><img class='figure' src='images/class-Material-1.jpg' />
</p>

<p><i>The <b>Shader</b> drop-down menu</i>
</p>

<p>You can choose any shader that exists in your project's assets folder or one of the builtin shaders. You can also create your own shaders.  For more information on shaders, take a look at the <a href="../Manual/Shaders.html">Shaders</a> documentation.
</p>

<h3>Setting shader properties</h3>

<p>Depending on the type of shader selected, a number of different properties can appear in the inspector. Some of the shaders can have quite a lot of them, like the <a href="../Manual/HOWTO-Water.html">Water</a> shader below.
</p>

<p><img class='figure' src='images/class-Material-2.jpg' />
</p>

<p><i>The Reflective&amp;Refractive Water shader has a lot of properties!</i>
</p>


<p>The different types of shader properties are:
</p>

<p><dl><dt>Color pickers</dt><dd> Used to choose colors.</dd><dt>Sliders</dt><dd> Used to tweak a number value across the allowed range.</dd><dt>Textures</dt><dd> Used to select textures.</dd></dl>
</p>

<h3>Texture placement</h3>

<p>The placement of the textures can be altered by clicking <b>Placement</b> button near the texture property. It brings up texture offset and scale foldout.
</p>

<p><img class='figure' src='images/class-Material-3.jpg' />
</p>

<p><i>A texture made to tile 4x2 times by using Scale entries in the Placement foldout</i>
</p>

<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Offset</nobr></b></td><td> Slides the texture around.
</td></tr><tr><td><b><nobr>Scale</nobr></b></td><td> Scales the texture along the different axes.
<p></td></tr></tr></table>
</p>

<h2>Hints</h2>
<p><ul><li>
It is a good practice to share a single material across as many Game Objects as possible.  This has great performance benefits.
</li></ul>
</p>



<p>Cubemap Texture is a collection of six square textures, put onto faces of imaginary cube. Most often they are used to display infinitely faraway reflections on objects, similar to how <a href="../Components/class-Skybox.html">Skybox</a> displays faraway scenery in the background. <i>Reflective</i> builtin shaders in Unity use Cubemaps to display reflection.
</p>

<p>You create Cubemap in one of two ways:
</p>
<ol><li> Use <b>Assets -&gt; Create -&gt; Cubemap</b>, set its properties and then drag six <a href="../Components/class-Texture2D.html">Texture</a> assets onto corresponding cubemap &quot;faces&quot;.
</li><li> Use <a href="../Components/class-Texture2D.html">Texture</a> Import Settings to create a Cubemap from a single square texture.
</li></ol>

<p><img class='figure' src='images/class-CubemapTexture-0.jpg' />
</p>

<p><i>A mountains cubemap displayed as reflection on the sphere</i>
</p>

<h2>Properties</h2>

<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
+X/-X</nobr></b></td><td> Textures for right and left cube faces.
</td></tr><tr><td><b><nobr>+Y/-Y</nobr></b></td><td> Textures for top and bottom cube faces.
</td></tr><tr><td><b><nobr>+Z/-Z</nobr></b></td><td> Textures for front and back cube faces.
</td></tr><tr><td><b><nobr>Texture size</nobr></b></td><td> Edge length in pixels that will be used for a single cubemap face. Source textures will be internally scaled to fit this size, there is no need to scale them manually.
</td></tr><tr><td><b><nobr>Mipmap</nobr></b></td><td> Enable to create mipmaps.
</td></tr><tr><td><b><nobr>Texture format</nobr></b></td><td> Format of the created cubemap.
<p></td></tr></tr></table>
</p>

<h2>See Also</h2>



