<!-- #BeginTemplate "/Templates/manual-page.dwt" --><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<!-- #TemplateBeginEditable name="doctitle" -->
		<title>Unity - Skinned Mesh Renderer</title>
	<!-- #TemplateEndEditable -->
</head>
<link rel="StyleSheet"  href="../Images/docs.css" type="text/css" />
<body onLoad="DocLoaded();">
<table class="titlebar" cellpadding=0 cellspacing=0 border=0><tr>
	<td class="titleleft"><img src="../images/top/left.png"></td>
	<td><a href="../../Documentation.html"><img src="../images/top/logo.png"></a></td>
	<td class="titlemid">
		<table><tr>
			<td class="doctitle">Skinned Mesh Renderer</td>
			<td><table align="right"><tr>
			<!-- #TemplateBeginEditable name="sections-nav" -->
			<td class="Components"><a href="../Manual/index.html" title="Go to Unity manual" class="scripting-anchor"><img src="../images/spacer.gif" class="manual" border="0"><span class="manual-text">Manual</span></a><span class="docs-navigation">&nbsp;&nbsp;&nbsp;&nbsp;</span></td>
			<td class="Components"><a href="../Components/index.html" title="Go to Reference" class="scripting-anchor"><img src="../images/spacer.gif" class="reference" border="0"><span class="components-text">Reference</span></a><span class="docs-navigation">&nbsp;&nbsp;&nbsp;&nbsp;</span></td>
			<td class="Components"><a href="../ScriptReference/index.html" title="Go to Scripting Reference" class="scripting-anchor"><img src="../images/spacer.gif" class="scripting" border="0"><span class="scripting-text">Scripting &nbsp;&nbsp;</span></a></td>
			<!-- #TemplateEndEditable -->	
			</tr></table></td>
		</tr><tr>
			<td colspan="4">
				<table width="100%" class="docpath"><tr><td >
		<!-- #TemplateBeginEditable name="path" -->
					<a href="../Components/index.html">Reference Manual</a> &gt; <a href="../Components/Components.html">Components</a> &gt; <a href="../Components/comp-MeshGroup.html">Mesh Components</a> &gt; <a href="../Components/class-SkinnedMeshRenderer.html">Skinned Mesh Renderer</a>
		<!-- #TemplateEndEditable -->	
				</td>
				</td><td class="switchlink">
					<!-- #TemplateBeginEditable name="switchLink" -->
					<!--BeginSwitchLink--><a href='../ScriptReference/SkinnedMeshRenderer.html' title='Go to SkinnedMeshRenderer Scripting Doc'>Switch to Scripting</a><!--EndSwitchLink-->
					<!-- #TemplateEndEditable -->	
				</td></tr></table>
			</td>
		</tr></table>
	</td>
	<td class="titleright" width="9"><img src="../images/top/right.png"></td>
</tr></table>
<div class="manual">
	<div class="main">

		<!-- #TemplateBeginEditable name="navigation" -->
		<div class="nav">  </div>
		<!-- #TemplateEndEditable -->	
		<!-- #TemplateBeginEditable name="title" -->
			<h1>Skinned Mesh Renderer</h1>
		<!-- #TemplateEndEditable -->	
		<!-- #TemplateBeginEditable name="body" -->
			
<p>The <span class='doc-keyword'>Skinned Mesh Renderer</span> is automatically added to imported meshes when the imported mesh is skinned.
</p>
<div class='vspace'></div><div><img class='figure' src='../Images/manual/class-SkinnedMeshRenderer-0.jpg' /><br /><em>An animated character rendered using the Skinned Mesh Renderer</em></div>
<div class='vspace'></div><h2>Properties</h2>
<table width='100%'><tr class='tableheader'><td  class='prop'></td><td class='function'></td></tr>
<tr ><td  align='left'><span class='doc-prop'>Cast Shadows</span> (Pro only)</td><td  align='left'>If enabled, this <span class='doc-keyword'>Mesh</span> will create shadows when a shadow-creating <a href="../Components/class-Light.html">Light</a> shines on it</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Receive Shadows</span> (Pro only)</td><td  align='left'>If enabled, this Mesh will display any shadows being cast upon it</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Materials</span></td><td  align='left'>A list of <span class='doc-keyword'>Materials</span> to render model with.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Quality</span></td><td  align='left'>The maximum amount of bones affecting every vertex.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Update When Offscreen</span></td><td  align='left'>If enabled, the Skinned Mesh will be updated when offscreen. If disabled, this also disables updating animations.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Bounds</span></td><td  align='left'>These bounds are use for determining when skinned mesh is offscreen. Bounding box is also displayed in the SceneView. Bounds are precalculated on import based on Mesh and animations in the model file.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Mesh</span></td><td  align='left'>Meshed used by this renderer.</td></tr>
</table>
<div class='vspace'></div><h2>Details</h2>
<p>Skinned Meshes are used for rendering characters. Characters are animated using bones, and every bone affects a part of the mesh. Multiple bones can affect the same vertex and are weighted.  The main advantage to using boned characters in Unity is you can enable the bones to be affected by physics, making your characters into ragdolls.  You can enable/disable bones via scripting, so your character instantly goes ragdoll when it is hit by an explosion.
</p>
<div class='vspace'></div><div><img class='figure' src='../Images/manual/class-SkinnedMeshRenderer-1.jpg' /><br /><em>A Skinned Mesh enabled as a Ragdoll</em></div>
<div class='vspace'></div><h3>Quality</h3>
<p>Unity can skin every vertex with either 1, 2, or 4 bones. 4 bone weights look nicest and are most expensive. 2 Bone weights is a good compromise and can be commonly used in games.
</p>
<p class='vspace'>If <span class='doc-prop'>Quality</span> is set to <span class='doc-prop'>Automatic</span>, the <a href="../Components/class-QualitySettings.html">Quality Settings</a> <span class='doc-prop'>Blend Weights</span> value will be used. This allows end-users to choose a quality setting that gives them optimum performance.
</p>
<div class='vspace'></div><h3>Update When Offscreen and Bounds</h3>
<p>By default, skinned meshes that are not visible are not updated. The skinning is not updated until the mesh comes back on screen. This is an important performance optimization - it allows you to have a lot of characters running around not taking up any processing power when they are not visible.
</p>
<p class='vspace'>However, visibility is determined from the Mesh's Bounds, which is precalculated on import. Unity takes into account all attached animations for precalcualating bounding volume, but there are cases when Unity can't precalculate Bounds to fit all user's needs, for example (each of these become a problem when they push bones or vertices out of precalculated bounding volume):
</p><ul><li>adding animations at run-time;
</li><li>using additive animations;
</li><li>proceduraly affecting positions of bones;
</li><li>using vertex shaders which can push vertices out of precalculated bounds;
</li><li>using ragdolls.
</li></ul><p class='vspace'>In those cases there are two solutions:
</p><ol><li>modify Bounds to match potential bounding volume of your mesh;
</li><li>enable <span class='doc-prop'>Update When Offscreen</span> to skin and render skinned mesh all the time.
</li></ol><p class='vspace'>You should use fist option most of the time since it has better performance and use second option only if performance is not important in your case or you can't predict the size of your bounding volume (for example when using ragdolls).
</p>
<p class='vspace'>In order to make SkinnedMeshes work better with Ragdolls Unity will automatically remap the SkinnedMeshRenderer to the rootbone on import. However Unity only does this if there is a single SkinnedMeshRenderer in the model file.
So if you can't attach all SkinnedMeshRenderers to the root bone or a child and you use ragdolls, you should turn off this optimization.
</p>
<div class='vspace'></div><h2>Hints</h2>
<ul><li>Skinned Meshes currently can be imported from:
<ul><li>Maya
</li><li>Cinema4D
</li><li>3D Studio Max
</li><li>Blender
</li><li>Cheetah 3D
</li><li>XSI
</li><li>Any other tool that supports the FBX format
</li></ul></li></ul>
</p><small>Page last updated: 2011-08-17</p>
    <script type="text/javascript">


    var allHTMLTags = new Array();
    document.divs = new Array();

    function getElementByClass(theClass) {

	    var allHTMLTags=document.getElementsByTagName("*");

	    for (var i=0; i<allHTMLTags.length; i++) {

		    if (allHTMLTags[i].className==theClass) {
			    return true;
		    }
	    }
	    return false;
    }

    function ShowHideDiv(containerName, className, content){
	var container = document.getElementById(containerName);
	if(container == null)
		return;
	if(content == '') {//In case there are no divs in the page we still can change the icons.
		if(containerName == 'desktopRef') {
			if(container.innerHTML == "<img src=\"../Images/DesktopNO.png\" alt=\"\">") {
				container.innerHTML = "<img src=\"../Images/DesktopYES.png\" alt=\"\">";
				SetCookie(containerName, 'set', 30);
			} else {
				container.innerHTML = "<img src=\"../Images/DesktopNO.png\" alt=\"\">";
				UnSetCookie(containerName);
			}
		}
		if(containerName == 'iosRef') {
			if(container.innerHTML == "<img src=\"../Images/iPhoneNO.png\" alt=\"\">") {
				container.innerHTML = "<img src=\"../Images/iPhoneYES.png\" alt=\"\">";
				SetCookie(containerName, 'set', 30);
			} else {
				container.innerHTML = "<img src=\"../Images/iPhoneNO.png\" alt=\"\">";
				UnSetCookie(containerName);
			}
		}
		if(containerName == 'androidRef') {
			if(container.innerHTML == "<img src=\"../Images/AndroidNO.png\" alt=\"\">") {
				container.innerHTML = "<img src=\"../Images/AndroidYES.png\" alt=\"\">";
				SetCookie(containerName, 'set', 30);
			} else {
				container.innerHTML = "<img src=\"../Images/AndroidNO.png\" alt=\"\">";
				UnSetCookie(containerName);
			}	
		}
	} else {
		if(container.innerHTML == "<h1><img src=\"../Images/PlatformArrowRight.png\" alt=\"\"> " + content + "</h1>") {
		container.innerHTML = "<h1><img src=\"../Images/PlatformArrowDown.png\" alt=\"\">" + content + "</h1>";
			SetCookie(containerName, 'set', 30);
		} else {
			container.innerHTML = "<h1><img src=\"../Images/PlatformArrowRight.png\" alt=\"\">" + content + "</h1>";
			UnSetCookie(containerName);
		}
	}
	for(var i = 0; i < document.divs.length; i++) {
		var divClassName = document.divs[i];
		var matched = false;
		if(divClassName.className == className)
			   matched = true;
		if(matched) {
			
			if(divClassName != null) {
				if (divClassName.style.display == 'block') {
					divClassName.style.display = 'none';
					if(content == '') {
						if(className == 'specific-desktop')
							container.innerHTML = "<img src=\"../Images/DesktopNO.png\" alt=\"\" />";
						if(className == 'specific-ios')
							container.innerHTML = "<img src=\"../Images/iPhoneNO.png\" alt=\"\" />";
						if(className == 'specific-android')
							container.innerHTML = "<img src=\"../Images/AndroidNO.png\" alt=\"\" />";
					} else {
						container.innerHTML = "<h1><img src=\"../Images/PlatformArrowRight.png\" alt=\"\" /> " + content + "</h1>";
					}
					UnSetCookie(containerName);
				} else {
					divClassName.style.display = 'block';
					if(content == '') {
						if(className == 'specific-desktop')
							container.innerHTML = "<img src=\"../Images/DesktopYES.png\" alt=\"\" />";
						if(className == 'specific-ios')
							container.innerHTML = "<img src=\"../Images/iPhoneYES.png\" alt=\"\" />";
						if(className == 'specific-android')
							container.innerHTML = "<img src=\"../Images/AndroidYES.png\" alt=\"\" />";
					} else {
						container.innerHTML = "<h1><img src=\"../Images/PlatformArrowDown.png\" alt=\"\" /> " + content + "</h1>";
					}
					SetCookie(containerName, 'set', 30);
				}
			}
		}	
        }			   
    }
    function UnSetCookie(cn) {
    	SetCookie(cn,'',30);
    }

    function GetCookie(cName) {
	if (document.cookie.length > 0) {
            cStart = document.cookie.indexOf(cName + "=");
	    if(cStart != -1) {
	        cStart = cStart + cName.length + 1;
	        cEnd = document.cookie.indexOf(";", cStart);
	        if (cEnd == -1) {
	            cEnd = document.cookie.length;
	        }
	        return unescape(document.cookie.substring(cStart, cEnd));;
	    }
	}
	return "";
    }

    function SetCookie(cName, value, expireDays) {
	var exDate = new Date();
	exDate.setDate(exDate.getDate()+expireDays);
	document.cookie = cName + "=" + escape(value) + ((expireDays ==null) ? "" : ";expires=" + exDate.toGMTString()) + ";path=/";
    }

    function DocLoaded() {
	document.divs = document.getElementsByTagName('div');
	var prefDesktop = GetCookie('desktopRef');
	var prefiOS = GetCookie('iosRef');
	var prefAndroid = GetCookie('androidRef');
	var firstTime = GetCookie('FT');
	if (firstTime == null || firstTime == "" ) {
	    SetCookie('FT', 'no', 30);
	    SetCookie('desktopRef', 'set', 30)
	} else if (prefDesktop == null || prefDesktop =="") {
	    if(getElementByClass('desktopRefIMG')) {
	        ShowHideDiv('desktopRef','specific-desktop','');
	    } else {
	        ShowHideDiv('desktopRef','specific-desktop','Desktop');
	    }
	}
	if (prefiOS == null || prefiOS =="") {
	    if(getElementByClass('iosRefIMG')) {
	        ShowHideDiv('iosRef','specific-ios','');
	    } else {
	        ShowHideDiv('iosRef','specific-ios','iOS');
	    }
	}
	if (prefAndroid == null || prefAndroid =="") {
	    if(getElementByClass('androidRefIMG')) {
	        ShowHideDiv('androidRef','specific-android','');
	    } else {
	        ShowHideDiv('androidRef','specific-android','Android');
	    }
	}	
    }
    </script>
    
		<!-- #TemplateEndEditable -->	

		<div class="nav">  </div>
	</div>
</div>
</body></html>
<!-- #EndTemplate -->
