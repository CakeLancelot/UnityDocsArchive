<!-- #BeginTemplate "/Templates/manual-page.dwt" --><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<!-- #TemplateBeginEditable name="doctitle" -->
		<!-- #BeginLibraryItem name="/Library/manual-title.lbi" section="Manual" title="Physics"-->
		<!-- #EndLibraryItem -->
	<!-- #TemplateEndEditable -->
</head>
<link rel="StyleSheet"  href="../images/manual.css" type="text/css" />
<body>
<table class="titlebar" cellpadding=0 cellspacing=0><tr>
<td class="doctitle">
	<!-- #TemplateBeginEditable name="manual-h1" -->
		<!-- #BeginLibraryItem name="/Library/manual-h1.lbi" section="Manual" title="Physics" path="%3Ca%20href%3D%22index.html%22%3EUnity%20Manual%3C%2Fa%3E%20%26gt%3B%20%3Ca%20href%3D%22User%20Guide.html%22%3EUser%20Guide%3C%2Fa%3E%20%26gt%3B%20%3Ca%20href%3D%22Game%20Logic.html%22%3EGame%20Logic%3C%2Fa%3E%20%26gt%3B%20%3Ca%20href%3D%22Physics.html%22%3EPhysics%3C%2Fa%3E" -->
		<h1>Physics</h1>
		<p ><a href="index.html">Unity Manual</a> &gt; <a href="User Guide.html">User Guide</a> &gt; <a href="Game Logic.html">Game Logic</a> &gt; <a href="Physics.html">Physics</a></p>
		<!-- #EndLibraryItem -->
	<!-- #TemplateEndEditable -->
	</td><td class="navbuttons" rowspan=2>
	<a href="../Manual/index.html"><img src="../images/Manuals.png" width="66" height="51"></a><a href="../Components/index.html"><img src="../images/Reference.png" width="62" height="51"></a><a href="../ScriptReference/index.html"><img src="../images/Scripting.png" width="66" height="51"></a></td>
	</tr><tr>
	<td height="1"bgcolor="#C9C9C9"><img src="../images/spacer.gif" width="236" height="1" alt=""></td>
	</tr>
</table>
<div class="manual">
	<div class="main">
		<!-- #TemplateBeginEditable name="body" -->
		<div class="navigation"><a href="Game Logic.html"><img src="../images/prev.png">Previous</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="Animation.html">Next<img src="../images/next.png"></a></div>

			

<p>Unity has the next-generation Ageia PhysX physics engine built-in. This allows for unique emergent behaviour and is generally very cool.
</p>

<h2>Basics</h2>
<p>To put an object under physics control, simply add a Rigidbody to it. When you do this, the object will be affected by gravity, and can collide with other objects in the world.
</p>


<h1>Rigidbody</h1>
<p>Rigidbodies are the gateway for applying physics to your objects. The Rigidbody can receive forces and torque to make your objects move in a realistic way.  Any GameObject must contain a Rigidbody to be influenced by gravity, act under added forces via scripting, or interact with other objects through the Ageia physX physics engine.
</p>

<!-- #BeginLibraryItem name="/Library/doc-figure.lbi" src="%22images/Physics-0.jpg%22" --><p><table><tr><td><img class="figure" src="images/Physics-0.jpg"></td></tr></table></p><!-- #EndLibraryItem -->
</p>

<p><i>A GameObject with a Rigidbody component attached</i>
</p>

<h2>Properties</h2>
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Mass</nobr></b></td><td> The weight of the object. Keep this below 1 for the best stability.
</td></tr><tr><td><b><nobr>Drag</nobr></b></td><td> How much air resistance affects the object when moving from forces. 0 means no air resistance, and infinity makes the object stop moving immediately.
</td></tr><tr><td><b><nobr>Angular Drag</nobr></b></td><td> How much air resistance affects the object when rotating from torque. 0 means no air resistance, and infinity makes the object stop rotating immediately.
</td></tr><tr><td><b><nobr>Use Gravity</nobr></b></td><td> If checked, the object is affected by gravity.
</td></tr><tr><td><b><nobr>Is Kinematic</nobr></b></td><td> If checked, the object will not be driven by the physics engine, but can only be manipulated by its Transform. This is useful for moving platforms or if you want to animate a Rigidbody that has a Hinge Joint attached.
<p></td></tr></tr></table>
</p>

<h2>Details</h2>
<p>Rigidbodies allow your GameObjects to act under control of the physics engine.  This opens the gateway to realistic collisions, varied types of joints, and other very cool behaviors.  Manipulating your objects by adding forces to a Rigidbody creates a very different feel and look than adjusting the Transform property directly.  Generally, you shouldn't manipulate the Rigidbody and the Transform of the same object &mdash; just one or the other.
</p>

<p>The biggest difference between manipulating the Transform or the Rigidbody is the use of forces.  Rigidbodies can receive forces and torque, but Transforms cannot.  Transforms can be translated and rotated, but this is not the same as using physics. You'll notice the distinct difference when adding you try it for yourself.  Adding forces/torque to the Rigidbody will actually change the object's position and rotation of the Transform component.  This is why you should only be using one or the other.  Changing the Transform while using phyics could cause problems with collisions and other calculations.
</p>

<p>Rigidbodies must be explicitly added to your game object before they will be affected by the physics engine.  You can add a Rigidbody to your selected object from <b>Components -&gt; Dynamics -&gt; Rigidbody</b>. Now your object is physics-ready; it will fall under gravity and can receive forces via scripting, but you may want to add a Collider or a Joint to get it to behave exactly how you want.
</p>

<h3> Parenting</h3>
<p>When an object is under physics control, it moves semi-independently of the way its transform parents move. If you move any parents, they will pull the Rigidbody child along with them. However, the Rigidbodies will still fall down due to gravity and react to collision detection.
</p>

<h3> Scripting</h3>
<p>To control your Rigidbodies, you will primarily use scripts to add forces or torque. You do this by calling <a class="wiki"  href="../ScriptReference/Rigidbody.AddForce.html">AddForce</a> and <a class="wiki"  href="../ScriptReference/Rigidbody.html#AddTorque">AddTorque</a> on the object's Rigidbody.  Remember that you shouldn't be directly altering the object's Transform when you are using physics.
</p>

<h3>Animation</h3>
<p>For some situations, mainly creating ragdoll effects, it is neccessary to switch control of the object between animations and physics. For this purpose Rigidbodies can be marked <a class="wiki"  href="http://www.unity3d.com/Documentation/ScriptReference/Rigidbody.html#isKinematic">Kinematic</a>. While the Rigidbody is marked Kinematic, it will not be affected by collisions, forces, or any other part of the physics engine. This means that you will have to control the object by manipulating the <a href="../Components/class-Transform.html">Transform</a> component directly.  Kinematic Rigidbodies will affect other objects, but they themselves will not be affected by physics. For example, Joints which are attached to Kinematic objects will constrain any other Rigidbodies attached to them and Kinematic Rigidbodies will affect other Rigidbodies through collisions.
</p>

<h3>Colliders</h3>
<p>Colliders are another kind of component that must be added alongside the Rigidbody in order to allow collisions to occur.  If two Rigidbodies bump into each other, the phyics engine will not calculate a collision unless both objects also have a Collider attached.  Collider-less Rigidbodies will simply pass through each other during physics simulation.
</p>

<!-- #BeginLibraryItem name="/Library/doc-figure.lbi" src="%22images/Physics-1.jpg%22" --><p><table><tr><td><img class="figure" src="images/Physics-1.jpg"></td></tr></table></p><!-- #EndLibraryItem -->
</p>

<p><i>A Rigidbody with a Collider component attached</i>
</p>

<p>Add a collider with the Component -&gt; Dynamics menu.  View the Component page of any individual Collider for more specific information:
</p>
<ul><li><a href="../Components/class-BoxCollider.html">Box Collider</a> - primitive shape of a cube
</li><li><a href="../Components/class-SphereCollider.html">Sphere Collider</a> - primitive shape of a sphere
</li><li><a href="../Components/class-CapsuleCollider.html">Capsule Collider</a> - primitive shape of a capsule
</li><li><a href="../Components/class-MeshCollider.html">Mesh Collider</a> - creates a collider from the object's mesh, cannot collide with another Mesh Collider
</li><li><a href="../Components/class-WheelCollider.html">Wheel Collider</a> - specifically for creating cars or other moving vehicles
</li></ul>



<h3>Compound colliders</h3>

<p>Compound Colliders are combinations of primitive Colliders, all together acting as a single Collider.  They come in handy when you have a complex mesh to use in collisions, but cannot use a Mesh Collider.  To create a Compound Collider, create child objects of your colliding object, then add a primitive Collider to each child object.  This allows you to position, rotate, and scale each Collider easily and independently of each other.
</p>

<p><img alt="" src=""img/wiki_up/RigidBody" border="0"  />
</p>

<p><i>A GameObject with a Rigidbody and multiple colliders attached</i>
</p>

<p>In the above picture, the terrain has a Mesh Collider attached.  Mesh Colliders work the best for terrain or environments made from irregular shapes. The Rigidbody has 3 child Colliders attached: capsule, cube and sphere. When Play mode begins, the Rigidbody falls due to gravity, and the 3 child Colliders fall with it. The 3 Collision primitives collide with the Mesh Collider, and the Rigidbody eventually balances and comes to rest on the 3 Colliders.
</p>

<p>Keep in mind, Mesh Colliders can't collide with each other, so the typical solution is to use primitive Colliders for any objects that move, and Mesh Colliders for static background objects.
</p>




<h2>Use the right size</h2>
<p>The size value of the your object's mesh is much more important than the mass of the Rigidbody.  If you find that your Rigidbody is not behaving exactly how you expect; it moves slowly, 'floats', or doesn't collide correctly; consider adjusting the scale of your mesh and/or the Rigidbody's <a href="../Components/class-Transform.html">Transform</a>.  Unity's default unit scale is 1 unit = 1 meter, so the scale of your imported mesh is maintained, and applied to physics calculations.  For example, a crumbling skyscraper is going to fall apart very differently than a tower made of toy blocks, so objects of different sizes should be modeled to accurate scale.
</p>

<p>If you are modelling a human make sure he is around 2 meters big in Unity. To check if your object has the right size compare it to the default cube. You can create a cube using <b>GameObject -&gt; Create Other -&gt; Cube</b>. The cube will be exactly 1 meter large. So your human should be twice as tall.
</p>

<p>If you aren't able to adjust the mesh itself, you can change the global scale of each particular mesh by control-clicking on your imported mesh and selecting 'Import Settings' from the context menu.  Here, you can change the scale and re-import your mesh.
</p>

<p>If your game requires that your GameObject needs to be instantiated at different scales, it is perfectly okay to directly adjust the values of your Transform's scale.  The down-side is that the physics simulation must do more work at the time the object is instantiated, and could cause a performance drop in your game.  This isn't a terrible loss, but it is not as efficient as finalizing your scale with the other two options.
</p>


<h2>Hints</h2>
<p><ul><li>
The relative masses of two objects determines how they react when they collide.
</li><li>Making one object have higher mass than another does not make it fall faster in free fall. Use drag for that.
</li><li>A low drag value makes an object seem heavy. A high one makes it seem light. Typical values for drag are between .001 (solid block of metal) and 10 (feather)
</li><li>If you are directly manipulating the Transform component of your object, don't attach a Rigidbody
</li></ul>
</p>
<h1>Constant Force</h1>
<p>The Constant Force component is a quick utility for adding constant forces to a rigidbody.
This works great for one shot objects like rockets, if you don't want it to start with a large velocity but instead accelerate.
</p>

<!-- #BeginLibraryItem name="/Library/doc-figure.lbi" src="%22images/Physics-2.jpg%22" --><p><table><tr><td><img class="figure" src="images/Physics-2.jpg"></td></tr></table></p><!-- #EndLibraryItem -->
</p>

<p><i>A rocket propelled forward by the constant force component</i>
</p>

<h2>Properties</h2>
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Force</nobr></b></td><td> The vector of a force to be applied in world space.
</td></tr><tr><td><b><nobr>Relative Force</nobr></b></td><td> The vector of a force to be applied in the objects local space.
</td></tr><tr><td><b><nobr>Torque</nobr></b></td><td> The vector of a torque, applied in world space. The object will begin spinning <i>around</i> this vector. The longer the vector is, the faster the rotation.
</td></tr><tr><td><b><nobr>Relative Torque</nobr></b></td><td> The vector of a torque, applied in local space. The object will begin spinning <i>around</i> this vector. The longer the vector is, the faster the rotation.
<p></td></tr></tr></table>
</p>

<h3> Details</h3>

<p>To make a rocket that accelerates forward set the relative force to be along the positive z-axis. Then use the rigidbody's drag property to make it not exceed a some maximum velocity. (The higher the drag the lower the maximum velocity will be.)
In the rigidbody also make sure to turn off gravity so that the rocket will always stay on it's path.
</p>

<h2>Hints</h2>
<p><ul><li>
To make an object flow upwards, add a constant force with the Force property having a positive Y value.
</li><li>To make an object fly forwards,  add a constant force with the Relative Force property having a positive Z value.
</li></ul>
</p>

<h1>Sphere Collider</h1>
<p>The Sphere Collider is a basic sphere-shaped collision primitive.
</p>

<!-- #BeginLibraryItem name="/Library/doc-figure.lbi" src="%22images/Physics-3.jpg%22" --><p><table><tr><td><img class="figure" src="images/Physics-3.jpg"></td></tr></table></p><!-- #EndLibraryItem -->
</p>

<p><i>(Image of a Sphere Collider in Inspector)</i>
</p>

<h2>Properties</h2>
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Material</nobr></b></td><td> Reference to the PhysicMaterial that determines how this Collider interacts with others.
</td></tr><tr><td><b><nobr>Is Trigger</nobr></b></td><td> If enabled, this Collider is used for triggering events, and is ignored by the physics engine.

</td></tr><tr><td><b><nobr>Radius</nobr></b></td><td> The size of the collider.
</td></tr><tr><td><b><nobr>Center</nobr></b></td><td> The position of the collider in the object's local space.
<p></td></tr></tr></table>
</p>

<h2>Details</h2>
<p>The Sphere Collider can be resized to uniform scale, but not along individual axes. It works great for falling boulders, ping pong balls, marbles, etc.
</p>

<!-- #BeginLibraryItem name="/Library/doc-figure.lbi" src="%22images/Physics-4.jpg%22" --><p><table><tr><td><img class="figure" src="images/Physics-4.jpg"></td></tr></table></p><!-- #EndLibraryItem -->
</p>

<p><i>A standard Sphere Collider</i>
</p>


<p>Colliders work with Rigidbodies to bring physics in Unity to life.  Whereas Rigidbodies allow objects to be controlled by physics, Colliders allow objects to collide with each other.  Colliders must be added to objects independently of Rigidbodies.  A Collider does not necessarily need a Rigidbody attached, but a Rigidbody <span style="text-decoration:underline;">must</span> be attached in order for the object to react to collisions.
</p>

<p>When a collision between two Colliders occurs and if at least one of them has a Rigidbody attached, <a class="wiki"  href="../ScriptReference/Collider.html#OnCollisionEnter">three</a> <a class="wiki"  href="../ScriptReference/Collider.html#OnCollisionExit">collision</a> <a class="wiki"  href="../ScriptReference/Collider.html#OnCollisionStay">messages</a> are sent out to the objects attached to them. These events can be handled in scripting, and allow you to create unique behaviors with or without making use of the built-in Ageia physX engine.
</p>

<h3>Triggers</h3>
<p>An alternative way of using Colliders is to mark them as a Trigger, just check the IsTrigger property checkbox in the Inspector.  Triggers are effectively ignored by the physics engine, and have a unique set of <a class="wiki"  href="../ScriptReference/Collider.html#OnTriggerEnter">three</a> <a class="wiki"  href="../ScriptReference/Collider.html#OnTriggerExit">trigger</a> <a class="wiki"  href="../ScriptReference/Collider.html#OnTriggerStay">messages</a> that are sent out when a collision with a Trigger occurs.  Triggers are useful for triggering other events in your game, like cutscenes, automatic door opening, displaying tutorial messages, etc.  Use your imagination!
</p>

<p>Be aware that in order for two Triggers to send out trigger events when they collide, one of them must be attached to a Rigidbody. For a Trigger to collide with a normal Collider, one of them must have a Rigidbody attached.  For a detailed chart of different types of collisions, see the collision action matrix in the Advanced section below.
</p>


<h2>Compound Colliders</h2>

<p>Compound Colliders are combinations of primitive Colliders, all together acting as a single Collider.  They come in handy when you have a complex mesh to use in collisions, but cannot use a Mesh Collider.  To create a Compound Collider, create child objects of your colliding object, then add a primitive Collider to each child object.  This allows you to position, rotate, and scale each Collider easily and independently of each other.
</p>

<p><img alt="" src=""img/wiki_up/RigidBody" border="0"  />
</p>

<p><i>A GameObject with a Rigidbody and multiple colliders attached</i>
</p>

<p>In the above picture, the terrain has a Mesh Collider attached.  Mesh Colliders work the best for terrain or environments made from irregular shapes. The Rigidbody has 3 child Colliders attached: capsule, cube and sphere. When Play mode begins, the Rigidbody falls due to gravity, and the 3 child Colliders fall with it. The 3 Collision primitives collide with the Mesh Collider, and the Rigidbody eventually balances and comes to rest on the 3 Colliders.
</p>

<p>Keep in mind, Mesh Colliders can't collide with each other, so the typical solution is to use primitive Colliders for any objects that move, and Mesh Colliders for static background objects.
</p>


<h2>Hints</h2>
<p><ul><li>
To add multiple Colliders for an object, create child objects and attach a Collider to each one.  This allows each Collider to be manipulated independently.
</li><li>You can look at the gizmos in the Scene view to see how the Collider is being calculated on your object.
</li><li>Colliders do their best to match the scale of an object. If you have a non-uniform scale (a scale which is different in each direction), only the Mesh Collider can match completely.
</li><li>If you make an explosion, it can be very effective to add a rigidbody with lots of drag and a sphere collider to it in order to push it out a bit from the wall it hits.
</li></ul>
</p>


<h1>Box Collider</h1>
<p>The Box Collider is a basic cube-shaped collision primitive.
</p>

<!-- #BeginLibraryItem name="/Library/doc-figure.lbi" src="%22images/Physics-5.jpg%22" --><p><table><tr><td><img class="figure" src="images/Physics-5.jpg"></td></tr></table></p><!-- #EndLibraryItem -->
</p>

<p><i>Box collider here is used to approximate car's hull</i>
</p>

<h2>Properties</h2>
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>Size</nobr></b></td><td> The size of the collider in the X, Y, Z directions.
</td></tr><tr><td><b><nobr>Center</nobr></b></td><td> The position of the collider in the object's local space.
<p></td></tr></tr></table>
</p>

<h2>Details</h2>
<p>The Box Collider can be resized into different shapes of rectangular prisms.  It works great for doors, walls, platforms, etc. It is also effective as a human torso in a ragdoll or car hull in a vehicle. Of course, it works perfectly for just boxes and crates as well!
</p>

<!-- #BeginLibraryItem name="/Library/doc-figure.lbi" src="%22images/Physics-6.jpg%22" --><p><table><tr><td><img class="figure" src="images/Physics-6.jpg"></td></tr></table></p><!-- #EndLibraryItem -->
</p>

<p><i>A standard Box Collider</i>
</p>




<h2>Compound Colliders</h2>




<h2>Hints</h2>
<p><ul><li>
</p>

<p></li></ul>
</p>


<h1>Mesh Collider</h1>

<p>The Mesh Collider takes a <a href="../Components/class-Mesh.html">Mesh Asset</a> and builds its Collider based on that mesh.  It is far more accurate for collision detection than using primitives for complicated meshes, but it cannot collide with other Mesh Colliders.
</p>

<!-- #BeginLibraryItem name="/Library/doc-figure.lbi" src="%22images/Physics-7.jpg%22" --><p><table><tr><td><img class="figure" src="images/Physics-7.jpg"></td></tr></table></p><!-- #EndLibraryItem -->
</p>

<p><i>A Mesh Collider used on the flag tower object</i>
</p>

<h2>Properties</h2>
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>Mesh</nobr></b></td><td> Reference to the Mesh to use for collisions.
</td></tr><tr><td><b><nobr>Smooth Sphere Collisions</nobr></b></td><td> When this is enabled, collision mesh normals are smoothed. You should enable this on smooth surfaces eg. rolling terrain without hard edges to make sphere rolling smoother.
<p></td></tr></tr></table>
</p>

<h2>Details</h2>
<p>The Mesh Collider builds its collision representation from the <a href="../Components/class-Mesh.html">Mesh</a> attached to the GameObject, and reads the properties of the attached <a href="../Components/class-Transform.html">Transform</a> to set its position and scale correctly.
</p>



<h2>Hints</h2>
<p><ul><li>
Mesh Colliders <span style="text-decoration:underline;">cannot</span> collide with each other.  Therefore, they are most useful for background objects like environment geometry.
</li><li>It is usually better to use primitive Colliders for objects under physics control.
</li><li>When you attach a Mesh Collider to a Game Object, its Mesh property will default to the mesh being rendered. You can change that by assigning a different Mesh.
</p>

<p></li></ul>
</p>


<h1>Physic Material</h1>
<p>The physics material contain all info needed to tune friction and bouncing effects of colliding objects.
</p>

<p>To create a physic material select the menu <b>Assets -&gt; Create -&gt; Physic Material</b>.  Then drag the physic material from the project pane on a collider in the scene.
</p>

<!-- #BeginLibraryItem name="/Library/doc-figure.lbi" src="%22images/Physics-8.jpg%22" --><p><table><tr><td><img class="figure" src="images/Physics-8.jpg"></td></tr></table></p><!-- #EndLibraryItem -->
</p>

<p><i>The Physic Material</i>
</p>

<h2>Properties</h2>
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Static Friction</nobr></b></td><td> The friction used when an object is lying on a surface. Usually a value from 0 to 1.
</td></tr><tr><td><b><nobr>Dynamic Friction</nobr></b></td><td> The friction used when already moving. Usually a value from 0 to 1.
</td></tr><tr><td><b><nobr>Bouncyness</nobr></b></td><td> How bouncy is the surface? A value of 0 will not bounce. A value of 1 will bounce without any loss of energy.
</td></tr><tr><td><b><nobr>Friction Combine Mode</nobr></b></td><td> How the friction of two colliding objects is combined.
</td></tr><tr><td><b><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Average</nobr></b></td><td> The two friction values are averaged.
</td></tr><tr><td><b><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Min</nobr></b></td><td> The smallest of the two values is used.
</td></tr><tr><td><b><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Max</nobr></b></td><td> The largest of the two values is used.
</td></tr><tr><td><b><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Multiply</nobr></b></td><td> The friction values are multiplied with each other.
</td></tr><tr><td><b><nobr>Bounce Combine Mode</nobr></b></td><td> How the bouncyness of two colliding objects is combined.
</td></tr><tr><td><b><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Average</nobr></b></td><td> The two values are averaged.
</td></tr><tr><td><b><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Min</nobr></b></td><td> The smallest of the two values is used.
</td></tr><tr><td><b><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Max</nobr></b></td><td> The largest of the two values is used.
</td></tr><tr><td><b><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Multiply</nobr></b></td><td> The values are multiplied with each other.
</td></tr><tr><td><b><nobr>Friction Direction 2</nobr></b></td><td> The direction of anisotropy. Anisotropic friction is enabled if the vector3 is not zero. Dynamic Friction 2 and Static Friction 2 will be applied along Friction Direction 2.
</td></tr><tr><td><b><nobr>Dynamic Friction 2</nobr></b></td><td> If anisotropic friction is enabled, dynamicFriction2 will be applied along Friction Direction 2.
</td></tr><tr><td><b><nobr>Static Friction 2</nobr></b></td><td> If anisotropic friction is enabled, staticFriction2 will be applied along Friction Direction 2.
</td></tr><tr><td><b><nobr>Static Friction 2</nobr></b></td><td> If anisotropic friction is enabled, staticFriction2 will be applied along Friction Direction 2.
</td></tr><tr><td><b><nobr>Use Spring</nobr></b></td><td> If use Spring is checked, surface will be springy.
</td></tr><tr><td><b><nobr>Spring</nobr></b></td><td> The spring of the surface
</td></tr><tr><td><b><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring</nobr></b></td><td> The spring coefficient. A high value will pull the surfaces towards the rest position faster.
</td></tr><tr><td><b><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Damper</nobr></b></td><td> The damper coefficient. A high value will dampen the relative movement of the two surfaces.
</td></tr><tr><td><b><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Target Position</nobr></b></td><td> The rest position of the spring.
<p></td></tr></tr></table>
</p>

<h2>Details</h2>

<p>Friction is the quantity which prevents surfaces from sliding off each other. This value is critical when trying to stack objects.
Friction comes in two forms, dynamic and static. Static friction is used when the object is lying still. It will prevent the object from starting to move. If a large enough force is applied to the object it will start moving. At this point dynamic friction will come into play. Dynamic friction will now attempt to slow down the object while in contact with another.
</p>

<h2>Hints</h2>
<p><ul><li>
Don't try to use a standard physic material for the main character. Make a customized one and get it perfect.
</li></ul>
</p>
<h1>Hinge Joint</h1>

<p>The Hinge Joint groups together 2 <a href="../Components/class-Rigidbody.html">Rigidbodies</a>, constraining them to move like they are connected by a hinge. It is perfect for doors, but can also be used to model chains, pendulums, etc.
</p>

<!-- #BeginLibraryItem name="/Library/doc-figure.lbi" src="%22images/Physics-9.jpg%22" --><p><table><tr><td><img class="figure" src="images/Physics-9.jpg"></td></tr></table></p><!-- #EndLibraryItem -->
</p>

<p><i>The Hinge Joint</i>
</p>

<h2>Properties</h2>
<table class="reftable"><tr><th>Property:</th><th>Function:</th></tr><tr><td><b><nobr>
Connected Body</nobr></b></td><td> Optional reference to the Rigidbody that the joint is dependent upon. If not set, the joint connects to the world.
</td></tr><tr><td><b><nobr>Anchor</nobr></b></td><td> The Position of the anchor around which the body swings. The Position is defined in local space.
</td></tr><tr><td><b><nobr>Axis</nobr></b></td><td> The Direction of the axis around which the body swings. The Axis is defined in local space.
</td></tr><tr><td><b><nobr>Use Spring</nobr></b></td><td> Spring makes the rigid body attempt to stay in a specific angle compared to its connected body.
</td></tr><tr><td><b><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring</nobr></b></td><td> The force the object asserts to move into the position.
</td></tr><tr><td><b><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Damper</nobr></b></td><td> the higher this value, the more the object will slow down.
</td></tr><tr><td><b><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Target Position</nobr></b></td><td> Target angle of the spring. The spring pulls towards this angle measured in degrees.
</td></tr><tr><td><b><nobr>Use Motor</nobr></b></td><td> The motor makes the object spin around.
</td></tr><tr><td><b><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Target Velocity</nobr></b></td><td> The speed the object tries to attain.
</td></tr><tr><td><b><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Force</nobr></b></td><td> The force applied in order to attain the speed.
</td></tr><tr><td><b><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Free Spin</nobr></b></td><td> If enabled, the motor is never used to brake the spinning, only accelerate it.
</td></tr><tr><td><b><nobr>Use Limits</nobr></b></td><td> If enabled, the angle of the hinge will be restricted within the <b>Min</b> &amp; <b>Max</b> values.
</td></tr><tr><td><b><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Min</nobr></b></td><td> The lowest angle the rotation can go.
</td></tr><tr><td><b><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Max</nobr></b></td><td> The highest angle the rotation can go.
</td></tr><tr><td><b><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Min Bounce</nobr></b></td><td> How much the object bounces when it hits the minimum stop.
</td></tr><tr><td><b><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Max Bounce</nobr></b></td><td> How much the object bounces when it hits the maximum stop.
</td></tr><tr><td><b><nobr>Break Force</nobr></b></td><td> The force that needs to be applied for this joint to break.
</td></tr><tr><td><b><nobr>Break Torque</nobr></b></td><td> The torque that needs to be applied for this joint to break.
<p></td></tr></tr></table>
</p>

<h2>Details</h2>

<p>A single Hinge Joint should be applied to an object per desired hinge.  The hinge will rotate at the point specified by the <b>Anchor</b> property, moving around the specified <b>Axis</b> property.  You DO NOT need to assign a Game Object to the joint's <b>Connected Body</b> property.  You should only assign a Game Object to the <b>Connected Body</b> property if you want the joint's Transform to be dependent on the attached object's Transform.
</p>

<p>Think about how the hinge of a door works. The <b>Axis</b> in this case is up, positive along the Y axis. The <b>Anchor</b> is placed somewhere at the intersection between door and wall.  You would not need to assign the wall to the <b>Connected Body</b>, because the joint will be connected to the world by default.
</p>

<!-- #BeginLibraryItem name="/Library/doc-figure.lbi" src="%22images/Physics-10.jpg%22" --><p><table><tr><td><img class="figure" src="images/Physics-10.jpg"></td></tr></table></p><!-- #EndLibraryItem -->
</p>

<p><i>A practical Hinge Joint with no <b>Connected Body</b></i>
</p>

<p>Now think about a doggy door hinge. The doggy door's <b>Axis</b> would be sideways, positive along the relative X axis.  The main door should be assigned as the <b>Connected Body</b>, so the doggy door's hinge is dependent on the main door's Transform.
</p>

<!-- #BeginLibraryItem name="/Library/doc-figure.lbi" src="%22images/Physics-11.jpg%22" --><p><table><tr><td><img class="figure" src="images/Physics-11.jpg"></td></tr></table></p><!-- #EndLibraryItem -->
</p>

<p><i>A practical Hinge Joint with a proper <b>Connected Body</b></i>
</p>


<h3>Chains</h3>

<p>Multiple Hinge Joints can also be strung together to create a chain.  Add a joint to each link in the chain, and attach the next link as a <b>Connected Body</b>.  The result should be similar to the following picture.
</p>

<!-- #BeginLibraryItem name="/Library/doc-figure.lbi" src="%22images/Physics-12.jpg%22" --><p><table><tr><td><img class="figure" src="images/Physics-12.jpg"></td></tr></table></p><!-- #EndLibraryItem -->
</p>

<p><i>A Nunchaku made exclusively with primitives and Hinge Joints</i>
</p>

<h3>Vehicles</h3>

<p>Hinge Joints can be implemented as axles on vehicles, as seen here in Forest Johnson's racing game. However, it's often better just to use a <a href="../Components/class-WheelCollider.html">Wheel Collider</a> for vehicles.
</p>

<!-- #BeginLibraryItem name="/Library/doc-figure.lbi" src="%22images/Physics-13.jpg%22" --><p><table><tr><td><img class="figure" src="images/Physics-13.jpg"></td></tr></table></p><!-- #EndLibraryItem -->
</p>

<h2>Hints</h2>
<p><ul><li>
You do not need to assign a <b>Connected Body</b> to your joint for it to work.
</li><li>Use <b>Break Force</b> in order to make dynamic damage systems. This is really cool as it allows the player to break a door off its hinge by blasting it with a rocket launcher or running into it with a car.
</li><li>The <b>Spring</b>, <b>Motor</b>, and <b>Limits</b> properties allow you to fine-tune your joint's behaviors.
</li></ul>
</p>






		<div class="navigation"><a href="Game Logic.html"><img src="../images/prev.png">Previous</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="Animation.html">Next<img src="../images/next.png"></a></div>
		<!-- #TemplateEndEditable -->	
	</div>
</div>
</body></html>
<!-- #EndTemplate -->
