<!-- #BeginTemplate "/Templates/manual-page.dwt" --><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<!-- #TemplateBeginEditable name="doctitle" -->
		<title>Unity - Physics</title>
	<!-- #TemplateEndEditable -->
</head>
<link rel="StyleSheet"  href="../Images/docs.css" type="text/css" />
<body onLoad="DocLoaded();">
<table class="titlebar" cellpadding=0 cellspacing=0 border=0><tr>
	<td class="titleleft"><img src="../Images/top/left.png"></td>
	<td><a href="../../Documentation.html"><img src="../Images/top/logo.png"></a></td>
	<td class="titlemid">
		<table><tr>
			<td class="doctitle">Physics</td>
			<td><table align="right"><tr>
			<!-- #TemplateBeginEditable name="sections-nav" -->
			<td class="Manual"><a href="../Manual/index.html" title="Go to Unity manual" class="scripting-anchor"><img src="../Images/spacer.gif" class="manual" border="0"><span class="manual-text">Manual</span></a><span class="docs-navigation">&nbsp;&nbsp;&nbsp;&nbsp;</span></td>
			<td class="Manual"><a href="../Components/index.html" title="Go to Reference" class="scripting-anchor"><img src="../Images/spacer.gif" class="reference" border="0"><span class="components-text">Reference</span></a><span class="docs-navigation">&nbsp;&nbsp;&nbsp;&nbsp;</span></td>
			<td class="Manual"><a href="../ScriptReference/index.html" title="Go to Scripting Reference" class="scripting-anchor"><img src="../Images/spacer.gif" class="scripting" border="0"><span class="scripting-text">Scripting &nbsp;&nbsp;</span></a></td>
			<!-- #TemplateEndEditable -->	
			</tr></table></td>
		</tr><tr>
			<td colspan="4">
				<table width="100%" class="docpath"><tr><td >
		<!-- #TemplateBeginEditable name="path" -->
					<a href="../Manual/index.html">Unity Manual</a> &gt; <a href="../Manual/User Guide.html">User Guide</a> &gt; <a href="../Manual/Creating Gameplay.html">Creating Gameplay</a> &gt; <a href="../Manual/Physics.html">Physics</a>
		<!-- #TemplateEndEditable -->	
				</td>
				</td><td class="switchlink">
					<!-- #TemplateBeginEditable name="switchLink" -->
					<!--BeginSwitchLink--><!--EndSwitchLink-->
					<!-- #TemplateEndEditable -->	
				</td></tr></table>
			</td>
		</tr></table>
	</td>
	<td class="titleright" width="9"><img src="../Images/top/right.png"></td>
</tr></table>
<div class="manual">
	<div class="main">

		<!-- #TemplateBeginEditable name="navigation" -->
		<div class="nav">  </div>
		<!-- #TemplateEndEditable -->	
		<!-- #TemplateBeginEditable name="title" -->
			<h1>Physics</h1>
		<!-- #TemplateEndEditable -->	
		<!-- #TemplateBeginEditable name="body" -->
			
<p>Unity has NVIDIA PhysX physics engine built-in. This allows for unique emergent behaviour and is generally very cool.
</p>
<div class='vspace'></div><h2>Basics</h2>
<p>To put an object under physics control, simply add a <span class='doc-keyword'>Rigidbody</span> to it. When you do this, the object will be affected by gravity, and can collide with other objects in the world.
</p>
<div class='vspace'></div><h3>Rigidbodies</h3>
<p><a href="../Components/class-Rigidbody.html">Rigidbodies</a> are physically simulated objects. You use Rigidbodies for things that the player can push around, eg. crates or loose objects, or you can move Rigidbodies around directly by adding forces to it by scripting.
</p>
<p class='vspace'>If you move the Transform of a non-Kinematic Rigidbody directly it may not collide correctly with other objects. Instead you should move a Rigidbody by applying forces and torque to it. You can also add <a href="../Components/class-HingeJoint.html">Joints</a> to rigidbodies to make the behavior more complex. For example, you could make a physical door or a crane with a swinging chain.
</p>
<p class='vspace'>You also use Rigidbodies to bring vehicles to life, for example you can make cars using a Rigidbody, 4 <a href="../Components/class-WheelCollider.html">Wheel Colliders</a> and a script applying wheel forces based on the user's <a href="../Components/class-InputManager.html">Input</a>.
</p>
<p class='vspace'>You can make airplanes by applying forces to the Rigidbody from a script. Or you can create special vehicles or robots by adding various Joints and applying forces via scripting.
</p>
<p class='vspace'>Rigidbodies are most often used in combination with <a href="../Components/class-BoxCollider.html">primitive colliders</a>.
</p>
<p class='vspace'><b>Tips:</b>
</p><ul><li>You should never have a parent and child rigidbody together
</li><li>You should never scale the parent of a rigidbody
</li></ul><div class='vspace'></div><h3>Kinematic Rigidbodies</h3>
<p>A <span class='doc-keyword'>Kinematic Rigidbody</span> is a Rigidbody that has the isKinematic option enabled. Kinematic Rigidbodies are not affected by forces, gravity or collisions. They are driven explicitly by setting the position and rotation of the Transform or animating them, yet they can interact with other non-Kinematic Rigidbodies.
</p>
<p class='vspace'>Kinematic Rigidbodies correctly <a href="../Components/RigidbodySleeping.html">wake up</a> other Rigidbodies when they collide with them, and they apply friction to Rigidbodies placed on top of them.
</p>
<p class='vspace'>These are a few example uses for Kinematic Rigidbodies:
</p>
<div class='vspace'></div><ol><li>Sometimes you want an object to be under physics control but in another situation to be controlled explicitly from a script or animation. For example you could make an animated character whose bones have Rigidbodies attached that are connected with joints for use as a Ragdoll. Most of the time the character is under animation control, thus you make the Rigidbody Kinematic. But when he gets hit you want him to turn into a Ragdoll and be affected by physics. To accomplish this, you simply disable the isKinematic property.
</li><li>Sometimes you want a moving object that can push other objects yet not be pushed itself. For example if you have an animated platform and you want to place some Rigidbody boxes on top, you should make the platform a Kinematic Rigidbody instead of just a <span class='doc-keyword'>Collider</span> without a Rigidbody.
</li><li>You might want to have a Kinematic Rigidbody that is animated and have a real Rigidbody follow it using one of the available Joints.
</li></ol><div class='vspace'></div><h3>Static Colliders</h3>
<p>A <span class='doc-keyword'>Static Collider</span> is a GameObject that has a Collider but not a Rigidbody. Static Colliders are used for level geometry which always stays at the same place and never moves around. You can add a <span class='doc-keyword'>Mesh Collider</span> to your already existing graphical meshes (even better use the <span class='doc-menu'>Import Settings</span> Generate Colliders check box), or you can use one of the other Collider types.
</p>
<p class='vspace'>You should never move a Static Collider on a frame by frame basis. Moving Static Colliders will cause an internal recomputation in PhysX that is quite expensive and which will result in a big drop in performance. On top of that the behaviour of waking up other Rigidbodies based on a Static Collider is undefined, and moving Static Colliders will not apply friction to Rigidbodies that touch it. Instead, Colliders that move should always be Kinematic Rigidbodies.
</p>
<div class='vspace'></div><h3>Character Controllers</h3>
<p>You use <a href="../Components/class-CharacterController.html">Character Controllers</a> if you want to make a humanoid character. This could be the main character in a third person platformer, FPS shooter or any enemy characters.
</p>
<p class='vspace'>These Controllers don't follow the rules of physics since it will not feel right (in Doom you run 90 miles per hour, come to halt in one frame and turn on a dime). Instead, a Character Controller performs collision detection to make sure your characters can slide along walls, walk up and down stairs, etc.
</p>
<p class='vspace'>Character Controllers are not affected by forces but they can push Rigidbodies by applying forces to them from a script. Usually, all humanoid characters are implemented using Character Controllers.
</p>
<p class='vspace'>Character Controllers are inherently unphysical, thus if you want to apply real physics - Swing on ropes, get pushed by big rocks - to your character you have to use a Rigidbody, this will let you use joints and forces on your character. Character Controllers are always aligned along the Y axis, so you also need to use a Rigidbody if your character needs to be able to change orientation in space (for example under a changing gravity). However, be aware that tuning a Rigidbody to feel right for a character is hard due to the unphysical way in which game characters are expected to behave. Another difference is that Character Controllers can slide smoothly over steps of a specified height, while Rigidbodies will not.
</p>
<p class='vspace'>If you parent a Character Controller with a Rigidbody you will get a "Joint" like behavior.
</p>
<div class='vspace'></div><h1>Rigidbody</h1>
<p><span class='doc-keyword'>Rigidbodies</span> enable your <span class='doc-keyword'>GameObjects</span> to act under the control of physics. The Rigidbody can receive forces and torque to make your objects move in a realistic way.  Any GameObject must contain a Rigidbody to be influenced by gravity, act under added forces via scripting, or interact with other objects through the NVIDIA PhysX physics engine.
</p>
<div class='vspace'></div><div><img class='figure' src='../Images/manual/Physics-0.jpg' /><br /><em>Rigidbodies allow GameObjects to act under physical influence</em></div>
<div class='vspace'></div><h2>Properties</h2>
<table width='100%'><tr class='tableheader'><td  class='prop'></td><td class='function'></td></tr>
<tr ><td  align='left'><span class='doc-prop'>Mass</span></td><td  align='left'>The mass of the object (arbitrary units). It is recommended to make masses not more or less than 100 times that of other Rigidbodies.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Drag</span></td><td  align='left'>How much air resistance affects the object when moving from forces. 0 means no air resistance, and infinity makes the object stop moving immediately.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Angular Drag</span></td><td  align='left'>How much air resistance affects the object when rotating from torque. 0 means no air resistance, and infinity makes the object stop rotating immediately.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Use Gravity</span></td><td  align='left'>If enabled, the object is affected by gravity.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Is Kinematic</span></td><td  align='left'>If enabled, the object will not be driven by the physics engine, and can only be manipulated by its <span class='doc-keyword'>Transform</span>. This is useful for moving platforms or if you want to animate a Rigidbody that has a <span class='doc-keyword'>HingeJoint</span> attached.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Interpolate</span></td><td  align='left'>Try one of the options only if you are seeing jerkiness in your Rigidbody's movement.</td></tr>
<tr ><td  align='left'><span  style='padding-left: 1.5em;'><span class='doc-prop'>None</span></span></td><td  align='left'>No Interpolation is applied.</td></tr>
<tr ><td  align='left'><span  style='padding-left: 1.5em;'><span class='doc-prop'>Interpolate</span></span></td><td  align='left'>Transform is smoothed based on the Transform of the previous frame.</td></tr>
<tr ><td  align='left'><span  style='padding-left: 1.5em;'><span class='doc-prop'>Extrapolate</span></span></td><td  align='left'>Transform is smoothed based on the estimated Transform of the next frame.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Freeze Rotation</span></td><td  align='left'>If enabled, this GameObject will never rotate based on collisions or forces added via script -- it will only rotate when using <span class='doc-prop'>transform.Rotate()</span>.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Collision Detection</span></td><td  align='left'>Used to prevent fast moving objects from passing through other objects without detecting collisions.</td></tr>
<tr ><td  align='left'><span  style='padding-left: 1.5em;'><span class='doc-prop'>Discrete</span></span></td><td  align='left'>Use Discreet collision detection against all other colliders in the scene. Other colliders will use Discreet collision detection when testing for collision against it. Used for normal collisions (This is the default value).</td></tr>
<tr ><td  align='left'><span  style='padding-left: 1.5em;'><span class='doc-prop'>Continuous</span></span></td><td  align='left'>Use Discrete collision detection against dynamic colliders (with a rigidbody) and continuous collision detection against static MeshColliders (without a rigidbody). Rigidbodies set to Continuous Dynamic will use continuous collision detection when testing for collision against this rigidbody. Other rigidbodies will use Discreet Collision detection. Used for objects which the Continuous Dynamic detection needs to collide with. (This has a big impact on physics performance, leave it set to Discrete, if you don't have issues with collisions of fast objects)</td></tr>
<tr ><td  align='left'><span  style='padding-left: 1.5em;'><span class='doc-prop'>Continuous Dynamic</span></span></td><td >Use continuous collision detection against objects set to Continuous and Continuous Dynamic Collision. It will also use continuous collision detection against static MeshColliders (without a rigidbody). For all other colliders it uses discreet collision detection. Used for fast moving objects.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Constraints</span></td><td >Restrictions on the Rigidbody's motion:-</td></tr>
<tr ><td ><span  style='padding-left: 1.5em;'><span class='doc-prop'>Freeze Position</span></span></td><td >Stops the Rigidbody moving in the world X, Y and Z axes selectively.</td></tr>
<tr ><td ><span  style='padding-left: 1.5em;'><span class='doc-prop'>Freeze Rotation</span></span></td><td >Stops the Rigidbody rotating around the world X, Y and Z axes selectively.</td></tr>
</table>
<div class='vspace'></div><h2>Details</h2>
<p>Rigidbodies allow your GameObjects to act under control of the physics engine.  This opens the gateway to realistic collisions, varied types of joints, and other very cool behaviors.  Manipulating your GameObjects by adding forces to a Rigidbody creates a very different feel and look than adjusting the Transform <span class='doc-keyword'>Component</span> directly.  Generally, you shouldn't manipulate the Rigidbody and the Transform of the same GameObject - only one or the other.
</p>
<p class='vspace'>The biggest difference between manipulating the Transform versus the Rigidbody is the use of forces.  Rigidbodies can receive forces and torque, but Transforms cannot.  Transforms can be translated and rotated, but this is not the same as using physics. You'll notice the distinct difference when you try it for yourself.  Adding forces/torque to the Rigidbody will actually change the object's position and rotation of the Transform component.  This is why you should only be using one or the other.  Changing the Transform while using physics could cause problems with collisions and other calculations.
</p>
<p class='vspace'>Rigidbodies must be explicitly added to your GameObject before they will be affected by the physics engine.  You can add a Rigidbody to your selected object from <span class='doc-prop'>Components-&gt;Physics-&gt;Rigidbody</span> in the menubar. Now your object is physics-ready; it will fall under gravity and can receive forces via scripting, but you may need to add a <span class='doc-keyword'>Collider</span> or a Joint to get it to behave exactly how you want.
</p>
<div class='vspace'></div><h3>Parenting</h3>
<p>When an object is under physics control, it moves semi-independently of the way its transform parents move. If you move any parents, they will pull the Rigidbody child along with them. However, the Rigidbodies will still fall down due to gravity and react to collision events.
</p>
<div class='vspace'></div><h3>Scripting</h3>
<p>To control your Rigidbodies, you will primarily use scripts to add forces or torque. You do this by calling <span class='doc-prop'><a class='urllink' href='../ScriptReference/Rigidbody.AddForce.html' rel='nofollow'>AddForce()</a></span> and <span class='doc-prop'><a class='urllink' href='../ScriptReference/Rigidbody.AddTorque.html' rel='nofollow'>AddTorque()</a></span> on the object's Rigidbody.  Remember that you shouldn't be directly altering the object's Transform when you are using physics.
</p>
<div class='vspace'></div><h3>Animation</h3>
<p>For some situations, mainly creating ragdoll effects, it is neccessary to switch control of the object between animations and physics. For this purpose Rigidbodies can be marked <span class='doc-prop'><a class='urllink' href='../ScriptReference/Rigidbody-isKinematic.html' rel='nofollow'>isKinematic</a></span>. While the Rigidbody is marked <span class='doc-prop'>isKinematic</span>, it will not be affected by collisions, forces, or any other part of physX. This means that you will have to control the object by manipulating the <a href="../Components/class-Transform.html">Transform</a> component directly.  Kinematic Rigidbodies will affect other objects, but they themselves will not be affected by physics. For example, Joints which are attached to Kinematic objects will constrain any other Rigidbodies attached to them and Kinematic Rigidbodies will affect other Rigidbodies through collisions.
</p>
<div class='vspace'></div><h3>Colliders</h3>
<p>Colliders are another kind of component that must be added alongside the Rigidbody in order to allow collisions to occur.  If two Rigidbodies bump into each other, the physics engine will not calculate a collision unless both objects also have a Collider attached.  Collider-less Rigidbodies will simply pass through each other during physics simulation.
</p>
<div class='vspace'></div><div><img class='figure' src='../Images/manual/Physics-1.jpg' /><br /><em>Colliders define the physical boundaries of a Rigidbody</em></div>
<p class='vspace'>Add a Collider with the <span class='doc-prop'>Component-&gt;Physics</span> menu.  View the Component Reference page of any individual Collider for more specific information:
</p><ul><li><a href="../Components/class-BoxCollider.html">Box Collider</a> - primitive shape of a cube
</li><li><a href="../Components/class-SphereCollider.html">Sphere Collider</a> - primitive shape of a sphere
</li><li><a href="../Components/class-CapsuleCollider.html">Capsule Collider</a> - primitive shape of a capsule
</li><li><a href="../Components/class-MeshCollider.html">Mesh Collider</a> - creates a collider from the object's mesh, cannot collide with another Mesh Collider
</li><li><a href="../Components/class-WheelCollider.html">Wheel Collider</a> - specifically for creating cars or other moving vehicles
</li></ul><div class='vspace'></div><h3>Compound Colliders</h3>
<p>Compound Colliders are combinations of primitive Colliders, collectively acting as a single Collider.  They come in handy when you have a complex mesh to use in collisions but cannot use a <span class='doc-keyword'>Mesh Collider</span>.  To create a Compound Collider, create child objects of your colliding object, then add a primitive Collider to each child object.  This allows you to position, rotate, and scale each Collider easily and independently of one another.
</p>
<div class='vspace'></div><div><img class='figure' src='../Images/manual/Physics-2.jpg' /><br /><em>A real-world Compound Collider setup</em></div>
<p class='vspace'>In the above picture, the environment has a Mesh Collider attached.  Mesh Colliders work the best for terrain or environments made from irregular shapes. The <span class='doc-menu'>gun_model</span> GameObject has a Rigidbody attached, and multiple primitive Colliders as child GameObjects. When the Rigidbody parent is moved around by forces, the child Colliders move along with it. The primitive Colliders will collide with the environment's Mesh Collider, and the parent Rigidbody will alter the way it moves based on forces being applied to it and how its child Colliders interact with other Colliders in the Scene.
</p>
<p class='vspace'>Mesh Colliders can't normally collide with each other.  If a Mesh Collider is marked as <span class='doc-prop'>Convex</span>, then it can collide with another Mesh Collider.  The typical solution is to use primitive Colliders for any objects that move, and Mesh Colliders for static background objects.
</p>
<div class='vspace'></div><h3>Continuous Collision Detection</h3>
<p>Continuous collision detection is a feature to prevent fast-moving colliders from passing each other. This may happen when using normal (<span class='doc-prop'>Discrete</span>) collision detection, when an object is one side of a collider in one frame, and already passed the collider in the next frame. To solve this, you can enable continuous collision detection on the rigidbody of the fast-moving object. Set the collision detection mode to <span class='doc-prop'>Continuous</span> to prevent the rigidbody from passing through any static (ie, non-rigidbody) MeshColliders. Set it to <span class='doc-prop'>Continuous Dynamic</span> to also prevent the rigidbody from passing through any other supported rigidbodies with collision detection mode set to <span class='doc-prop'>Continuous</span> or <span class='doc-prop'>Continuous Dynamic</span>. 
Continuous collision detection is supported for Box-, Sphere- and CapsuleColliders.
</p>
<div class='vspace'></div><h2>Use the right size</h2>
<p>The size of the your GameObject's mesh is much more important than the mass of the Rigidbody.  If you find that your Rigidbody is not behaving exactly how you expect - it moves slowly, floats, or doesn't collide correctly - consider adjusting the scale of your mesh asset.  Unity's default unit scale is 1 unit = 1 meter, so the scale of your imported mesh is maintained, and applied to physics calculations.  For example, a crumbling skyscraper is going to fall apart very differently than a tower made of toy blocks, so objects of different sizes should be modeled to accurate scale.
</p>
<p class='vspace'>If you are modeling a human make sure he is around 2 meters tall in Unity. To check if your object has the right size compare it to the default cube. You can create a cube using <span class='doc-menu'>GameObject-&gt;Create Other-&gt;Cube</span>. The cube's height will be exactly 1 meter, so your human should be twice as tall.
</p>
<p class='vspace'>If you aren't able to adjust the mesh itself, you can change the uniform scale of a particular mesh asset by selecting it in <span class='doc-keyword'>Project View</span> and choosing <span class='doc-menu'>Assets-&gt;Import Settings...</span> from the menubar.  Here, you can change the scale and re-import your mesh.
</p>
<p class='vspace'>If your game requires that your GameObject needs to be instantiated at different scales, it is okay to adjust the values of your Transform's scale axes.  The downside is that the physics simulation must do more work at the time the object is instantiated, and could cause a performance drop in your game.  This isn't a terrible loss, but it is not as efficient as finalizing your scale with the other two options.  Also keep in mind that non-uniform scales can create undesirable behaviors when Parenting is used.  For these reasons it is always optimal to create your object at the correct scale in your modeling application.
</p>
<div class='vspace'></div><h2>Hints</h2>
<ul><li>The relative <span class='doc-prop'>Mass</span> of two Rigidbodies determines how they react when they collide with each other.
</li><li>Making one Rigidbody have greater <span class='doc-prop'>Mass</span> than another does not make it fall faster in free fall. Use <span class='doc-prop'>Drag</span> for that.
</li><li>A low <span class='doc-prop'>Drag</span> value makes an object seem heavy. A high one makes it seem light. Typical values for <span class='doc-prop'>Drag</span> are between .001 (solid block of metal) and 10 (feather).
</li><li>If you are directly manipulating the Transform component of your object but still want physics, attach a Rigidbody and make it Kinematic.
</li><li>If you are moving a GameObject through its Transform component but you want to receive Collision/Trigger messages, you must attach a Rigidbody to the object that is moving.
</li></ul><h1>Constant Force</h1>
<p><span class='doc-keyword'>Constant Force</span> is a quick utility for adding constant forces to a <span class='doc-keyword'>Rigidbody</span>.  This works great for one shot objects like rockets, if you don't want it to start with a large velocity but instead accelerate.
</p>
<div class='vspace'></div><div><img class='figure' src='../Images/manual/Physics-3.jpg' /><br /><em>A rocket propelled forward by a Constant Force</em></div>
<div class='vspace'></div><h2>Properties</h2>
<table width='100%'><tr class='tableheader'><td  class='prop'></td><td class='function'></td></tr>
<tr ><td  align='left'><span class='doc-prop'>Force</span></td><td  align='left'>The vector of a force to be applied in world space.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Relative Force</span></td><td  align='left'>The vector of a force to be applied in the object's local space.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Torque</span></td><td  align='left'>The vector of a torque, applied in world space. The object will begin spinning <em>around</em> this vector. The longer the vector is, the faster the rotation.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Relative Torque</span></td><td  align='left'>The vector of a torque, applied in local space. The object will begin spinning <em>around</em> this vector. The longer the vector is, the faster the rotation.</td></tr>
</table>
<div class='vspace'></div><h3>Details</h3>
<p>To make a rocket that accelerates forward set the <span class='doc-prop'>Relative Force</span> to be along the positive z-axis. Then use the Rigidbody's <span class='doc-prop'>Drag</span> property to make it not exceed some maximum velocity (the higher the drag the lower the maximum velocity will be). In the Rigidbody, also make sure to turn off gravity so that the rocket will always stay on its path.
</p>
<div class='vspace'></div><h2>Hints</h2>
<ul><li>To make an object flow upwards, add a Constant Force with the <span class='doc-prop'>Force</span> property having a positive Y value.
</li><li>To make an object fly forwards, add a Constant Force with the <span class='doc-prop'>Relative Force</span> property having a positive Z value.
</li></ul><h1>Sphere Collider</h1>
<p>The <span class='doc-keyword'>Sphere Collider</span> is a basic sphere-shaped collision primitive.
</p>
<div class='vspace'></div><div><img class='figure' src='../Images/manual/Physics-4.jpg' /><br /><em>A pile of Sphere Colliders</em></div>
<div class='vspace'></div><h2>Properties</h2>
<table width='100%'><tr class='tableheader'><td  class='prop'></td><td class='function'></td></tr>
<tr ><td  align='left'><span class='doc-prop'>Material</span></td><td  align='left'>Reference to the <a href="../Components/class-PhysicMaterial.html">Physic Material</a> that determines how this Collider interacts with others.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Is Trigger</span></td><td  align='left'>If enabled, this Collider is used for triggering events, and is ignored by the physics engine.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Radius</span></td><td  align='left'>The size of the Collider.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Center</span></td><td  align='left'>The position of the Collider in the object's local space.</td></tr>
</table>
<div class='vspace'></div><h2>Details</h2>
<p>The Sphere Collider can be resized to uniform scale, but not along individual axes. It works great for falling boulders, ping pong balls, marbles, etc.
</p>
<div class='vspace'></div><div><img class='figure' src='../Images/manual/Physics-5.jpg' /></div>
<p><em>A standard Sphere Collider</em>
</p>
<p class='vspace'>Colliders work with Rigidbodies to bring physics in Unity to life.  Whereas Rigidbodies allow objects to be controlled by physics, Colliders allow objects to collide with each other.  Colliders must be added to objects independently of Rigidbodies.  A Collider does not necessarily need a Rigidbody attached, but a Rigidbody <b>must</b> be attached in order for the object to move as a result of collisions.
</p>
<p class='vspace'>When a collision between two Colliders occurs and if at least one of them has a Rigidbody attached, <a class='urllink' href='../ScriptReference/Collider.OnCollisionEnter.html' rel='nofollow'>three</a> <a class='urllink' href='../ScriptReference/Collider.OnCollisionExit.html' rel='nofollow'>collision</a> <a class='urllink' href='../ScriptReference/Collider.OnCollisionStay.html' rel='nofollow'>messages</a> are sent out to the objects attached to them. These events can be handled in scripting, and allow you to create unique behaviors with or without making use of the built-in NVIDIA PhysX engine.
</p>
<div class='vspace'></div><h3>Triggers</h3>
<p>An alternative way of using Colliders is to mark them as a <span class='doc-keyword'>Trigger</span>, just check the IsTrigger property checkbox in the Inspector.  Triggers are effectively ignored by the physics engine, and have a unique set of <a class='urllink' href='../ScriptReference/Collider.OnTriggerEnter.html' rel='nofollow'>three</a> <a class='urllink' href='../ScriptReference/Collider.OnTriggerExit.html' rel='nofollow'>trigger</a> <a class='urllink' href='../ScriptReference/Collider.OnTriggerStay.html' rel='nofollow'>messages</a> that are sent out when a collision with a Trigger occurs.  Triggers are useful for triggering other events in your game, like cutscenes, automatic door opening, displaying tutorial messages, etc.  Use your imagination!
</p>
<p class='vspace'>Be aware that in order for two Triggers to send out trigger events when they collide, one of them must include a Rigidbody as well. For a Trigger to collide with a normal Collider, one of them must have a Rigidbody attached.  For a detailed chart of different types of collisions, see the collision action matrix in the Advanced section below.
</p>
<div class='vspace'></div><h3>Friction and bouncyness</h3>
<p>Friction, bouncyness and softness are defined in the <a href="../Components/class-PhysicMaterial.html">Physic Material</a>. The <a href="../Manual/HOWTO-InstallStandardAssets.html">Standard Assets</a> contain the most common physics materials. To use one of them click on the Physic Material drop-down and select one, eg. Ice. You can also <a href="../Components/class-PhysicMaterial.html">create</a> your own physics materials and tweak all friction values.
</p>
<div class='vspace'></div><h2>Compound Colliders</h2>
<p>Compound Colliders are combinations of primitive Colliders, collectively acting as a single Collider.  They come in handy when you have a complex mesh to use in collisions but cannot use a <span class='doc-keyword'>Mesh Collider</span>.  To create a Compound Collider, create child objects of your colliding object, then add a primitive Collider to each child object.  This allows you to position, rotate, and scale each Collider easily and independently of one another.
</p>
<div class='vspace'></div><div><img class='figure' src='../Images/manual/Physics-6.jpg' /><br /><em>A real-world Compound Collider setup</em></div>
<p class='vspace'>In the above picture, the environment has a Mesh Collider attached.  Mesh Colliders work the best for terrain or environments made from irregular shapes. The <span class='doc-menu'>gun_model</span> GameObject has a Rigidbody attached, and multiple primitive Colliders as child GameObjects. When the Rigidbody parent is moved around by forces, the child Colliders move along with it. The primitive Colliders will collide with the environment's Mesh Collider, and the parent Rigidbody will alter the way it moves based on forces being applied to it and how its child Colliders interact with other Colliders in the Scene.
</p>
<p class='vspace'>Mesh Colliders can't normally collide with each other.  If a Mesh Collider is marked as <span class='doc-prop'>Convex</span>, then it can collide with another Mesh Collider.  The typical solution is to use primitive Colliders for any objects that move, and Mesh Colliders for static background objects.
</p>
<div class='vspace'></div><h2>Hints</h2>
<ul><li>To add multiple Colliders for an object, create child GameObjects and attach a Collider to each one.  This allows each Collider to be manipulated independently.
</li><li>You can look at the gizmos in the <span class='doc-keyword'>Scene View</span> to see how the Collider is being calculated on your object.
</li><li>Colliders do their best to match the scale of an object. If you have a non-uniform scale (a scale which is different in each direction), only the Mesh Collider can match completely.
</li><li>If you are moving an object through its Transform component but you want to receive Collision/Trigger messages, you must attach a Rigidbody to the object that is moving.
</li><li>If you make an explosion, it can be very effective to add a rigidbody with lots of drag and a sphere collider to it in order to push it out a bit from the wall it hits.
</li></ul><div class='vspace'></div><h2>Advanced</h2>
<div class='vspace'></div><h3>Collider combinations</h3>
<p>There are numerous different combinations of collisions that can happen in Unity.  Each game is unique, and different combinations may work better for different types of games.  If you're using physics in your game, it will be very helpful to understand the different basic Collider types, their common uses, and how they interact with other types of objects.
</p>
<div class='vspace'></div><h4>Static Collider</h4>
<p>These are GameObjects that do <b>not</b> have a Rigidbody attached, but <b>do</b> have a Collider attached.  These objects should remain still, or move very little.  These work great for your environment geometry.  They will not move if a Rigidbody collides with them.
</p>
<div class='vspace'></div><h4>Rigidbody Collider</h4>
<p>These GameObjects contain both a Rigidbody and a Collider.  They are completely affected by the physics engine through scripted forces and collisions.  They might collide with a GameObject that only contains a Collider.  These will likely be your primary type of Collider in games that use physics.
</p>
<div class='vspace'></div><h4>Kinematic Rigidbody Collider</h4>
<p>This GameObject contains a Collider and a Rigidbody which is marked <span class='doc-prop'>IsKinematic</span>.  To move this GameObject, you modify its <a href="../Components/class-Transform.html">Transform</a> Component, rather than applying forces. They're similar to Static Colliders but will work better when you want to move the Collider around frequently.  There are some other specialized scenarios for using this GameObject.
</p>
<p class='vspace'>This object can be used for circumstances in which you would normally want a Static Collider to send a trigger event.  Since a Trigger must have a Rigidbody attached, you should add a Rigidbody, then enable <span class='doc-prop'>IsKinematic</span>.  This will prevent your Object from moving from physics influence, and allow you to receive trigger events when you want to.
</p>
<p class='vspace'>Kinematic Rigidbodies can easily be turned on and off.  This is great for creating ragdolls, when you normally want a character to follow an animation, then turn into a ragdoll when a collision occurs, prompted by an explosion or anything else you choose.  When this happens, simply turn all your Kinematic Rigidbodies into normal Rigidbodies through scripting.
</p>
<p class='vspace'>If you have Rigidbodies come to rest so they are not moving for some time, they will "fall asleep".  That is, they will not be calculated during the physics update since they are not going anywhere.  If you move a Kinematic Rigidbody out from underneath normal Rigidbodies that are at rest on top of it, the sleeping Rigidbodies will "wake up" and be correctly calculated again in the physics update.  So if you have a lot of Static Colliders that you want to move around and have different object fall on them correctly, use Kinematic Rigidbody Colliders.
</p>
<div class='vspace'></div><h3>Collision action matrix</h3>
<p>Depending on the configurations of the two colliding Objects, a number of different actions can occur.  The chart below outlines what you can expect from two colliding Objects, based on the components that are attached to them.  Some of the combinations only cause one of the two Objects to be affected by the collision, so keep the standard rule in mind - physics will not be applied to objects that do not have Rigidbodies attached.
</p>
<div class='vspace'></div>
<table border='2' ><tr ><td  align='center' colspan='7'><b>Collision detection occurs and messages are sent upon collision</b></td></tr>
<tr ><td >&nbsp;</td><td  align='left'>Static Collider</td><td  align='left'>Rigidbody Collider</td><td  align='left'>Kinematic <br clear='all' /> Rigidbody Collider</td><td  align='left'>Static <br clear='all' /> Trigger Collider</td><td  align='left'>Rigidbody <br clear='all' /> Trigger Collider</td><td  align='left'>Kinematic Rigidbody <br clear='all' /> Trigger Collider</td></tr>
<tr ><td  align='left'>Static Collider</td><td >&nbsp;</td><td  align='center'>Y</td><td >&nbsp;</td><td >&nbsp;</td><td >&nbsp;</td><td >&nbsp;</td></tr>
<tr ><td  align='left'>Rigidbody Collider</td><td  align='center'>Y</td><td  align='center'>Y</td><td  align='center'>Y</td><td >&nbsp;</td><td >&nbsp;</td><td >&nbsp;</td></tr>
<tr ><td  align='left'>Kinematic Rigidbody Collider</td><td >&nbsp;</td><td  align='center'>Y</td><td >&nbsp;</td><td >&nbsp;</td><td >&nbsp;</td><td >&nbsp;</td></tr>
<tr ><td  align='left'>Static Trigger Collider</td><td >&nbsp;</td><td >&nbsp;</td><td >&nbsp;</td><td >&nbsp;</td><td >&nbsp;</td><td >&nbsp;</td></tr>
<tr ><td  align='left'>Rigidbody Trigger Collider</td><td >&nbsp;</td><td >&nbsp;</td><td >&nbsp;</td><td >&nbsp;</td><td >&nbsp;</td><td >&nbsp;</td></tr>
<tr ><td  align='left'>Kinematic Rigidbody Trigger Collider</td><td >&nbsp;</td><td >&nbsp;</td><td >&nbsp;</td><td >&nbsp;</td><td >&nbsp;</td><td >&nbsp;</td></tr>
</table>
<div class='vspace'></div>
<table border='2' ><tr ><td  align='center' colspan='7'><b>Trigger messages are sent upon collision</b></td></tr>
<tr ><td >&nbsp;</td><td  align='left'>Static Collider</td><td  align='left'>Rigidbody Collider</td><td  align='left'>Kinematic <br clear='all' /> Rigidbody Collider</td><td  align='left'>Static <br clear='all' /> Trigger Collider</td><td  align='left'>Rigidbody <br clear='all' /> Trigger Collider</td><td  align='left'>Kinematic Rigidbody <br clear='all' /> Trigger Collider</td></tr>
<tr ><td  align='left'>Static Collider</td><td >&nbsp;</td><td >&nbsp;</td><td >&nbsp;</td><td >&nbsp;</td><td  align='center'>Y</td><td  align='center'>Y</td></tr>
<tr ><td  align='left'>Rigidbody Collider</td><td >&nbsp;</td><td >&nbsp;</td><td >&nbsp;</td><td  align='center'>Y</td><td  align='center'>Y</td><td  align='center'>Y</td></tr>
<tr ><td  align='left'>Kinematic Rigidbody Collider</td><td >&nbsp;</td><td >&nbsp;</td><td >&nbsp;</td><td  align='center'>Y</td><td  align='center'>Y</td><td  align='center'>Y</td></tr>
<tr ><td  align='left'>Static Trigger Collider</td><td >&nbsp;</td><td  align='center'>Y</td><td  align='center'>Y</td><td >&nbsp;</td><td  align='center'>Y</td><td  align='center'>Y</td></tr>
<tr ><td  align='left'>Rigidbody Trigger Collider</td><td  align='center'>Y</td><td  align='center'>Y</td><td  align='center'>Y</td><td  align='center'>Y</td><td  align='center'>Y</td><td  align='center'>Y</td></tr>
<tr ><td  align='left'>Kinematic Rigidbody Trigger Collider</td><td  align='center'>Y</td><td  align='center'>Y</td><td  align='center'>Y</td><td  align='center'>Y</td><td  align='center'>Y</td><td  align='center'>Y</td></tr>
</table>
<div class='vspace'></div><h3><a href="../Components/Layer Based Collision detection.html">Layer-Based Collision Detection</a></h3>
<p>In Unity 3.x we introduce something called <span class='doc-keyword'>Layer-Based Collision Detection</span>, and is that you can now selectively tell Unity GameObjects to collide with specific layers they are attached to. For more info, you can click <a href="../Components/Layer Based Collision detection.html">here</a>
</p><h1>Box Collider</h1>
<p>The <span class='doc-keyword'>Box Collider</span> is a basic cube-shaped collision primitive.
</p>
<div class='vspace'></div><div><img class='figure' src='../Images/manual/Physics-7.jpg' /><br /><em>A pile of Box Colliders</em></div>
<div class='vspace'></div><h2>Properties</h2>
<table border='2' ><tr class='tableheader'><td  class='prop'></td><td class='function'></td></tr>
<tr ><td  align='left'><span class='doc-prop'>Material</span></td><td  align='left'>Reference to the <a href="../Components/class-PhysicMaterial.html">Physic Material</a> that determines how this Collider interacts with others.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Is Trigger</span></td><td  align='left'>If enabled, this Collider is used for triggering events, and is ignored by the physics engine.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Size</span></td><td  align='left'>The size of the Collider in the X, Y, Z directions.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Center</span></td><td  align='left'>The position of the Collider in the object's local space.</td></tr>
</table>
<div class='vspace'></div><h2>Details</h2>
<p>The Box Collider can be resized into different shapes of rectangular prisms.  It works great for doors, walls, platforms, etc. It is also effective as a human torso in a ragdoll or as a car hull in a vehicle. Of course, it works perfectly for just boxes and crates as well!
</p>
<div class='vspace'></div><div><img class='figure' src='../Images/manual/Physics-8.jpg' /><br /><em>A standard Box Collider</em></div>
<p class='vspace'>Colliders work with Rigidbodies to bring physics in Unity to life.  Whereas Rigidbodies allow objects to be controlled by physics, Colliders allow objects to collide with each other.  Colliders must be added to objects independently of Rigidbodies.  A Collider does not necessarily need a Rigidbody attached, but a Rigidbody <b>must</b> be attached in order for the object to move as a result of collisions.
</p>
<p class='vspace'>When a collision between two Colliders occurs and if at least one of them has a Rigidbody attached, <a class='urllink' href='../ScriptReference/Collider.OnCollisionEnter.html' rel='nofollow'>three</a> <a class='urllink' href='../ScriptReference/Collider.OnCollisionExit.html' rel='nofollow'>collision</a> <a class='urllink' href='../ScriptReference/Collider.OnCollisionStay.html' rel='nofollow'>messages</a> are sent out to the objects attached to them. These events can be handled in scripting, and allow you to create unique behaviors with or without making use of the built-in NVIDIA PhysX engine.
</p>
<div class='vspace'></div><h3>Triggers</h3>
<p>An alternative way of using Colliders is to mark them as a <span class='doc-keyword'>Trigger</span>, just check the IsTrigger property checkbox in the Inspector.  Triggers are effectively ignored by the physics engine, and have a unique set of <a class='urllink' href='../ScriptReference/Collider.OnTriggerEnter.html' rel='nofollow'>three</a> <a class='urllink' href='../ScriptReference/Collider.OnTriggerExit.html' rel='nofollow'>trigger</a> <a class='urllink' href='../ScriptReference/Collider.OnTriggerStay.html' rel='nofollow'>messages</a> that are sent out when a collision with a Trigger occurs.  Triggers are useful for triggering other events in your game, like cutscenes, automatic door opening, displaying tutorial messages, etc.  Use your imagination!
</p>
<p class='vspace'>Be aware that in order for two Triggers to send out trigger events when they collide, one of them must include a Rigidbody as well. For a Trigger to collide with a normal Collider, one of them must have a Rigidbody attached.  For a detailed chart of different types of collisions, see the collision action matrix in the Advanced section below.
</p>
<div class='vspace'></div><h3>Friction and bouncyness</h3>
<p>Friction, bouncyness and softness are defined in the <a href="../Components/class-PhysicMaterial.html">Physic Material</a>. The <a href="../Manual/HOWTO-InstallStandardAssets.html">Standard Assets</a> contain the most common physics materials. To use one of them click on the Physic Material drop-down and select one, eg. Ice. You can also <a href="../Components/class-PhysicMaterial.html">create</a> your own physics materials and tweak all friction values.
</p><h1>Mesh Collider</h1>
<p>The <span class='doc-keyword'>Mesh Collider</span> takes a <a href="../Components/class-Mesh.html">Mesh Asset</a> and builds its Collider based on that mesh.  It is far more accurate for collision detection than using primitives for complicated meshes.  Mesh Colliders that are marked as <span class='doc-prop'>Convex</span> can collide with other Mesh Colliders.
</p>
<div class='vspace'></div><div><img class='figure' src='../Images/manual/Physics-9.jpg' /><br /><em>A Mesh Collider used on level geometry</em></div>
<div class='vspace'></div><h2>Properties</h2>
<table border='2' ><tr class='tableheader'><td  class='prop'></td><td class='function'></td></tr>
<tr ><td  align='left'><span class='doc-prop'>Material</span></td><td  align='left'>Reference to the <a href="../Components/class-PhysicMaterial.html">Physic Material</a> that determines how this Collider interacts with others.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Is Trigger</span></td><td  align='left'>If enabled, this Collider is used for triggering events, and is ignored by the physics engine.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Mesh</span></td><td  align='left'>Reference to the Mesh to use for collisions.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Smooth Sphere Collisions</span></td><td  align='left'>When this is enabled, collision mesh normals are smoothed. You should enable this on smooth surfaces eg. rolling terrain without hard edges to make sphere rolling smoother.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Convex</span></td><td  align='left'>If enabled, this Mesh Collider will collide with other Mesh Colliders. Convex Mesh Colliders are limited to 255 triangles.</td></tr>
</table>
<div class='vspace'></div><h2>Details</h2>
<p>The Mesh Collider builds its collision representation from the <a href="../Components/class-Mesh.html">Mesh</a> attached to the GameObject, and reads the properties of the attached <a href="../Components/class-Transform.html">Transform</a> to set its position and scale correctly.
</p>
<p class='vspace'>Collision meshes use backface culling. If an object collides with a mesh that will be backface culled graphically it will also not collide with it physically.
</p>
<p class='vspace'>There are some limitations when using the Mesh Collider.  Usually, two Mesh Colliders cannot collide with each other.  All Mesh Colliders can collide with any primitive Collider.  If your mesh is marked as <span class='doc-prop'>Convex</span>, then it can collide with other Mesh Colliders.
</p>
<p class='vspace'>Colliders work with Rigidbodies to bring physics in Unity to life.  Whereas Rigidbodies allow objects to be controlled by physics, Colliders allow objects to collide with each other.  Colliders must be added to objects independently of Rigidbodies.  A Collider does not necessarily need a Rigidbody attached, but a Rigidbody <b>must</b> be attached in order for the object to move as a result of collisions.
</p>
<p class='vspace'>When a collision between two Colliders occurs and if at least one of them has a Rigidbody attached, <a class='urllink' href='../ScriptReference/Collider.OnCollisionEnter.html' rel='nofollow'>three</a> <a class='urllink' href='../ScriptReference/Collider.OnCollisionExit.html' rel='nofollow'>collision</a> <a class='urllink' href='../ScriptReference/Collider.OnCollisionStay.html' rel='nofollow'>messages</a> are sent out to the objects attached to them. These events can be handled in scripting, and allow you to create unique behaviors with or without making use of the built-in NVIDIA PhysX engine.
</p>
<div class='vspace'></div><h3>Triggers</h3>
<p>An alternative way of using Colliders is to mark them as a <span class='doc-keyword'>Trigger</span>, just check the IsTrigger property checkbox in the Inspector.  Triggers are effectively ignored by the physics engine, and have a unique set of <a class='urllink' href='../ScriptReference/Collider.OnTriggerEnter.html' rel='nofollow'>three</a> <a class='urllink' href='../ScriptReference/Collider.OnTriggerExit.html' rel='nofollow'>trigger</a> <a class='urllink' href='../ScriptReference/Collider.OnTriggerStay.html' rel='nofollow'>messages</a> that are sent out when a collision with a Trigger occurs.  Triggers are useful for triggering other events in your game, like cutscenes, automatic door opening, displaying tutorial messages, etc.  Use your imagination!
</p>
<p class='vspace'>Be aware that in order for two Triggers to send out trigger events when they collide, one of them must include a Rigidbody as well. For a Trigger to collide with a normal Collider, one of them must have a Rigidbody attached.  For a detailed chart of different types of collisions, see the collision action matrix in the Advanced section below.
</p>
<div class='vspace'></div><h3>Friction and bouncyness</h3>
<p>Friction, bouncyness and softness are defined in the <a href="../Components/class-PhysicMaterial.html">Physic Material</a>. The <a href="../Manual/HOWTO-InstallStandardAssets.html">Standard Assets</a> contain the most common physics materials. To use one of them click on the Physic Material drop-down and select one, eg. Ice. You can also <a href="../Components/class-PhysicMaterial.html">create</a> your own physics materials and tweak all friction values.
</p>
<div class='vspace'></div><h2>Hints</h2>
<ul><li>Mesh Colliders <b>cannot</b> collide with each other unless they are marked as <span class='doc-prop'>Convex</span>.  Therefore, they are most useful for background objects like environment geometry.
</li><li><span class='doc-prop'>Convex</span> Mesh Colliders must be fewer than 255 triangles. 
</li><li>Primitive Colliders are less costly for objects under physics control.
</li><li>When you attach a Mesh Collider to a <span class='doc-keyword'>GameObject</span>, its Mesh property will default to the mesh being rendered. You can change that by assigning a different Mesh.
</li><li>To add multiple Colliders for an object, create child GameObjects and attach a Collider to each one.  This allows each Collider to be manipulated independently.
</li><li>You can look at the gizmos in the <span class='doc-keyword'>Scene View</span> to see how the Collider is being calculated on your object.
</li><li>Colliders do their best to match the scale of an object. If you have a non-uniform scale (a scale which is different in each direction), only the Mesh Collider can match completely.
</li><li>If you are moving an object through its Transform component but you want to receive Collision/Trigger messages, you must attach a Rigidbody to the object that is moving.
</li></ul><h1>Physic Material</h1>
<p>The <span class='doc-keyword'>Physic Material</span> is used to adjust friction and bouncing effects of colliding objects.
</p>
<p class='vspace'>To create a Physic Material select <span class='doc-menu'>Assets-&gt;Create-&gt;Physic Material</span> from the menu bar.  Then drag the Physic Material from the Project View onto a <span class='doc-keyword'>Collider</span> in the scene.
</p>
<div class='vspace'></div><div><img class='figure' src='../Images/manual/Physics-10.jpg' /><br /><em>The Physic Material <span class='doc-keyword'>Inspector</span></em></div>
<div class='vspace'></div><h2>Properties</h2>
<table border='2' ><tr class='tableheader'><td  class='prop'></td><td class='function'></td></tr>
<tr ><td  align='left'><span class='doc-prop'>Dynamic Friction</span></td><td  align='left'>The friction used when already moving. Usually a value from 0 to 1. A value of zero feels like ice, a value of 1 will make it come to rest very quickly unless a lot of force or gravity pushes the object.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Static Friction</span></td><td  align='left'>The friction used when an object is laying still on a surface. Usually a value from 0 to 1. A value of zero feels like ice, a value of 1 will make it very hard to get the object moving.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Bouncyness</span></td><td  align='left'>How bouncy is the surface? A value of 0 will not bounce. A value of 1 will bounce without any loss of energy.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Friction Combine Mode</span></td><td  align='left'>How the friction of two colliding objects is combined.</td></tr>
<tr ><td  align='left'><span  style='padding-left: 1.5em;'><span class='doc-prop'>Average</span></span></td><td  align='left'>The two friction values are averaged.</td></tr>
<tr ><td  align='left'><span  style='padding-left: 1.5em;'><span class='doc-prop'>Min</span></span></td><td  align='left'>The smallest of the two values is used.</td></tr>
<tr ><td  align='left'><span  style='padding-left: 1.5em;'><span class='doc-prop'>Max</span></span></td><td  align='left'>The largest of the two values is used.</td></tr>
<tr ><td  align='left'><span  style='padding-left: 1.5em;'><span class='doc-prop'>Multiply</span></span></td><td  align='left'>The friction values are multiplied with each other.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Bounce Combine</span></td><td  align='left'>How the bouncyness of two colliding objects is combined. It has the same modes as Friction Combine Mode</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Friction Direction 2</span></td><td  align='left'>The direction of anisotropy. Anisotropic friction is enabled if this direction is not zero. Dynamic Friction 2 and Static Friction 2 will be applied along Friction Direction 2.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Dynamic Friction 2</span></td><td  align='left'>If anisotropic friction is enabled, DynamicFriction2 will be applied along Friction Direction 2.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Static Friction 2</span></td><td  align='left'>If anisotropic friction is enabled, StaticFriction2 will be applied along Friction Direction 2.</td></tr>
</table>
<div class='vspace'></div><h2>Details</h2>
<p>Friction is the quantity which prevents surfaces from sliding off each other. This value is critical when trying to stack objects. Friction comes in two forms, dynamic and static. <span class='doc-prop'>Static friction</span> is used when the object is lying still. It will prevent the object from starting to move. If a large enough force is applied to the object it will start moving. At this point <span class='doc-prop'>Dynamic Friction</span> will come into play. <span class='doc-prop'>Dynamic Friction</span> will now attempt to slow down the object while in contact with another.
</p>
<div class='vspace'></div><h2>Hints</h2>
<ul><li>Don't try to use a standard physic material for the main character. Make a customized one and get it perfect.
</li></ul><h1>Hinge Joint</h1>
<p>The <span class='doc-keyword'>Hinge Joint</span> groups together two <a href="../Components/class-Rigidbody.html">Rigidbodies</a>, constraining them to move like they are connected by a hinge. It is perfect for doors, but can also be used to model chains, pendulums, etc.
</p>
<div class='vspace'></div><div><img class='figure' src='../Images/manual/Physics-11.jpg' /><br /><em>The Hinge Joint <span class='doc-keyword'>Inspector</span></em></div>
<div class='vspace'></div><h2>Properties</h2>
<table border='2' ><tr class='tableheader'><td  class='prop'></td><td class='function'></td></tr>
<tr ><td  align='left'><span class='doc-prop'>Connected Body</span></td><td  align='left'>Optional reference to the Rigidbody that the joint is dependent upon. If not set, the joint connects to the world.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Anchor</span></td><td  align='left'>The position of the axis around which the body swings. The position is defined in local space.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Axis</span></td><td  align='left'>The direction of the axis around which the body swings. The direction is defined in local space.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Use Spring</span></td><td  align='left'>Spring makes the Rigidbody reach for a specific angle compared to its connected body.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Spring</span></td><td  align='left'>Properties of the Spring that are used if <span class='doc-prop'>Use Spring</span> is enabled.</td></tr>
<tr ><td  align='left'><span  style='padding-left: 1.5em;'><span class='doc-prop'>Spring</span></span></td><td  align='left'>The force the object asserts to move into the position.</td></tr>
<tr ><td  align='left'><span  style='padding-left: 1.5em;'><span class='doc-prop'>Damper</span></span></td><td  align='left'>The higher this value, the more the object will slow down.</td></tr>
<tr ><td  align='left'><span  style='padding-left: 1.5em;'><span class='doc-prop'>Target Position</span></span></td><td  align='left'>Target angle of the spring. The spring pulls towards this angle measured in degrees.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Use Motor</span></td><td  align='left'>The motor makes the object spin around.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Motor</span></td><td  align='left'>Properties of the Motor that are used if <span class='doc-prop'>Use Motor</span> is enabled.</td></tr>
<tr ><td  align='left'><span  style='padding-left: 1.5em;'><span class='doc-prop'>Target Velocity</span></span></td><td  align='left'>The speed the object tries to attain.</td></tr>
<tr ><td  align='left'><span  style='padding-left: 1.5em;'><span class='doc-prop'>Force</span></span></td><td  align='left'>The force applied in order to attain the speed.</td></tr>
<tr ><td  align='left'><span  style='padding-left: 1.5em;'><span class='doc-prop'>Free Spin</span></span></td><td  align='left'>If enabled, the motor is never used to brake the spinning, only accelerate it.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Use Limits</span></td><td  align='left'>If enabled, the angle of the hinge will be restricted within the <span class='doc-prop'>Min</span> &amp; <span class='doc-prop'>Max</span> values.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Limits </span></td><td  align='left'>Properties of the Limits that are used if <span class='doc-prop'>Use Limits</span> is enabled.</td></tr>
<tr ><td  align='left'><span  style='padding-left: 1.5em;'><span class='doc-prop'>Min</span></span></td><td  align='left'>The lowest angle the rotation can go.</td></tr>
<tr ><td  align='left'><span  style='padding-left: 1.5em;'><span class='doc-prop'>Max</span></span></td><td  align='left'>The highest angle the rotation can go.</td></tr>
<tr ><td  align='left'><span  style='padding-left: 1.5em;'><span class='doc-prop'>Min Bounce</span></span></td><td  align='left'>How much the object bounces when it hits the minimum stop.</td></tr>
<tr ><td  align='left'><span  style='padding-left: 1.5em;'><span class='doc-prop'>Max Bounce</span></span></td><td  align='left'>How much the object bounces when it hits the maximum stop.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Break Force</span></td><td  align='left'>The force that needs to be applied for this joint to break.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Break Torque</span></td><td  align='left'>The torque that needs to be applied for this joint to break.</td></tr>
</table>
<div class='vspace'></div><h2>Details</h2>
<p>A single Hinge Joint should be applied to a <span class='doc-keyword'>GameObject</span>.  The hinge will rotate at the point specified by the <span class='doc-prop'>Anchor</span> property, moving around the specified <span class='doc-prop'>Axis</span> property.  You <b>do not</b> need to assign a GameObject to the joint's <span class='doc-prop'>Connected Body</span> property.  You should only assign a GameObject to the <span class='doc-prop'>Connected Body</span> property if you want the joint's <span class='doc-keyword'>Transform</span> to be dependent on the attached object's Transform.
</p>
<p class='vspace'>Think about how the hinge of a door works. The <span class='doc-prop'>Axis</span> in this case is up, positive along the Y axis. The <span class='doc-prop'>Anchor</span> is placed somewhere at the intersection between door and wall.  You would not need to assign the wall to the <span class='doc-prop'>Connected Body</span>, because the joint will be connected to the world by default.
</p>
<p class='vspace'>Now think about a doggy door hinge. The doggy door's <span class='doc-prop'>Axis</span> would be sideways, positive along the relative X axis.  The main door should be assigned as the <span class='doc-prop'>Connected Body</span>, so the doggy door's hinge is dependent on the main door's Rigidbody.
</p>
<div class='vspace'></div><h3>Chains</h3>
<p>Multiple Hinge Joints can also be strung together to create a chain.  Add a joint to each link in the chain, and attach the next link as the <span class='doc-prop'>Connected Body</span>.
</p>
<div class='vspace'></div><h2>Hints</h2>
<ul><li>You do not need to assign a <span class='doc-prop'>Connected Body</span> to your joint for it to work.
</li><li>Use <span class='doc-prop'>Break Force</span> in order to make dynamic damage systems. This is really cool as it allows the player to break a door off its hinge by blasting it with a rocket launcher or running into it with a car.
</li><li>The <span class='doc-prop'>Spring</span>, <span class='doc-prop'>Motor</span>, and <span class='doc-prop'>Limits</span> properties allow you to fine-tune your joint's behaviors.
</li></ul><h1>Spring Joint</h1>
<p>The <span class='doc-keyword'>Spring Joint</span> groups together two <span class='doc-keyword'>Rigidbodies</span>, constraining them to move like they are connected by a spring.
</p>
<div class='vspace'></div><div><img class='figure' src='../Images/manual/Physics-12.jpg' /><br /><em>The Spring Joint <span class='doc-keyword'>Inspector</span></em></div>
<div class='vspace'></div><h2>Properties</h2>
<table border='2' ><tr class='tableheader'><td  class='prop'></td><td class='function'></td></tr>
<tr ><td  align='left'><span class='doc-prop'>Connected Body</span></td><td >Optional reference to the Rigidbody that the joint is dependent upon.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Anchor</span></td><td >Position in the object's local space (at rest) that defines the center of the joint. This is not the point that the object will be drawn toward.</td></tr>
<tr ><td  align='left'><span  style='padding-left: 1.5em;'><span class='doc-prop'>X</span></span></td><td  align='left'>Position of the joint's local center along the X axis.</td></tr>
<tr ><td  align='left'><span  style='padding-left: 1.5em;'><span class='doc-prop'>Y</span></span></td><td  align='left'>Position of the joint's local center along the Y axis.</td></tr>
<tr ><td  align='left'><span  style='padding-left: 1.5em;'><span class='doc-prop'>Z</span></span></td><td  align='left'>Position of the joint's local center along the Z axis.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Spring</span></td><td >Strength of the spring.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Damper</span></td><td  align='left'>Amount that the spring is reduced when active.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Min Distance</span></td><td  align='left'>Distances greater than this will not cause the Spring to activate.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Max Distance</span></td><td  align='left'>Distances less than this will not cause the Spring to activate.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Break Force</span></td><td  align='left'>The force that needs to be applied for this joint to break.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Break Torque</span></td><td  align='left'>The torque that needs to be applied for this joint to break.</td></tr>
</table>
<div class='vspace'></div><h2>Details</h2>
<p>Spring Joints allows a Rigidbodied <span class='doc-keyword'>GameObject</span> to be pulled toward a particular "target" position.  This position will either be another Rigidbodied GameObject or the world.  As the GameObject travels further away from this "target" position, the Spring Joint applies forces that will pull it back to its original "target" position.  This creates an effect very similar to a rubber band or a slingshot.
</p>
<p class='vspace'>The "target" position of the Spring is determined by the relative position from the <span class='doc-prop'>Anchor</span> to the <span class='doc-prop'>Connected Body</span> (or the world) when the Spring Joint is created, or when Play mode is entered.  This makes the Spring Joint very effective at setting up Jointed characters or objects in the Editor, but is harder to create push/pull spring behaviors in runtime through scripting.  If you want to primarily control a GameObject's position using a Spring Joint, it is best to create an empty GameObject with a Rigidbody, and set that to be the <span class='doc-prop'>Connected Rigidbody</span> of the Jointed object.  Then in scripting you can change the position of the <span class='doc-prop'>Connected Rigidbody</span> and see your Spring move in the ways you expect.
</p>
<div class='vspace'></div><h3>Connected Rigidbody</h3>
<p>You do not need to use a <span class='doc-prop'>Connected Rigidbody</span> for your joint to work.  Generally, you should only use one if your object's position and/or rotation is dependent on it.  If there is no <span class='doc-prop'>Connected Rigidbody</span>, your Spring will connect to the world.
</p>
<div class='vspace'></div><h3>Spring &amp; Damper</h3>
<p><span class='doc-prop'>Spring</span> is the strength of the force that draws the object back toward its "target" position.  If this is 0, then there is no force that will pull on the object, and it will behave as if no Spring Joint is attached at all.
</p>
<p class='vspace'><span class='doc-prop'>Damper</span> is the resistance encountered by the <span class='doc-prop'>Spring</span> force.  The lower this is, the springier the object will be.  As the <span class='doc-prop'>Damper</span> is increased, the amount of bounciness caused by the Joint will be reduced.
</p>
<div class='vspace'></div><h3>Min &amp; Max Distance</h3>
<p>If the position of your object falls in-between the <span class='doc-prop'>Min</span> &amp; <span class='doc-prop'>Max Distances</span>, then the Joint will not be applied to your object.  The position must be moved outside of these values for the Joint to activate.
</p>
<div class='vspace'></div><h2>Hints</h2>
<ul><li>You do not need to assign a <span class='doc-prop'>Connected Body</span> to your Joint for it to work.
</li><li>Set the ideal positions of your Jointed objects in the Editor prior to entering Play mode.
</li><li>Spring Joints require your object to have a Rigidbody attached.
</li></ul><div class='vspace'></div><a class='iosRef' id='iosRef' href="javascript:ShowHideDiv('iosRef','specific-ios', 'iOS');"><h1><img class='figure' src='../Images/manual/Physics-13.jpg' /> iOS</h1></a>
<div class='specific-ios' style='display: block;' id='specific-ios' > 
<p>iOS physics optimization hints can be found <a href="../Manual/iphone-Optimizing-Physics.html">here</a>. 
</p></div>
</p><small>Page last updated: 2011-01-12</p>
    <script type="text/javascript">


    var allHTMLTags = new Array();
    document.divs = new Array();

    function getElementByClass(theClass) {

	    var allHTMLTags=document.getElementsByTagName("*");

	    for (var i=0; i<allHTMLTags.length; i++) {

		    if (allHTMLTags[i].className==theClass) {
			    return true;
		    }
	    }
	    return false;
    }

    function ShowHideDiv(containerName, className, content){
	var container = document.getElementById(containerName);
	if(container == null)
		return;
	if(content == '') {//In case there are no divs in the page we still can change the icons.
		if(containerName == 'desktopRef') {
			if(container.innerHTML == "<img src=\"../Images/DesktopNO.png\" alt=\"\">") {
				container.innerHTML = "<img src=\"../Images/DesktopYES.png\" alt=\"\">";
				SetCookie(containerName, 'set', 30);
			} else {
				container.innerHTML = "<img src=\"../Images/DesktopNO.png\" alt=\"\">";
				UnSetCookie(containerName);
			}
		}
		if(containerName == 'iosRef') {
			if(container.innerHTML == "<img src=\"../Images/iPhoneNO.png\" alt=\"\">") {
				container.innerHTML = "<img src=\"../Images/iPhoneYES.png\" alt=\"\">";
				SetCookie(containerName, 'set', 30);
			} else {
				container.innerHTML = "<img src=\"../Images/iPhoneNO.png\" alt=\"\">";
				UnSetCookie(containerName);
			}
		}
		if(containerName == 'androidRef') {
			if(container.innerHTML == "<img src=\"../Images/AndroidNO.png\" alt=\"\">") {
				container.innerHTML = "<img src=\"../Images/AndroidYES.png\" alt=\"\">";
				SetCookie(containerName, 'set', 30);
			} else {
				container.innerHTML = "<img src=\"../Images/AndroidNO.png\" alt=\"\">";
				UnSetCookie(containerName);
			}	
		}
	} else {
		if(container.innerHTML == "<h1><img src=\"../Images/PlatformArrowRight.png\" alt=\"\"> " + content + "</h1>") {
		container.innerHTML = "<h1><img src=\"../Images/PlatformArrowDown.png\" alt=\"\">" + content + "</h1>";
			SetCookie(containerName, 'set', 30);
		} else {
			container.innerHTML = "<h1><img src=\"../Images/PlatformArrowRight.png\" alt=\"\">" + content + "</h1>";
			UnSetCookie(containerName);
		}
	}
	for(var i = 0; i < document.divs.length; i++) {
		var divClassName = document.divs[i];
		var matched = false;
		if(divClassName.className == className)
			   matched = true;
		if(matched) {
			
			if(divClassName != null) {
				if (divClassName.style.display == 'block') {
					divClassName.style.display = 'none';
					if(content == '') {
						if(className == 'specific-desktop')
							container.innerHTML = "<img src=\"../Images/DesktopNO.png\" alt=\"\" />";
						if(className == 'specific-ios')
							container.innerHTML = "<img src=\"../Images/iPhoneNO.png\" alt=\"\" />";
						if(className == 'specific-android')
							container.innerHTML = "<img src=\"../Images/AndroidNO.png\" alt=\"\" />";
					} else {
						container.innerHTML = "<h1><img src=\"../Images/PlatformArrowRight.png\" alt=\"\" /> " + content + "</h1>";
					}
					UnSetCookie(containerName);
				} else {
					divClassName.style.display = 'block';
					if(content == '') {
						if(className == 'specific-desktop')
							container.innerHTML = "<img src=\"../Images/DesktopYES.png\" alt=\"\" />";
						if(className == 'specific-ios')
							container.innerHTML = "<img src=\"../Images/iPhoneYES.png\" alt=\"\" />";
						if(className == 'specific-android')
							container.innerHTML = "<img src=\"../Images/AndroidYES.png\" alt=\"\" />";
					} else {
						container.innerHTML = "<h1><img src=\"../Images/PlatformArrowDown.png\" alt=\"\" /> " + content + "</h1>";
					}
					SetCookie(containerName, 'set', 30);
				}
			}
		}	
        }			   
    }
    function UnSetCookie(cn) {
    	SetCookie(cn,'',30);
    }

    function GetCookie(cName) {
	if (document.cookie.length > 0) {
            cStart = document.cookie.indexOf(cName + "=");
	    if(cStart != -1) {
	        cStart = cStart + cName.length + 1;
	        cEnd = document.cookie.indexOf(";", cStart);
	        if (cEnd == -1) {
	            cEnd = document.cookie.length;
	        }
	        return unescape(document.cookie.substring(cStart, cEnd));;
	    }
	}
	return "";
    }

    function SetCookie(cName, value, expireDays) {
	var exDate = new Date();
	exDate.setDate(exDate.getDate()+expireDays);
	document.cookie = cName + "=" + escape(value) + ((expireDays ==null) ? "" : ";expires=" + exDate.toGMTString()) + ";path=/";
    }

    function DocLoaded() {
	document.divs = document.getElementsByTagName('div');
	var prefDesktop = GetCookie('desktopRef');
	var prefiOS = GetCookie('iosRef');
	var prefAndroid = GetCookie('androidRef');
	var firstTime = GetCookie('FT');
	if (firstTime == null || firstTime == "" ) {
	    SetCookie('FT', 'no', 30);
	    SetCookie('desktopRef', 'set', 30)
	} else if (prefDesktop == null || prefDesktop =="") {
	    if(getElementByClass('desktopRefIMG')) {
	        ShowHideDiv('desktopRef','specific-desktop','');
	    } else {
	        ShowHideDiv('desktopRef','specific-desktop','Desktop');
	    }
	}
	if (prefiOS == null || prefiOS =="") {
	    if(getElementByClass('iosRefIMG')) {
	        ShowHideDiv('iosRef','specific-ios','');
	    } else {
	        ShowHideDiv('iosRef','specific-ios','iOS');
	    }
	}
	if (prefAndroid == null || prefAndroid =="") {
	    if(getElementByClass('androidRefIMG')) {
	        ShowHideDiv('androidRef','specific-android','');
	    } else {
	        ShowHideDiv('androidRef','specific-android','Android');
	    }
	}	
    }
    </script>
    
		<!-- #TemplateEndEditable -->	

		<div class="nav">  </div>
	</div>
</div>
</body></html>
<!-- #EndTemplate -->
