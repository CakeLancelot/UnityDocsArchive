<!-- #BeginTemplate "/Templates/manual-page.dwt" --><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<!-- #TemplateBeginEditable name="doctitle" -->
		<title>Unity - Optimizing iPhone Performance</title>
	<!-- #TemplateEndEditable -->
</head>
<link rel="StyleSheet"  href="../Images/docs.css" type="text/css" />
<body>
<table class="titlebar" cellpadding=0 cellspacing=0 border=0><tr>
	<td class="titleleft"><img src="../Images/top/left.png"></td>
	<td><a href="../../Documentation.html"><img src="../Images/top/logo.png"></a></td>
	<td class="titlemid">
		<table><tr>
			<td class="doctitle">Optimizing iPhone Performance</td>
			<td class="Components" align="right"><a href="../Manual/index.html" title="Go to Unity manual"><img src="../Images/spacer.gif" width="72" height="36" class="manual" border="0"></a></td>
			<td class="Components" width="94"><a href="../Components/index.html" title="Go to Reference"><img src="../Images/spacer.gif" width="94" height="36" class="reference" border="0"></a></td>
			<td class="Components" width="82"><a href="../ScriptReference/index.html" title="Go to Scripting Reference"><img src="../Images/spacer.gif" width="82" height="36" class="scripting" border="0"></a></td>
		</tr><tr>
			<td colspan="4">
				<table width="100%" class="docpath"><tr><td >
		<!-- #TemplateBeginEditable name="path" -->
					<a href="../Components/index.html">Reference Manual</a> &gt; <a href="../Components/iPhoneGuide.html">Developing for the iPhone</a> &gt; <a href="../Components/Optimizing Performance on the iPhone.html">Optimizing iPhone Performance</a>
		<!-- #TemplateEndEditable -->	
				</td>
				</td><td class="switchlink">
					<!--BeginSwitchLink--><!--EndSwitchLink-->
				</td></tr></table>
			</td>
		</tr></table>
	</td>
	<td class="titleright" width="9"><img src="../Images/top/right.png"></td>
</tr></table>
<div class="manual">
	<div class="main">

		<!-- #TemplateBeginEditable name="navigation" -->
		<div class="nav">
		<div class="nav-prev">
			<a href='../Components/Advanced Unity iPhone Tips.html'>
				<div class="nav-left"></div>
				<div class="nav-main">Previous</div>
				<div class="nav-right"></div>
			</a>
		</div>
	
		<div class="nav-next">
			<a href='../Components/Account Setup Help.html'>
				<div class="nav-left"></div>
				<div class="nav-main">Next</div>
				<div class="nav-right"></div>
			</a>
		</div>
	</div>
		<!-- #TemplateEndEditable -->	
		<!-- #TemplateBeginEditable name="title" -->
			<h1>Optimizing iPhone Performance</h1>
		<!-- #TemplateEndEditable -->	
		<!-- #TemplateBeginEditable name="body" -->
			
<p>Making games for the iPhone is fun. However it is crucial for your success to understand graphical capabilities and processing power of the iPhone.
You should expect iPhone's combined graphical and processing power somewhere between the Nintendo DS and the Playstation Portable. Plan your games accordingly!
</p>
<p class='vspace'>In the sections below we have gathered guidelines which will help you to achieve better performance on iPhone.
</p>
<div class='vspace'></div><h2>General GPU Information</h2>
<h3>iPhone GPU</h3>
<p>iPhone GPU is a Tile-Based Deferred Renderer. In contrast with most <span class='wikiword'>GPUs</span> in the desktop computers, iPhone GPU focuses on minimising the processing required to render an image as early in the processing of a scene as possible, so that only the pixels that actually will be seen consume processing resources.
</p>
<p class='vspace'>GPU framebuffer is divided up into tiles and rendering happens tile by tile. First triangles for the whole frame are gathered and assigned to the tiles. Visible fragments of each triangle are chosen and only then are passed to rasterizer. Triangles occluded from the camera are rejected at this stage. Following rasterization happens tile by tile.
</p>
<p class='vspace'>Tile-Based Deferred Rendering consumes less memory bandwidth, has lower power consumption and is utilizes texture cache better. Tile-Based Deferred Rendering allows to reject occluded fragments before actual rasterization (somewhat comparable with Early-Z rejection of modern desktop <span class='wikiword'>GPUs</span>) which is effective to keep overdraw low. Theoretically overdraw ratio for fully opaque geometry is 1.
</p>
<div class='vspace'></div><h3>Vertex Processing Unit</h3>
<p>iPhone has a dedicated unit responsible for vertex processing which runs calculations parallel with rasterization. In order to achieve better parallelization iPhone process vertices one frame ahead of the rasterizer.
</p>
<p class='vspace'>Since vertex processing and rasterization are parallel, time which takes to process a frame on GPU is the longest of two: <em>max(vertex_processing_time, rasterization_time)</em>
</p>
<div class='vspace'></div><h3>Unified memory architecture</h3>
<p>Both CPU and GPU on the iPhone are sharing same memory. It has an advantage that you don't need to worry about running out of video memory for your textures (unless of course you don't run out of main memory). It has a disadvantage that you share same memory bandwidth for gameplay and graphics. More memory bandwidth you dedicate to graphics, less you will have for gameplay and physics.
</p>
<div class='vspace'></div><h2>Pixel performance</h2>
<h3>Alpha</h3>
<p>Alpha-blending on iPhone takes an advantage of Tile-Based Deferred Rendering since there is no additional memory bandwidth is required for reading color values from the framebuffer. However alpha-blending can not take advantage of hidden surface removal and results in additional overdraw.
</p>
<p class='vspace'>Alpha-testing in contrary is very expensive on iPhone. Use alpa-blending instead if possible. If you absolutely need to use alpha-testing, make sure you minimize its usage.
</p>
<div class='vspace'></div><h3>Texturing</h3>
<p>iPhone supports texture combiners which allows to combine up 2 textures per fragment. Note that iPhone doesn't support any pixel shaders. There is no additional cost to use 2 textures except for the cost of the sampling actual texture data. You should always prefer combiners to multi-pass rendering.
</p>
<p class='vspace'>Although Tile-Based Deferred Rendering of the chip is well suited to take maximum advantage of texture cache, actual size of texture cache onboard is quite small. It is crucial to get texture sizes to minimum. One way to do that is to use PVRTC hardware texture compression.
</p>
<p class='vspace'>iPhone support <span class='wikiword'>PVRTC4</span> texture compression with 4 bits per pixel and <span class='wikiword'>PVRTC2</span> with 2 bits per pixel. Both formats are supported for 3 channel RGB and 4 channel RGBA textures. Size of <span class='wikiword'>PVRTC4</span> is equivalent to <span class='wikiword'>DXT1</span> and <span class='wikiword'>PVRTC2</span> is two times smaller.
</p>
<p class='vspace'>Following table presents time needed to sample uncompressed vs PVRTC compressed texture:
</p><table width='100%'><tr ><td  align='left'>Single uncompressed 32bit (8bit per channel) RGBA texture</td><td  align='left'>3.8ms</td></tr>
<tr ><td  align='left'>Texture combiner using two uncompressed 32bit (8bit per channel) RGBA textures</td><td  align='left'>13.4ms</td></tr>
<tr ><td  align='left'>Single PVRTC 4bpp compressed texture (size equivalent to <span class='wikiword'>DXT1</span>)</td><td  align='left'>1.1ms</td></tr>
<tr ><td  align='left'>Texture combiner using two PVRTC 4bpp compressed textures</td><td  align='left'>5.2ms</td></tr>
<tr ><td  align='left'>Texture combiner using two PVRTC 2bpp compressed textures</td><td  align='left'>4.8ms</td></tr>
</table>
<p class='vspace'>(Texture sampling performance was measured by rendering full-screen quad and applying 512x512 textures upside-down to stress texture cache a bit. To get pure sampling time without rasterization, time of rendering same full-screen quad with single color (which is around 7ms) was subtracted from results)
</p>
<p class='vspace'>Note that PVRTC compressed texture sampling time is dramatically lower comparing to non-compressed texture. Fitting in cache becomes extremely important once you sample from 2 textures simultaneously. You should always use smallest possible and PVRTC compressed textures.
</p>
<p class='vspace'>Sampling only one texture instead of two is always a good idea. Think about baking result of texture combiner directly into single texture. For example sometimes lightmap textures can be baked directly into the diffuse textures.
</p>
<div class='vspace'></div><h3>General rasterization</h3>
<p>Rasterizing single color full-screen quad takes around 7ms on iPhone. Rendering same full-screen quad, but with texture will add additional cost of actually sampling texture data.
</p>
<p class='vspace'>Following table presents approximate rasterization times of full-screen quad:
</p><table width='100%'><tr ><td  align='left'>Single color</td><td >7.0ms</td></tr>
<tr ><td  align='left'>Single PVRTC 4 bpp textured</td><td >8.1ms</td></tr>
<tr ><td  align='left'>Combining two PVRTC 4bpp textures</td><td >13.2ms</td></tr>
</table>
<p class='vspace'>Due to Tile-Based Deferred Rendering you don't need to pay additional cost of depth comparisons or reading framebuffer. If you want to lay out one more alpha blended pass on top, you would increase your frame time twice. It is simple, no other costs.
</p>
<div class='vspace'></div><h3>Depth buffer</h3>
<p>You always need to clear depth AND color of framebuffer to achieve best performance. Note that you don't need to pay for clearing framebuffer with a color, if subsequent opaque geometry will cover it. Best approach to clearing screen in Unity on iPhone is to use Skybox.
</p>
<div class='vspace'></div><h2>Vertex performance</h2>
<p>One of the main problems with <span class='wikiword'>OpenGLES</span> implementation on iPhone that it will copy vertex data for each render call every frame. That usually eats around 1/3 of the frame time on CPU and wastes memory bandwidth. Keep your vertex budget as low possible.
</p>
<p class='vspace'>Generally you should aim at 5K-10K vertices visible per frame.
</p>
<p class='vspace'>Calculating lighting informations per-vertex dynamically can be expensive as well. Try to avoid multiple complex lights affecting single objects. Think about avoiding dynamic lighting on some (most) objects altogether, bake lighting instead.
</p>
<div class='vspace'></div><h2>Summary</h2>
<ol><li>Keep vertex count below 10K per frame
</li><li>Use PVRTC texture compression
</li><li>Use combiners to mix two textures per fragment instead of multi-pass approach
</li><li>Prefer single texture instead of two per fragment
</li><li>Make sure you don't use lights when you don't need to - for example static light-mapped objects definitely don't need additional lighting
</li><li>Avoid alpha-testing, prefer alpha-blending instead
</li><li>Use skyboxes
</li></ol>

		<!-- #TemplateEndEditable -->	

		<div class="nav">
		<div class="nav-prev">
			<a href='../Components/Advanced Unity iPhone Tips.html'>
				<div class="nav-left"></div>
				<div class="nav-main">Previous</div>
				<div class="nav-right"></div>
			</a>
		</div>
	
		<div class="nav-next">
			<a href='../Components/Account Setup Help.html'>
				<div class="nav-left"></div>
				<div class="nav-main">Next</div>
				<div class="nav-right"></div>
			</a>
		</div>
	</div>
	</div>
</div>
</body></html>
<!-- #EndTemplate -->
