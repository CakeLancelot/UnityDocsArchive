<!-- #BeginTemplate "/Templates/manual-page.dwt" --><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<!-- #TemplateBeginEditable name="doctitle" -->
		<title>Unity - Optimizing iPhone Performance</title>
	<!-- #TemplateEndEditable -->
</head>
<link rel="StyleSheet"  href="../Images/docs.css" type="text/css" />
<body>
<table class="titlebar" cellpadding=0 cellspacing=0 border=0><tr>
	<td class="titleleft"><img src="../images/top/left.png"></td>
	<td><a href="../../Documentation.html"><img src="../images/top/logo.png"></a></td>
	<td class="titlemid">
		<table><tr>
			<td class="doctitle">Optimizing iPhone Performance</td>
			<td class="Components" align="right"><a href="../Manual/index.html" title="Go to Unity manual"><img src="../images/spacer.gif" width="72" height="36" class="manual" border="0"></a></td>
			<td class="Components" width="94"><a href="../Components/index.html" title="Go to Reference"><img src="../images/spacer.gif" width="94" height="36" class="reference" border="0"></a></td>
			<td class="Components" width="82"><a href="../ScriptReference/index.html" title="Go to Scripting Reference"><img src="../images/spacer.gif" width="82" height="36" class="scripting" border="0"></a></td>
		</tr><tr>
			<td colspan="4">
				<table width="100%" class="docpath"><tr><td >
		<!-- #TemplateBeginEditable name="path" -->
					<a href="../Components/index.html">Reference Manual</a> &gt; <a href="../Components/iPhoneGuide.html">Developing for the iPhone</a> &gt; <a href="../Components/Optimizing Performance on the iPhone.html">Optimizing iPhone Performance</a>
		<!-- #TemplateEndEditable -->	
				</td>
				</td><td class="switchlink">
					<!--BeginSwitchLink--><!--EndSwitchLink-->
				</td></tr></table>
			</td>
		</tr></table>
	</td>
	<td class="titleright" width="9"><img src="../images/top/right.png"></td>
</tr></table>
<div class="manual">
	<div class="main">

		<!-- #TemplateBeginEditable name="navigation" -->
		<div class="nav">
		<div class="nav-prev">
			<a href='../Components/Advanced Unity iPhone Tips.html'>
				<div class="nav-left"></div>
				<div class="nav-main">Previous</div>
				<div class="nav-right"></div>
			</a>
		</div>
	
		<div class="nav-next">
			<a href='../Components/Account Setup Help.html'>
				<div class="nav-left"></div>
				<div class="nav-main">Next</div>
				<div class="nav-right"></div>
			</a>
		</div>
	</div>
		<!-- #TemplateEndEditable -->	
		<!-- #TemplateBeginEditable name="title" -->
			<h1>Optimizing iPhone Performance</h1>
		<!-- #TemplateEndEditable -->	
		<!-- #TemplateBeginEditable name="body" -->
			
<p>Making games for the iPhone is fun. However it is crucial for your success to understand graphical capabilities and processing power of the iPhone. You should expect iPhone's graphical and processing power somewhere between the Nintendo DS and the Playstation Portable. Plan your games accordingly!
</p>
<p class='vspace'>In the sections below we have gathered some guidelines which will help you to achieve better performance on iPhone.
</p>
<div class='vspace'></div><h2>Measuring performance with the Built-in Profiler</h2>
<p>Unity iPhone equips your project with a built-in performance profiler. Note that it is disabled by default. In order to enable it you will have to open Unity the generated <span class='wikiword'>XCode</span> project, select the <span class='doc-menu'><span class='wikiword'>AppController</span>.mm</span> file and change <code>#define ENABLE_INTERNAL_PROFILER 0</code> to <code>#define ENABLE_INTERNAL_PROFILER 1</code>. Choose <span class='doc-menu'>Run-&gt;Console</span> in the <span class='wikiword'>XCode</span> menu to display output (GDB) console and then run your project. Unity will output statistics to the console window every 30 frames. For example you will see:
</p><pre class='codelisting'>
iPhone Unity internal profiler stats:
cpu-player&gt;    min: 18.4   max: 28.3   avg: 23.8
cpu-ogles-drv&gt; min:  1.8   max:  6.9   avg:  2.8
cpu-present&gt;   min:  1.0   max:  2.6   avg:  1.1
frametime&gt;     min: 31.7   max: 35.0   avg: 33.3
draw-call #&gt;   min: 9   max: 9   avg: 9
tris #&gt;        min: 1980   max: 1980   avg: 1980
verts #&gt;       min: 1326   max: 1326   avg: 1326
player-detail&gt; physx:  7.6 animation:  0.0 skinning:  0.0 render:  9.9 fixed-update-count: 1 .. 2
mono-scripts&gt;  update:  1.2   fixedUpdate:  4.6 coroutines:  0.0 
mono-memory&gt;   used heap: 3317760 allocated heap: 3657728
</pre>
<p>All times are measured in milliseconds per frame. You can see the minimum, maximum and average times over last 30 frames.
</p><table width='100%'><tr ><td  align='left'><span class='doc-prop'>cpu-player</span></td><td >Displays time your game spends inside Unity engine and executing scripts on the CPU</td></tr>
<tr ><td  align='left'><span class='doc-prop'>cpu-ogles-drv</span></td><td >Displays time spent by the <span class='wikiword'>OpenGLES</span> driver to process and copy vertex buffer data on the CPU. The more vertices you submit per frame to the rendering pipeline - the more time will be spent in the <span class='wikiword'>OpenGLES</span> driver</td></tr>
<tr ><td  align='left'><span class='doc-prop'>cpu-present</span></td><td >Stands for amount of time spent executing presentRenderbuffer command in <span class='wikiword'>OpenGLES</span></td></tr>
</table>
<p class='vspace'>Overall time your game has spent on CPU per frame is a total of <span class='doc-prop'>cpu-player</span>, <span class='doc-prop'>cpu-ogles-drv</span> and <span class='doc-prop'>cpu-present</span>
</p>
<div class='vspace'></div><table width='100%'><tr ><td  align='left'><span class='doc-prop'>frametime</span></td><td >Represents overall time of a game frame. Note that iPhone hardware is always locked at 60Hz refresh rate, thus you will always get multiples times of ~16.7ms  (1000ms/60Hz = ~16.7ms). If frametime is significantly higher than total of <span class='doc-prop'>cpu-player</span>, <span class='doc-prop'>cpu-ogles-drv</span>, and <span class='doc-prop'>cpu-present</span> time, then it's a sign that your game's performance is limited by the GPU's processing speed..</td></tr>
<tr ><td  align='left'><span class='doc-prop'>draw-call #</span></td><td >The number of draw calls per frame. Keep it as low as possible.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>tris #</span></td><td >Total number of triangles sent for rendering.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>verts #</span></td><td >Total number of vertices sent for rendering. You should keep this number below 10000, if you use only static geometry. On the other hand, if you have lots of skinned geometry, then you should keep this number much lower.</td></tr>
</table>
<p class='vspace'><span class='doc-prop'>player-detail</span> provides a detailed breakdown of what is happening inside the engine:
</p><table width='100%'><tr ><td  align='left'><span class='doc-prop'>physx</span></td><td >Time spent on physics</td></tr>
<tr ><td  align='left'><span class='doc-prop'>animation</span></td><td >Time spent animating bones</td></tr>
<tr ><td  align='left'><span class='doc-prop'>skinning</span></td><td >Time spent applying animations to skinned meshes</td></tr>
<tr ><td  align='left'><span class='doc-prop'>render</span></td><td >Time spent rendering visible objects</td></tr>
<tr ><td  align='left'><span class='doc-prop'>fixed-update-count</span></td><td >Minimum and maximum number of <span class='wikiword'>FixedUpdates</span> executed during this frame. Too many <span class='wikiword'>FixedUpdate</span> will deteriorate perforamance really fast. Follow some simple guidelines to setup an effective <a href='#FixedDeltaTime'>fixed delta time</a></td></tr>
</table>
<p class='vspace'><span class='doc-prop'>mono-scripts</span> provides a detailed breakdown of time spent in Mono runtime:
</p><table width='100%'><tr ><td  align='left'><span class='doc-prop'>update</span></td><td >Total time spent executing all Update() functions in scripts</td></tr>
<tr ><td  align='left'><span class='doc-prop'>fixedUpdate</span></td><td >Total time spent executing all <span class='wikiword'>FixedUpdate</span>() functions in scripts</td></tr>
<tr ><td  align='left'><span class='doc-prop'>coroutines</span></td><td >Time spent inside script coroutines</td></tr>
</table>
<p class='vspace'><span class='doc-prop'>mono-memory</span> Should give you an idea how much memory is used by Mono Garbage Collector. <span class='doc-prop'>Allocated heap</span> represents a total amount of memory which can be filled with objects. If there is a need for more objects than the size of allocated heap, then Garbage Collector will start a collection phase during which all unreferenced objects will be thrown away from memory. If there is not enough free memory after the collection phase, then the allocated heap will grow in size. <span class='doc-prop'>Used heap</span> represents the amount of the <span class='doc-prop'>allocated heap</span> which is currently used up by objects. Every time you create a new class instance (not a struct) this number will grow until collection phase is invoked.
</p>
<div class='vspace'></div><h2>Tuning internals</h2>
<h3>Tuning rendering frequency</h3>
<p>You can tweak how many times per second iPhone Unity application will execute its rendering loop. Default value is 60 times per second. By lowering this number your application will save more battery power, but will render fewer frames per second. By increasing this value, rendering will be prioritized over other activities such as touch input and accelerometer processing. A higher value will also allow less time for background running processes, but might boost performance of your game significantly.  This is on a case-by-case basis, so it's best to try it for yourself and see the impact on your specific game.
</p>
<p class='vspace'>To set the desired rendering loop frequency you will have to open the Unity generated <span class='wikiword'>XCode</span> project, select the <span class='wikiword'>AppController</span>.mm file and change <code>#define kFPS 60</code> to a different value, for example: <code>define kFPS 120</code>.
</p>
<div class='vspace'></div><h3>Tuning accelerometer processing frequency</h3>
<p>Processing accelerometer input multiple times per frame can have a negative impact on overall performance of your game. By default iPhone Unity application will query accelerometer input 60 times per second. You might discover an additional performance improvement by lowering its frequency or even setting it to 0, if your game is not using the accelerometer at all.
</p>
<p class='vspace'>To set the desired accelerometer processing frequency you will have to open the Unity generated <span class='wikiword'>XCode</span> project, select <span class='wikiword'>AppController</span>.mm file and change <code>#define kAccelerometerFrequency 60</code> to a different value, for example: <code>define kAccelerometerFrequency 10</code>.
</p>
<div class='vspace'></div><h2>Optimizing Graphics Performance</h2>
<h3>iPhone GPU Information</h3>
<p>iPhone GPU is a Tile-Based Deferred Renderer. In contrast with most <span class='wikiword'>GPUs</span> in desktop computers, the iPhone GPU focuses on minimizing the processing required to render an image as early in the processing of a scene as possible, so that only the pixels that actually will be seen consume processing resources.
</p>
<p class='vspace'>The GPU's frame buffer is divided up into tiles and rendering happens tile by tile. First, triangles for the whole frame are gathered and assigned to the tiles. Visible fragments of each triangle are chosen and only then are passed to rasterizer. Triangles occluded from the camera are rejected at this stage.
</p>
<p class='vspace'>Tile-Based Deferred Rendering consumes less memory bandwidth, has lower power consumption and is utilizes texture cache better. Tile-Based Deferred Rendering allows the device to reject occluded fragments before actual rasterization which is effective to keep overdraw low.
</p>
<div class='vspace'></div><h3>Vertex Processing Unit</h3>
<p>The iPhone has a dedicated unit responsible for vertex processing which runs calculations parallel with rasterization. In order to achieve better parallelization, the iPhone process vertices one frame ahead of the rasterizer.
</p>
<p class='vspace'>Since vertex processing and rasterization are parallel, the time it takes to process a frame on GPU becomes the longest of the two.
</p>
<div class='vspace'></div><h3>Unified memory architecture</h3>
<p>Both CPU and GPU on the iPhone are sharing the same memory. The advantage is that you don't need to worry about running out of video memory for your textures (unless of course you run out of main memory too). The disadvantage is that you share same memory bandwidth for gameplay and graphics. The more memory bandwidth you dedicate to graphics, less you will have for gameplay and physics.
</p>
<div class='vspace'></div><h2>Pixel performance</h2>
<h3>Alpha</h3>
<p>Alpha-blending on iPhone takes an advantage of Tile-Based Deferred Rendering since there is no additional memory bandwidth is required for reading color values from the framebuffer. However alpha-blending can not take advantage of hidden surface removal and results in additional overdraw.
</p>
<p class='vspace'>Alpha-testing in contrary is very expensive on iPhone. Use alpa-blending instead if possible. If you absolutely need to use alpha-testing, make sure you minimize its usage.
</p>
<div class='vspace'></div><h3>Texturing</h3>
<p>iPhone supports texture combiners which allows to combine up 2 textures per fragment. Note that iPhone doesn't support any pixel shaders. There is no additional cost to use 2 textures except for the cost of the sampling actual texture data. You should always prefer combiners to multi-pass rendering.
</p>
<p class='vspace'>Although Tile-Based Deferred Rendering of the chip is well suited to take maximum advantage of texture cache, actual size of texture cache onboard is quite small. It is crucial to get texture sizes to minimum. One way to do that is to use PVRTC hardware texture compression.
</p>
<p class='vspace'>iPhone support <span class='wikiword'>PVRTC4</span> texture compression with 4 bits per pixel and <span class='wikiword'>PVRTC2</span> with 2 bits per pixel. Both formats are supported for 3 channel RGB and 4 channel RGBA textures. Size of <span class='wikiword'>PVRTC4</span> is equivalent to <span class='wikiword'>DXT1</span> and <span class='wikiword'>PVRTC2</span> is two times smaller.
</p>
<p class='vspace'>Following table presents time needed to sample uncompressed vs PVRTC compressed texture:
</p><table width='100%'><tr ><td  align='left'>Single uncompressed 32bit (8bit per channel) RGBA texture</td><td  align='left'>3.8ms</td></tr>
<tr ><td  align='left'>Texture combiner using two uncompressed 32bit (8bit per channel) RGBA textures</td><td  align='left'>13.4ms</td></tr>
<tr ><td  align='left'>Single PVRTC 4bpp compressed texture (size equivalent to <span class='wikiword'>DXT1</span>)</td><td  align='left'>1.1ms</td></tr>
<tr ><td  align='left'>Texture combiner using two PVRTC 4bpp compressed textures</td><td  align='left'>5.2ms</td></tr>
<tr ><td  align='left'>Texture combiner using two PVRTC 2bpp compressed textures</td><td  align='left'>4.8ms</td></tr>
</table>
<p class='vspace'>(Texture sampling performance was measured by rendering full-screen quad and applying 512x512 textures upside-down to stress texture cache a bit. To get pure sampling time without rasterization, time of rendering same full-screen quad with single color (which is around 7ms) was subtracted from results)
</p>
<p class='vspace'>Note that PVRTC compressed texture sampling time is dramatically lower comparing to non-compressed texture. Fitting in cache becomes extremely important once you sample from 2 textures simultaneously. You should always use smallest possible and PVRTC compressed textures.
</p>
<p class='vspace'>Sampling only one texture instead of two is always a good idea. Think about baking result of texture combiner directly into single texture. For example sometimes lightmap textures can be baked directly into the diffuse textures.
</p>
<div class='vspace'></div><h3>General rasterization</h3>
<p>Rasterizing single color full-screen quad takes around 7ms on iPhone. Rendering same full-screen quad, but with texture will add additional cost of actually sampling texture data.
</p>
<p class='vspace'>Following table presents approximate rasterization times of full-screen quad:
</p><table width='100%'><tr ><td  align='left'>Single color</td><td >7.0ms</td></tr>
<tr ><td  align='left'>Single PVRTC 4 bpp textured</td><td >8.1ms</td></tr>
<tr ><td  align='left'>Combining two PVRTC 4bpp textures</td><td >13.2ms</td></tr>
</table>
<p class='vspace'>Due to Tile-Based Deferred Rendering you don't need to pay the additional cost of depth comparisons or reading the frame buffer. If you want to lay out one more alpha blended pass on top, you would increase your frame time twice. It is simple, no other costs.
</p>
<div class='vspace'></div><h3>Depth buffer</h3>
<p>You always need to clear depth AND color of framebuffer to achieve best performance. Note that you don't need to pay for clearing framebuffer with a color, if subsequent opaque geometry will cover it. Best approach to clearing screen in Unity on iPhone is to use Skybox.
</p>
<div class='vspace'></div><h2>Vertex performance</h2>
<p>One of the main problems with <span class='wikiword'>OpenGLES</span> implementation on iPhone that it will copy vertex data for each render call every frame. That usually eats around 1/3 of the frame time on CPU and wastes memory bandwidth. Keep your vertex budget as low possible.
</p>
<p class='vspace'>Generally you should aim at 5K-10K vertices visible per frame.
</p>
<p class='vspace'>Calculating lighting informations per-vertex dynamically can be expensive as well. Try to avoid multiple complex lights affecting single objects. Think about avoiding dynamic lighting on some (most) objects altogether, bake lighting instead.
</p>
<div class='vspace'></div><h2>Graphics Optimizing Summary</h2>
<ol><li>Use Occlusion culling excessively
</li><li>Keep vertex count below 10K per frame
</li><li>Use PVRTC texture compression
</li><li>Use combiners to mix two textures per fragment instead of multi-pass approach
</li><li>Prefer single texture instead of two per fragment
</li><li>Make sure you don't use lights when you don't need to - for example static light-mapped objects definitely don't need additional lighting
</li><li>Avoid alpha-testing, prefer alpha-blending instead
</li><li>Use skyboxes
</li></ol><div class='vspace'></div><h2>Optimizing Script performance</h2>
<p><a name='FixedDeltaTime' id='FixedDeltaTime'></a>
</p><h3>Reduce fixed delta time</h3>
<p>Use fixed delta time of 15-25 fps. You can change this in <span class='doc-menu'>Edit-&gt;Project Settings-&gt;Time</span>
This reduces how often <span class='wikiword'>FixedUpdate</span> is called and how often physics has to perform collision detection and rigidbody updates.
If you are using rigidbodies for the main character, you can enable interpolation in the Rigidbody Component to smooth out low fixed delta time steps.
</p>
<div class='vspace'></div><h3>Reduce <span class='wikiword'>GetComponent</span> calls in hotspots</h3>
<p>Using <span class='wikiword'>GetComponent</span> or builtin component accessors can have a noticable overhead. You can reduce it by caching a direct reference to the component.
</p>
<p class='vspace'>For example:
</p><pre class='codelisting'>
function Update () {
    transform.Translate(0, 1, 0);
}
</pre>
<p>You can optimize your script to this instead:
</p><pre class='codelisting'>
myTransform : Transform;
function Awake () {
   myTransform = transform;
}
function Update () {
    myTransform.Translate(0, 1, 0);
}
</pre>
<div class='vspace'></div><h3>Avoid allocating memory</h3>
<ol><li>Try avoiding any allocations during runtime from scripts.
</li><li>structs do not allocate memory, instead they are allocated on the stack and passed by value which is fast.
</li></ol><div class='vspace'></div><h3>Reduce GUI</h3>
<ol><li>Don't use <span class='wikiword'>GUILayout</span> use GUI functions instead and minimize the amount of GUI on screen
</li><li>Use <span class='wikiword'>MonoBehaviour</span>.useGUILayout = false; to minimize GUI overhead
</li></ol><pre class='codelisting'>
function Awake () {
    useGUILayout = false;
}
</pre>
<div class='vspace'></div><h3>Use iPhone Script Call optimization</h3>
<p>Most of the functions in <code><span class='wikiword'>UnityEngine</span></code> are implemented in C/C++. Calling such functions from scripts has additional performance overhead. Consider using <span style='font-size: 110%; font-weight: bold; color: yellow; background-color: red; padding: 2px;'>iPhone Script Call optimization</span> to gain several extra milliseconds per frame.
</p>

		<!-- #TemplateEndEditable -->	

		<div class="nav">
		<div class="nav-prev">
			<a href='../Components/Advanced Unity iPhone Tips.html'>
				<div class="nav-left"></div>
				<div class="nav-main">Previous</div>
				<div class="nav-right"></div>
			</a>
		</div>
	
		<div class="nav-next">
			<a href='../Components/Account Setup Help.html'>
				<div class="nav-left"></div>
				<div class="nav-main">Next</div>
				<div class="nav-right"></div>
			</a>
		</div>
	</div>
	</div>
</div>
</body></html>
<!-- #EndTemplate -->
